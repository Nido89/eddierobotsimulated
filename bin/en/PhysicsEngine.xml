<?xml version="1.0"?>
<doc>
    <assembly>
        "PhysicsEngine"
    </assembly>
    <members>
        <member name="M:Microsoft.Robotics.Simulation.Physics.JointBreakReport.onJointBreak(System.Single,NxJoint*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Gets called when a joint in the simulator breaks
</summary>
            <param name="breakingImpulse" />
            <param name="brokenJoint" />
        </member>
        <member name="T:PhysicsErrorStream">
@} 
</member>
        <member name="M:NxStream.storeDword(System.Int32)">
	\brief Store a signed dword(wrapper for the unsigned version).

	\param d DWord to store.
	\return Reference to the current NxStream object.

</member>
        <member name="M:NxStream.storeWord(System.Int16)">
	\brief Store a signed word(wrapper for the unsigned version).

	\param w Word to store.
	\return Reference to the current NxStream object.

</member>
        <member name="M:NxStream.storeByte(System.SByte)">
	\brief Store a signed byte(wrapper for the unsigned version).

	\param b Byte to store.
	\return Reference to the current NxStream object.

</member>
        <member name="M:NxStream.storeBuffer(System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
	\brief Called to write an array of bytes to the stream.

	\param[in] buffer Array of bytes, size bytes in size.
	\param[in] size Size, in bytes of buffer.
	\return Reference to the current NxStream object.

</member>
        <member name="M:NxStream.storeDouble(System.Double)">
	\brief Called to write a double precision floating point value to the stream(64 bits).

	\param f floating point value to store.
	\return Reference to the current NxStream object.

</member>
        <member name="M:NxStream.storeFloat(System.Single)">
	\brief Called to write a single precision floating point value to the stream(32 bits).

	\param f floating point value to store.
	\return Reference to the current NxStream object.

</member>
        <member name="M:NxStream.storeDword(System.UInt32)">
	\brief Called to write a single unsigned dword to the stream(32 bits).

	\param d DWord to store.
	\return Reference to the current NxStream object.

</member>
        <member name="M:NxStream.storeWord(System.UInt16)">
\brief Called to write a single unsigned word to the stream(16 bits).

\param w World to store.
\return Reference to the current NxStream object.

</member>
        <member name="M:NxStream.storeByte(System.Byte)">
	\brief Called to write a single unsigned byte to the stream(8 bits).

	\param b Byte to store.
	\return Reference to the current NxStream object.

</member>
        <member name="M:NxStream.readBuffer(System.Void*,System.UInt32)">
	\brief Called to read a number of bytes.

	\param[out] buffer Buffer to read bytes into, must be at least size bytes in size.
	\param[in] size The size of the buffer in bytes.

</member>
        <member name="M:NxStream.readDouble">
	\brief Called to read a double precision floating point value(64 bits)

	\return Floating point value read.

</member>
        <member name="M:NxStream.readFloat">
	\brief Called to read a single precision floating point value(32 bits)

	\return Floating point value read.

</member>
        <member name="M:NxStream.readDword">
	\brief Called to read a single unsigned dword(32 bits)

	\return DWord read.

</member>
        <member name="M:NxStream.readWord">
	\brief Called to read a single unsigned word(16 bits)

	\return Word read.

</member>
        <member name="M:NxStream.readByte">
	\brief Called to read a single unsigned byte(8 bits)

	\return Byte read.

</member>
        <member name="M:NxStream.Dispose">
\brief Virtual destructor.

</member>
        <member name="M:NxStream.#ctor">
\brief Empty constructor.

</member>
        <member name="M:NxCookingInterface.NxReportCooking">
\brief Report state of cooking memory usage.

</member>
        <member name="M:NxCookingInterface.NxScaleCookedConvexMesh(NxStream!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,NxStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Scales an existing cooked convex mesh and outputs it into another stream.

	\param[in] source The source cooked convex mesh to scale.
	\param[in] scale The uniform scale factor to apply to the convex mesh.
	\param[in] dest User stream to output the cooked data.
	\return true on success

	\note #NxInitCooking() must be called before attempting to cook a mesh. #NxCloseCooking() should be called
	when the application has finished using the cooking library.

	@see NxCookConvexMesh() NxCookTriangleMesh() NxInitCooking() NxSetCookingParams()

</member>
        <member name="M:NxCookingInterface.NxReleasePMap(NxPMap*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Releases PMap previously created with NxCreatePMap.

	\warning Legacy function

	You should not call this on PMap data you have loaded from
	disc yourself. Don't release a PMap while it is being used by a NxTriangleMesh object.

	\param[in] pmap Pmap to release.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxPMap NxTriangleMesh.loadPMap() NxConvexShape.loadPMap() NxCreatePMap

</member>
        <member name="M:NxCookingInterface.NxCreatePMap(NxPMap*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxTriangleMesh!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,NxUserOutputStream*)">
	\brief Creates a PMap from a triangle mesh.

	\warning Legacy function

	A PMap is an optional data structure which makes mesh-mesh collision 
	detection more robust at the cost of higher	memory consumption.

	This structure can then be assigned to NxTriangleMeshDesc::pmap or passed to NxTriangleMesh::loadPMap().

	You may wish to store the PMap on disk (just write the above data block to a file of your choice) after
	computing it because the creation process can be quite expensive. Then you won't have to create it the next time
	you need it.

	\param[out] pmap Used to store details of the created PMap.
	\param[in] mesh Mesh to create PMap from.
	\param[in] density The density(resolution) of the PMap.
	\param[in] outputStream User supplied interface for reporting errors and displaying messages(see NxUserOutputStream)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxPMap NxTriangleMesh.loadPMap() NxConvexShape.loadPMap() NxReleasePMap

</member>
        <member name="M:NxCookingInterface.NxCookSoftBodyMesh(NxSoftBodyMeshDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Cooks a tetrahedral mesh to a SoftBodyMesh.

	\param desc The soft body mesh descriptor on which the generation of the cooked mesh depends.
	\param stream The stream the cooked mesh is written to.
	\return True if cooking was successful

</member>
        <member name="M:NxCookingInterface.NxCookClothMesh(NxClothMeshDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Cooks a triangle mesh to a ClothMesh.

	\param desc The cloth mesh descriptor on which the generation of the cooked mesh depends.
	\param stream The stream the cooked mesh is written to.
	\return True if cooking was successful

</member>
        <member name="M:NxCookingInterface.NxCookConvexMesh(NxConvexMeshDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Cooks a convex mesh. The results are written to the stream.

	To create a triangle mesh object(unlike previous versions) it is necessary to first 'cook' the mesh data into
	a form which allows the SDK to perform efficient collision detection.

	NxCookTriangleMesh() and NxCookConvexMesh() allow a mesh description to be cooked into a binary stream
	suitable for loading and performing collision detection at runtime.

	\note #NxInitCooking() must be called before attempting to cook a mesh. NxCloseCooking() should be called
	when the application has finished using the cooking library.

	Example

	\include NxCookConvexMesh_Example.cpp

	\param[in] desc The convex mesh descriptor to read the mesh from.
	\param[in] stream User stream to output the cooked data.
	\return true on success

	@see NxCookTriangleMesh() NxInitCooking() NxSetCookingParams()

</member>
        <member name="M:NxCookingInterface.NxCookTriangleMesh(NxTriangleMeshDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Cooks a triangle mesh. The results are written to the stream.

	To create a triangle mesh object(unlike previous versions) it is necessary to first 'cook' the mesh data into
	a form which allows the SDK to perform efficient collision detection.

	NxCookTriangleMesh() and NxCookConvexMesh() allow a mesh description to be cooked into a binary stream
	suitable for loading and performing collision detection at runtime.

	NxCookConvex requires the input mesh to form a closed convex volume. This allows more efficient and robust
	collision detection.

	\note #NxInitCooking() must be called before attempting to cook a mesh. NxCloseCooking() should be called
	when the application has finished using the cooking library.

	Example

	\include NxCookTriangleMesh_Example.cpp

	\param[in] desc The triangle mesh descriptor to read the mesh from.
	\param[in] stream User stream to output the cooked data.
	\return true on success

	@see NxCookTriangleMesh() NxInitCooking() NxSetCookingParams()

</member>
        <member name="M:NxCookingInterface.NxCloseCooking">
	\brief Closes cooking.

	This must be called at the end of your app, to release cooking-related data.

	@see NxInitCooking()

</member>
        <member name="M:NxCookingInterface.NxInitCooking(NxUserAllocator*,NxUserOutputStream*)">
	\brief Initializes cooking.

	This must be called at least once, before any cooking method is called (otherwise cooking fails) and
	should be matched with a call to NxCloseCooking() before you remove the allocator or output stream
	objects.

	Please note that this also initializes the Foundation SDK. This is not an issue, unless you are linking
	the AGEIA PhysX SDK using static libraries. When you are using static libraries, the cooking library
	will share the same Foundation SDK as the rest of the application and this you will have to consider
	when initializing the cooking library. In statically linked applications, you should specify the same
	allocator and error stream to NxInitCooking() and NxCreatePhysicsSDK(). You are not compelled to
	do so, but should be aware of the possible issues that could arise if you specify different values.
	A common error would be to specify a user error stream when creating the Physics SDK, but omit it
	when initializing the cooking, thus resulting in no error stream if the cooking is initialized last.

	The previous state of the cooking initialization is stored in a stack each time you call NxInitCooking()
	and when you call NxCloseCooking() the previous state is activated again. The "state" that is saved is the 
	allocator and output stream settings. The stack size is currently 32 states, which means that you can 
	not call NxInitCooking() 33 consecutive times without at least one call to NxCloseCooking() in between.

	Note: Cooking parameters (as set by NxSetCookingParams) are reset by this function. You should call NxSetCookingParams
	after this function, not before.

	\param[in] allocator The memory allocator to use.
	\param[in] outputStream The output stream to use.
	\return true on success.

	@see NxCloseCooking()

</member>
        <member name="M:NxCookingInterface.NxGetCookingParams">
	\brief Gets cooking parameters

	\return Current cooking parameters.

	@see NxCookingParams NxSetCookingParams()

</member>
        <member name="M:NxCookingInterface.NxSetCookingParams(NxCookingParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets cooking parameters

	\note #NxInitCooking() sets the parameters to their default values.

	\param[in] params Cooking parameters

	\return true on success.

	@see NxCookingParams NxGetCookingParams()

</member>
        <member name="M:NxCookSoftBodyMesh(NxSoftBodyMeshDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Cooks a tetrahedral mesh to a SoftBodyMesh.

	\param desc The soft body mesh descriptor on which the generation of the cooked mesh depends.
	\param stream The stream the cooked mesh is written to.
	\return True if cooking was successful

</member>
        <member name="M:NxCookClothMesh(NxClothMeshDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Cooks a triangle mesh to a ClothMesh.

	\param desc The cloth mesh descriptor on which the generation of the cooked mesh depends.
	\param stream The stream the cooked mesh is written to.
	\return True if cooking was successful

</member>
        <member name="M:NxReportCooking">
\brief Report state of cooking memory usage.

</member>
        <member name="M:NxScaleCookedConvexMesh(NxStream!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,NxStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Scales an existing cooked convex mesh and outputs it into another stream.

	\note #NxInitCooking() must be called before attempting to cook a mesh. #NxCloseCooking() should be called
	when the application has finished using the cooking library.

	\param[in] source The source cooked convex mesh to scale.
	\param[in] scale The uniform scale factor to apply to the convex mesh.
	\param[in] dest User stream to output the cooked data.
	\return true on success

	@see NxCookConvexMesh() NxCookTriangleMesh() NxInitCooking() NxSetCookingParams()

</member>
        <member name="M:NxCookConvexMesh(NxConvexMeshDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Cooks a convex mesh. The results are written to the stream.

	To create a triangle mesh object(unlike previous versions) it is necessary to first 'cook' the mesh data into
	a form which allows the SDK to perform efficient collision detection.

	NxCookTriangleMesh() and NxCookConvexMesh() allow a mesh description to be cooked into a binary stream
	suitable for loading and performing collision detection at runtime.

	\note #NxInitCooking() must be called before attempting to cook a mesh. NxCloseCooking() should be called
	when the application has finished using the cooking library.

	Example

	\include NxCookConvexMesh_Example.cpp

	\param[in] desc The convex mesh descriptor to read the mesh from.
	\param[in] stream User stream to output the cooked data.
	\return true on success

	@see NxCookTriangleMesh() NxInitCooking() NxSetCookingParams()

</member>
        <member name="M:NxCookTriangleMesh(NxTriangleMeshDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Cooks a triangle mesh. The results are written to the stream.

	To create a triangle mesh object(unlike previous versions) it is necessary to first 'cook' the mesh data into
	a form which allows the SDK to perform efficient collision detection.

	NxCookTriangleMesh() and NxCookConvexMesh() allow a mesh description to be cooked into a binary stream
	suitable for loading and performing collision detection at runtime.

	NxCookConvex requires the input mesh to form a closed convex volume. This allows more efficient and robust
	collision detection.

	\note #NxInitCooking() must be called before attempting to cook a mesh. NxCloseCooking() should be called
	when the application has finished using the cooking library.

	Example

	\include NxCookTriangleMesh_Example.cpp

	\param[in] desc The triangle mesh descriptor to read the mesh from.
	\param[in] stream User stream to output the cooked data.
	\return true on success

	@see NxCookTriangleMesh() NxInitCooking() NxSetCookingParams()

</member>
        <member name="M:NxCloseCooking">
	\brief Closes cooking.

	This must be called at the end of your app, to release cooking-related data.

	@see NxInitCooking()

</member>
        <member name="M:NxInitCooking(NxUserAllocator*,NxUserOutputStream*)">
	\brief Initializes cooking.

	This must be called at least once, before any cooking method is called (otherwise cooking fails) and
	should be matched with a call to NxCloseCooking() before you remove the allocator or output stream
	objects.

	Please note that this also initializes the Foundation SDK. This is not an issue, unless you are linking
	the AGEIA PhysX SDK using static libraries. When you are using static libraries, the cooking library
	will share the same Foundation SDK as the rest of the application and this you will have to consider
	when initializing the cooking library. In statically linked applications, you should specify the same
	allocator and error stream to NxInitCooking() and NxCreatePhysicsSDK(). You are not compelled to
	do so, but should be aware of the possible issues that could arise if you specify different values.
	A common error would be to specify a user error stream when creating the Physics SDK, but omit it
	when initializing the cooking, thus resulting in no error stream if the cooking is initialized last.

	The previous state of the cooking initialization is stored in a stack each time you call NxInitCooking()
	and when you call NxCloseCooking() the previous state is activated again. The "state" that is saved is the 
	allocator and output stream settings. The stack size is currently 32 states, which means that you can 
	not call NxInitCooking() 33 consecutive times without at least one call to NxCloseCooking() in between.

	Note: Cooking parameters (as set by NxSetCookingParams) are reset by this function. You should call NxSetCookingParams
	after this function, not before.

	\param[in] allocator The memory allocator to use.
	\param[in] outputStream The output stream to use.
	\return true on success.

	@see NxCloseCooking()

</member>
        <member name="M:NxGetCookingParams">
	\brief Gets cooking parameters

	\return Current cooking parameters.

	@see NxCookingParams NxSetCookingParams()

</member>
        <member name="M:NxSetCookingParams(NxCookingParams!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets cooking parameters

	\note #NxInitCooking() sets the parameters to their default values.

	\param[in] params Cooking parameters

	\return true on success.

	@see NxCookingParams NxGetCookingParams()

</member>
        <member name="F:NxCookingParams.hintCollisionSpeed">
		\brief Hint to choose speed or less memory for collision structures

		<b>Default value:</b> false

</member>
        <member name="F:NxCookingParams.skinWidth">
		\brief Skin width for convexes

		Specifies the amount to inflate the convex mesh by when the new convex hull generator is used
		(the skinWidth is ignored when using the legacy convex hull generator, enable with NX_CF_USE_LEGACY_COOKER).

		Inflating the mesh allows the user to hide interpenetration errors by increasing the size of the
		collision mesh with respect to the size of the rendered geometry.

		<b>Default value:</b> 0.025f

</member>
        <member name="F:NxCookingParams.targetPlatform">
		\brief Target platform

		Should be set to the platform which you intend to load the cooked mesh data on. This allows
		the SDK to optimize the mesh data in an appropriate way for the platform and make sure that
		endianness issues are accounted for correctly.

		<b>Default value:</b> Same as the platform on which the SDK is running.

</member>
        <member name="T:NxCookingParams">

	\brief Structure describing parameters affecting mesh cooking.

	@see NxSetCookingParams() NxGetCookingParams()

</member>
        <member name="M:NxCrc32(System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
\brief Computes CRC of input buffer

\warning #NxCreatePhysicsSDK() must be called before using this function.

\param buffer Input buffer.
\param nbBytes Number of bytes in in the input buffer.
\return The computed CRC.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxComputeBounds(NxBounds3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,NxVec3!System.Runtime.CompilerServices.IsConst*)">
\brief Computes bounds of an array of vertices

\warning #NxCreatePhysicsSDK() must be called before using this function.

\param bounds Computed bounds.
\param nbVerts Number of input vertices.
\param verts Array of vertices.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

@see NxBounds3

</member>
        <member name="M:NxComputeBounds(NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,NxVec3!System.Runtime.CompilerServices.IsConst*)">
\brief Computes bounds of an array of vertices

\warning #NxCreatePhysicsSDK() must be called before using this function.

\param min Computed minimum of the bounds.
\param max Maximum
\param nbVerts Number of input vertices.
\param verts Array of vertices.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

@see NxBounds3

</member>
        <member name="M:NxFindRotationMatrix(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat33*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief  Computes a rotation matrix.

computes rotation matrix M so that:

M * x = b

x and b are unit vectors.

\warning #NxCreatePhysicsSDK() must be called before using this function.

\param x Vector.
\param b Vector.
\param M Computed rotation matrix.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxDiagonalizeInertiaTensor(NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat33*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Rotates a 3x3 symmetric inertia tensor I into a space R where it can be represented with the diagonal matrix D.

I = R * D * R'

Returns false on failure. 

\warning #NxCreatePhysicsSDK() must be called before using this function.

\param denseInertia The dense inertia tensor.
\param diagonalInertia The diagonalized inertia tensor.
\param rotation Rotation for the frame of the diagonalized inertia tensor.

\return True if the inertia tensor can be diagonalized.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxNormalToTangents(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Get the tangent vectors associated with a normal.

\warning #NxCreatePhysicsSDK() must be called before using this function.

\param n Normal vector
\param t1 First tangent
\param t2 Second tangent

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxMergeSpheres(NxSphere*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxSphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxSphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Compute an overall bounding sphere for a pair of spheres.

\warning #NxCreatePhysicsSDK() must be called before using this function.

\param merged The computed sphere.
\param sphere0 First sphere.
\param sphere1 Second sphere.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

@see NxSphere NxComputeSphere

</member>
        <member name="M:NxFastComputeSphere(NxSphere*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,NxVec3!System.Runtime.CompilerServices.IsConst*)">
\brief Compute a bounding sphere for a point cloud.

The sphere may not be as tight as #NxComputeSphere

\warning #NxCreatePhysicsSDK() must be called before using this function.

\param sphere The computed sphere.
\param nb_verts Number of points.
\param verts Array of points.

\return True on success.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

@see NxSphere NxComputeSphere

</member>
        <member name="M:NxComputeSphere(NxSphere*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,NxVec3!System.Runtime.CompilerServices.IsConst*)">
\brief Compute a bounding sphere for a point cloud.

\warning #NxCreatePhysicsSDK() must be called before using this function.

\param sphere The computed sphere.
\param nb_verts Number of points.
\param verts Array of points.

\return The method used to compute the sphere, see #NxBSphereMethod.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

@see NxSphere NxFastComputeSphere

</member>
        <member name="M:NxComputeSquareDistance(NxSegment!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*)">
\brief Compute the distance squared from a point to a line segment.

\warning #NxCreatePhysicsSDK() must be called before using this function.

\param seg The line segment.
\param point The point.
\param t Used to retrieve the closest parameter value on the line segment.

\return The squared distance.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

@see NxSegment

</member>
        <member name="M:NxComputeDistanceSquared(NxRay!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*)">
\brief Compute the distance squared from a point to a ray.

\warning #NxCreatePhysicsSDK() must be called before using this function.

\param ray The ray.
\param point The point.
\param t Used to retrieve the closest parameter value on the ray.

\return The squared distance.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

@see NxRay

</member>
        <member name="M:NxIntCeil(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Convert a floating point number to an integer.

\warning #NxCreatePhysicsSDK() must be called before using this function.

\param f Floating point number.

\return The result.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxIntFloor(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Convert a floating point number to an integer.

\warning #NxCreatePhysicsSDK() must be called before using this function.

\param f Floating point number.

\return The result.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxIntChop(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Convert a floating point number to an integer.

\warning #NxCreatePhysicsSDK() must be called before using this function.

\param f Floating point number.

\return The result.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxSetFPUExceptions(System.Boolean)">
\brief Enable/Disable FPU exception.

\warning #NxCreatePhysicsSDK() must be called before using this function.

\param b True to enable exception.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxSetFPURoundingNear">
\brief Set FPU rounding mode.

\warning #NxCreatePhysicsSDK() must be called before using this function.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxSetFPURoundingDown">
\brief Set FPU rounding mode.

\warning #NxCreatePhysicsSDK() must be called before using this function.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxSetFPURoundingUp">
\brief Set FPU rounding mode.

\warning #NxCreatePhysicsSDK() must be called before using this function.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxSetFPURoundingChop">
\brief Set FPU precision.

\warning #NxCreatePhysicsSDK() must be called before using this function.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxSetFPUPrecision64">
\brief Set FPU precision

\warning #NxCreatePhysicsSDK() must be called before using this function.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxSetFPUPrecision53">
\brief Set FPU precision.

\warning #NxCreatePhysicsSDK() must be called before using this function.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxSetFPUPrecision24">
\brief Set FPU precision.

\warning #NxCreatePhysicsSDK() must be called before using this function.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxComputeBoxAroundCapsule(NxCapsule!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxBox*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Compute a box which encloses a capsule.

\warning #NxCreatePhysicsSDK() must be called before using this function.

\param capsule Capsule to generate an enclosing box for.
\param box Generated box.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

@see NxComputeCapsuleAroundBox

</member>
        <member name="M:NxBoxVertexToQuad(System.UInt32)">
\brief Returns a list of quad indices sharing the vertex index.

\warning #NxCreatePhysicsSDK() must be called before using this function.

\param vertexIndex Vertex Index.
\return List of quad indices sharing the vertex index.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

@see NxComputeBoxPoints() NxGetBoxQuads()

</member>
        <member name="M:NxGetBoxQuads">
\brief Get a list of indices representing the box as quads.

\warning #NxCreatePhysicsSDK() must be called before using this function.

\return List of quad indices.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

@see NxComputeBoxPoints()

</member>
        <member name="M:NxIsBoxAInsideBoxB(NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Test if box A is inside another box B.

\warning #NxCreatePhysicsSDK() must be called before using this function.

\param a Box A
\param b Box B

\return True if box A is inside box B.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

@see NxBox

</member>
        <member name="M:NxComputeCapsuleAroundBox(NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxCapsule*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">

\brief Compute a capsule which encloses a box.

\warning #NxCreatePhysicsSDK() must be called before using this function.

\param box Box to generate capsule for.
\param capsule Stores the capsule which is generated.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

@see NxBox NxCapsule NxComputeBoxAroundCapsule

</member>
        <member name="M:NxComputeBoxWorldEdgeNormal(NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Compute and edge normals for an oriented box.

This is an averaged normal, from the two faces sharing the edge.

The edge index should be from 0 to 11 (i.e. a box has 12 edges).

Edge ordering:

\image html boxEdgeDiagram.png

\warning #NxCreatePhysicsSDK() must be called before using this function.

\param[in] box The oriented box.
\param[in] edge_index The index of the edge to compute a normal for.
\param[out] world_normal The computed normal.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxGetBoxLocalEdgeNormals">
\brief Returns a list of local space edge normals.

\warning #NxCreatePhysicsSDK() must be called before using this function.

\return List of edge normals.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxGetBoxTriangles">
\brief Return a set of triangle indices suitable for use with #NxComputeBoxPoints.

\warning #NxCreatePhysicsSDK() must be called before using this function.

\return List of box triangles.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

@see NxComputeBoxPoints

</member>
        <member name="M:NxGetBoxEdgesAxes">
\brief Return a list of box edge axes.

\warning #NxCreatePhysicsSDK() must be called before using this function.

\return List of box edge axes.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

@see NxComputeBoxPoints

</member>
        <member name="M:NxGetBoxEdges">
\brief Return a list of edge indices.

\warning #NxCreatePhysicsSDK() must be called before using this function.

\return List of edge indices.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

@see NxComputeBoxPoints

</member>
        <member name="M:NxComputeBoxVertexNormals(NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*)">

\brief Compute the vertex normals of an oriented box. These are smooth normals, i.e. averaged from the faces of the box.

\warning #NxCreatePhysicsSDK() must be called before using this function.

\param[in] box The oriented box.
\param[out] pts The normals for each vertex(should be large enough to hold 8 normals).

\return True on success.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

@see NxBox

</member>
        <member name="M:NxComputeBoxPoints(NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*)">

\brief Compute the corner points of an oriented box.

\warning #NxCreatePhysicsSDK() must be called before using this function.

\param[in] box The oriented box.
\param[out] pts Array to receive the box point (should be large enough to hold 8 points)

\return True on success.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

@see NxBox

</member>
        <member name="M:NxComputeBoxPlanes(NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxPlane*)">

\brief Computes plane equation for each face of an oriented box.

\warning #NxCreatePhysicsSDK() must be called before using this function.

\param[in] box The oriented box.
\param[out] planes Array to receive the computed planes(should be large enough to hold 6 planes)

\return True on success.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

@see NxBox NxPlane

</member>
        <member name="M:NxCreateBox(NxBox*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat34!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">

\brief Create an oriented box from an axis aligned box and a transformation.

\warning #NxCreatePhysicsSDK() must be called before using this function.

\param[out] box Used to store the oriented box.
\param[in] aabb Axis aligned box.
\param[in] mat Transformation to apply to the axis aligned box.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

@see NxBox NxBounds3

</member>
        <member name="M:NxBoxContainsPoint(NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">

\brief Test if an oriented box contains a point.

\warning #NxCreatePhysicsSDK() must be called before using this function.

\param[in] box Oriented Box to test point against.
\param[in] p Point to test. 

\return True if the box contains p.

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

@see NxBox

</member>
        <member name="T:NxIntegrals">
@} 
\addtogroup physics
  @{

</member>
        <member name="T:NxAllocateable">
@} 
\addtogroup physics
  @{

\brief Subclasses of this base class automatically take part in user memory management.

</member>
        <member name="M:NxBuildSmoothNormals(System.UInt32,System.UInt32,NxVec3!System.Runtime.CompilerServices.IsConst*,System.UInt32!System.Runtime.CompilerServices.IsConst*,System.UInt16!System.Runtime.CompilerServices.IsConst*,NxVec3*,System.Boolean)">
@} 
\addtogroup physics
  @{

	\brief Builds smooth vertex normals over a mesh.

	- "smooth" because smoothing groups are not supported here
	- takes angles into account for correct cube normals computation

	To use 32bit indices pass a pointer in dFaces and set wFaces to zero. Alternatively pass a pointer to 
	wFaces and set dFaces to zero.

	\warning #NxCreatePhysicsSDK() must be called before using this function.

	\param[in] nbTris Number of triangles
	\param[in] nbVerts Number of vertices
	\param[in] verts Array of vertices
	\param[in] dFaces Array of dword triangle indices, or null
	\param[in] wFaces Array of word triangle indices, or null
	\param[out] normals Array of computed normals (assumes nbVerts vectors)
	\param[in] flip Flips the normals or not

	\return True on success.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxReleasePMap(NxPMap*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Releases PMap previously created with NxCreatePMap.
	
	\warning Legacy function

	You should not call this on PMap data you have loaded from
	disc yourself. Don't release a PMap while it is being used by a NxTriangleMesh object.

	\param[in] pmap Pmap to release.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxPMap NxTriangleMesh.loadPMap() NxConvexShape.loadPMap() NxCreatePMap

</member>
        <member name="M:NxCreatePMap(NxPMap*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxTriangleMesh!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,NxUserOutputStream*)">
	\brief Creates a PMap from a triangle mesh.
	
	\warning Legacy function

	A PMap is an optional data structure which makes mesh-mesh collision 
	detection more robust at the cost of higher	memory consumption.
	
	This structure can then be assigned to NxTriangleMeshDesc::pmap or passed to NxTriangleMesh::loadPMap().

	You may wish to store the PMap on disk (just write the above data block to a file of your choice) after
	computing it because the creation process can be quite expensive. Then you won't have to create it the next time
	you need it.

	\param[out] pmap Used to store details of the created PMap.
	\param[in] mesh Mesh to create PMap from.
	\param[in] density The density(resolution) of the PMap.
	\param[in] outputStream User supplied interface for reporting errors and displaying messages(see #NxUserOutputStream)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxPMap NxTriangleMesh.loadPMap() NxConvexShape.loadPMap() NxReleasePMap

</member>
        <member name="T:NxPMap">
@} 
\addtogroup physics
  @{

\brief PMap data structure for mesh collision detection.

\warning Legacy class

Used by the functions NxCreatePMap and NxReleasePMap.

This structure can be assigned to NxTriangleMeshDesc::pmap or passed to NxTriangleMesh::loadPMap().

<h3>Creation</h3>

Example:

\include NxPMap_Create.cpp

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes (Software fallback)
\li PS3  : Yes
\li XB360: Yes

@see NxTriangleMesh.loadPMap() NxConvexShape.loadPMap()

</member>
        <member name="M:NxSweptSpheresIntersect(NxSphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxSphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@} 
\addtogroup physics
  @{

	\brief Sphere-sphere sweep test.
	
	Returns true if spheres intersect during their linear motion along provided velocity vectors.

	\warning #NxCreatePhysicsSDK() must be called before using this function.

	\param[in] sphere0 First sphere to test. <b>Range:</b> See #NxSphere
	\param[in] velocity0 Velocity of the first sphere(ie the vector to sweep the sphere along). <b>Range:</b> velocity/direction vector
	\param[in] sphere1 Second sphere to test <b>Range:</b> See #NxSphere
	\param[in] velocity1 Velocity of the second sphere(ie the vector to sweep the sphere along). <b>Range:</b> velocity/direction vector

	\return True if spheres intersect.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSphere

</member>
        <member name="M:NxSegmentCapsuleIntersect(NxSegment!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxCapsule!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*,System.Single*)">
	\brief Segment-capsule intersection test.
	
	Returns number of intersection points (0,1 or 2) and corresponding parameters along the ray.

	\warning #NxCreatePhysicsSDK() must be called before using this function.

	\param[in] segment Line segment. <b>Range:</b> See #NxSegment
	\param[in] capsule Capsule to test. <b>Range:</b> See #NxCapsule
	\param[out] nbImpacts Number of intersection point (0, 1 or 2)
	\param[out] t Parameter of intersection on the ray.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSegement NxCapsule

</member>
        <member name="M:NxRayCapsuleIntersect(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxCapsule!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*)">
@} 
\addtogroup physics
  @{

	\brief Ray-capsule intersection test.
	
	Returns number of intersection points (0,1 or 2) and corresponding parameters along the ray.

	\warning #NxCreatePhysicsSDK() must be called before using this function.

	\param[in] origin Origin of ray. <b>Range:</b> position vector
	\param[in] dir Direction of ray. <b>Range:</b> direction vector
	\param[in] capsule Capsule to test. <b>Range:</b> see #NxCapsule
	\param[out] t Parameter of intersection on the ray.

	\return Number of intersection points.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxRay NxCapsule

</member>
        <member name="M:NxRayOBBIntersect(NxRay!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Boolean ray-OBB intersection test.
	
	Based on separating axis theorem.

	\warning #NxCreatePhysicsSDK() must be called before using this function.

	\param[in] ray Ray to test against OBB. <b>Range:</b> See #NxRay
	\param[in] center Center point of OBB. <b>Range:</b> position vector
	\param[in] extents Extent/Radii of the OBB. <b>Range:</b> direction vector
	\param[in] rot Rotation of the OBB(applied before translation). <b>Range:</b> rotation matrix

	\return True on intersection.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxSegmentAABBIntersect(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Boolean segment-AABB intersection test.
	
	Based on separating axis theorem.

	\warning #NxCreatePhysicsSDK() must be called before using this function.

	\param[in] p0 First point of line segment. <b>Range:</b> position vector
	\param[in] p1 Second point of line segment. <b>Range:</b> position vector
	\param[in] min Minimum extent of AABB. <b>Range:</b> position vector
	\param[in] max Maximum extent of AABB. <b>Range:</b> position vector

	\return True if the segment and AABB intersect.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxSegmentOBBIntersect(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Boolean segment-OBB intersection test.
	
	Based on separating axis theorem.

	\warning #NxCreatePhysicsSDK() must be called before using this function.

	\param[in] p0 First point of line segment. <b>Range:</b> position vector
	\param[in] p1 Second point of line segment. <b>Range:</b> position vector
	\param[in] center Center point of OBB. <b>Range:</b> position vector
	\param[in] extents Extent/Radii of the OBB. <b>Range:</b> direction vector
	\param[in] rot Rotation of the OBB(applied before translation). <b>Range:</b> rotation matrix

	\return true if the segment and OBB intersect.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxRayAABBIntersect2(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Extended Ray-AABB intersection test.
	
	Also computes intersection point, and parameter and returns contacted box axis index+1. Rays starting from inside the box are ignored.
	
	\warning #NxCreatePhysicsSDK() must be called before using this function.

	\param[in] min Minimum extent of AABB. <b>Range:</b> position vector
	\param[in] max Maximum extent of AABB. <b>Range:</b> position vector
	\param[in] origin Origin of ray. <b>Range:</b> position vector
	\param[in] dir Direction of ray. <b>Range:</b> direction vector
	\param[out] coord Intersection point.
	\param[out] t Ray parameter corresponding to contact point.

	\return Box axis index.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxRayAABBIntersect(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Ray-AABB intersection test.
	
	Also computes intersection point.

	\warning #NxCreatePhysicsSDK() must be called before using this function.

	\param[in] min Minimum extent of AABB. <b>Range:</b> position vector
	\param[in] max Maximum extent of AABB. <b>Range:</b> position vector
	\param[in] origin Origin of ray. <b>Range:</b> position vector
	\param[in] dir Direction of ray. <b>Range:</b> direction vector
	\param[out] coord Intersection point.

	\return True if the ray and AABB intersect.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxSegmentBoxIntersect(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Segment-AABB intersection test.
	
	Also computes intersection point.

	\warning #NxCreatePhysicsSDK() must be called before using this function.

	\param[in] p1 First point of line segment. <b>Range:</b> position vector
	\param[in] p2 Second point of line segment. <b>Range:</b> position vector
	\param[in] bbox_min Minimum extent of AABB. <b>Range:</b> position vector
	\param[in] bbox_max Max extent of AABB. <b>Range:</b> position vector
	\param[out] intercept Intersection point between segment and box.

	\return True if the segment and AABB intersect.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxRayTriIntersect(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
@} 
\addtogroup physics
  @{

	\brief Ray-triangle intersection test.
	
	Returns impact distance (t) as well as barycentric coordinates (u,v) of impact point.
	Use NxComputeBarycentricPoint() in Foundation to compute the impact point from the barycentric coordinates.
	The test performs back face culling or not according to 'cull'.

	\warning #NxCreatePhysicsSDK() must be called before using this function.

	\param[in] orig Origin of the ray. <b>Range:</b> position vector
	\param[in] dir Direction of the ray. <b>Range:</b> direction vector
	\param[in] vert0 First vertex of triangle. <b>Range:</b> position vector
	\param[in] vert1 Second vertex of triangle. <b>Range:</b> position vector
	\param[in] vert2 Third vertex of triangle. <b>Range:</b> position vector
	\param[out] t Distance along the ray from the origin to the impact point.
	\param[out] u Barycentric coordinate.
	\param[out] v Barycentric coordinate.
	\param[in] cull Cull backfaces.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxRaySphereIntersect(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@} 
\addtogroup physics
  @{

	\brief Ray-sphere intersection test.
	
	Returns true if the ray intersects the sphere, and the impact point if needed.

	\warning #NxCreatePhysicsSDK() must be called before using this function.

	\param[in] origin Origin of the ray. <b>Range:</b> position vector
	\param[in] dir Direction of the ray. <b>Range:</b> direction vector
	\param[in] length Length of the ray. <b>Range:</b> (0,inf)
	\param[in] center Center of the sphere. <b>Range:</b> position vector
	\param[in] radius Sphere radius. <b>Range:</b> (0,inf)
	\param[out] hit_time Distance of intersection between ray and sphere.
	\param[out] hit_pos Point of intersection between ray and sphere.

	\return True on intersection.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxRayPlaneIntersect(NxRay!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxPlane!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Ray-plane intersection test.
	
	Returns distance between ray origin and impact point, as well as impact point on plane.

	\warning #NxCreatePhysicsSDK() must be called before using this function.

	\param[in] ray Ray to test against plane. <b>Range:</b> See #NxRay
	\param[in] plane Plane to test. <b>Range:</b> See #NxPlane
	\param[out] dist Distance along ray to impact point (so pointOnPlane=Normalize(v2-v1)*dist).
	\param[out] pointOnPlane Impact point on the plane.

	\return True on intersection.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxSegmentPlaneIntersect(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxPlane!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Segment-plane intersection test.
	
	Returns distance between v1 and impact point, as well as impact point on plane.

	\warning #NxCreatePhysicsSDK() must be called before using this function.

	\param[in] v1 First vertex of segment. <b>Range:</b> position vector
	\param[in] v2 Second vertex of segment. <b>Range:</b> position vector
	\param[in] plane Plane to test against. <b>Range:</b> See #NxPlane
	\param[out] dist Distance from v1 to impact point (so pointOnPlane=Normalize(v2-v1)*dist).
	\param[out] pointOnPlane Imapct point on plane.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxPointTriangleIntersect2D(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
	\brief Dedicated 2D version of previous test

	\param[in] px Point to test, X
	\param[in] pz Point to test, Z
	\param[in] p0x Vertex of triangle to test, X
	\param[in] p0z Vertex of triangle to test, Z
	\param[in] e10x Edge of triangle to test, X
	\param[in] e10z Edge of triangle to test, Y
	\param[in] e20x Second edge of triangle to test, X
	\param[in] e20z Second edge of triangle to test, Y

	\return True on intersection

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxPointTriangleIntersect

</member>
        <member name="M:NxPointTriangleIntersect(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@} 
\addtogroup physics
  @{

	\brief Point-in-triangle test.
	
	We use the edges as parameters in case the user has access to edges directly
	This is actually a "point-in-prism" test since it returns true as long as the point is bound by the edge planes.

	\param[in] p Point to test. <b>Range:</b> position vector
	\param[in] p0 Triangle vertex. <b>Range:</b> position vector
	\param[in] edge10 Triangle edge. <b>Range:</b> direction vector
	\param[in] edge20 Second triangle edge. <b>Range:</b> direction vector
	
	\return True on intersection

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxPointTriangleIntersect2D

</member>
        <member name="M:NxSeparatingAxis(NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
	\brief Computes the separating axis between two OBBs.

	\param[in] obb0 First Oriented Bounding box. <b>Range:</b> See #NxBox
	\param[in] obb1 Second Oriented Bounding box. <b>Range:</b> See #NxBox
	\param[in] fullTest If false test only the first 6 axis.

	\return The separating axis.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSepAxis

</member>
        <member name="M:NxSeparatingAxis(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
	\brief Computes the separating axis between two OBBs.

	\param[in] extents0 Extents/radii of first box before transformation. <b>Range:</b> direction vector
	\param[in] center0 Center of box first box. <b>Range:</b> position vector
	\param[in] rotation0 Rotation to apply to first box (before translation). <b>Range:</b> rotation matrix
	\param[in] extents1 Extents/radii of second box before transformation. <b>Range:</b> direction vector
	\param[in] center1 Center of second box. <b>Range:</b> position vector
	\param[in] rotation1 Rotation to apply to second box (before translation). <b>Range:</b> rotation matrix
	\param[in] fullTest If false test only the first 6 axis.

	\return The separating axis or NX_SEP_AXIS_OVERLAP for an overlap.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSepAxis

</member>
        <member name="M:NxBoxBoxIntersect(NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
	\brief Boolean intersection test between two OBBs.
	
	Uses the separating axis theorem. Disabling 'full_test' only performs 6 axis tests out of 15.

	\param[in] obb0 First Oriented Bounding Box. <b>Range:</b> See #NxBox
	\param[in] obb1 Second Oriented Bounding Box. <b>Range:</b> See #NxBox
	\param[in] fullTest If false test only the first 6 axis.

	\return true on intersection

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBox

</member>
        <member name="M:NxBoxBoxIntersect(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
@} 
\addtogroup physics
  @{

	\brief Boolean intersection test between two OBBs.
	
	Uses the separating axis theorem. Disabling 'full_test' only performs 6 axis tests out of 15.

	\param[in] extents0 Extents/radii of first box before transformation. <b>Range:</b> direction vector
	\param[in] center0 Center of first box. <b>Range:</b> position vector
	\param[in] rotation0 Rotation to apply to first box (before translation). <b>Range:</b> rotation matrix
	\param[in] extents1 Extents/radii of second box before transformation <b>Range:</b> direction vector
	\param[in] center1 Center of second box. <b>Range:</b> position vector
	\param[in] rotation1 Rotation to apply to second box(before translation). <b>Range:</b> rotation matrix
	\param[in] fullTest If false test only the first 6 axis.

	\return true on intersection

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxComputeSphereInertiaTensor(NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,System.Boolean)">
	\brief Computes diagonalized inertia tensor for a sphere.

	\warning #NxCreatePhysicsSDK() must be called before using this function.

	\param[out] diagInertia The diagonalized inertia tensor.
	\param[in] mass The mass. <b>Range:</b> (0,inf)
	\param[in] radius The radius. <b>Range:</b> (-inf,inf)
	\param[in] hollow True to treat the sphere as a hollow shell. 

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxComputeBoxInertiaTensor(NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,System.Single,System.Single)">
	\brief Computes diagonalized inertia tensor for a box.

	\warning #NxCreatePhysicsSDK() must be called before using this function.

	\param[out] diagInertia The diagonalized inertia tensor.
	\param[in] mass The mass of the box. <b>Range:</b> (0,inf)
	\param[in] xlength The width of the box. <b>Range:</b> (-inf,inf)
	\param[in] ylength The height. <b>Range:</b> (-inf,inf)
	\param[in] zlength The depth. <b>Range:</b> (-inf,inf)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxComputeConeDensity(System.Single,System.Single,System.Single)">
	\brief Computes density of a homogeneous cone according to cone mass.

	\warning #NxCreatePhysicsSDK() must be called before using this function.

	\param[in] radius The radius of the cone. <b>Range:</b> (0,inf)
	\param[in] length The length. <b>Range:</b> (0,inf)
	\param[in] mass The mass. <b>Range:</b> (0,inf)

	\return The density.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxComputeConeMass(System.Single,System.Single,System.Single)">
	\brief Computes mass of a homogeneous cone according to cone density.

	\warning #NxCreatePhysicsSDK() must be called before using this function.

	\param[in] radius The radius of the cone. <b>Range:</b> (0,inf)
	\param[in] length The length. <b>Range:</b> (0,inf)
	\param[in] density The density. <b>Range:</b> (0,inf)

	\return The mass.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxComputeCylinderDensity(System.Single,System.Single,System.Single)">
	\brief Computes density of a homogeneous cylinder according to cylinder mass.

	\warning #NxCreatePhysicsSDK() must be called before using this function.

	\param[in] radius The radius of the cylinder. <b>Range:</b> (0,inf)
	\param[in] length The length. <b>Range:</b> (0,inf)
	\param[in] mass The mass. <b>Range:</b> (0,inf)

	\return The density.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxComputeCylinderMass(System.Single,System.Single,System.Single)">
	\brief Computes mass of a homogeneous cylinder according to cylinder density.

	\warning #NxCreatePhysicsSDK() must be called before using this function.

	\param[in] radius The radius of the cylinder. <b>Range:</b> (0,inf)
	\param[in] length The length. <b>Range:</b> (0,inf)
	\param[in] density The density. <b>Range:</b> (0,inf)

	\return The mass.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxComputeEllipsoidDensity(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
	\brief Computes density of a homogeneous ellipsoid according to ellipsoid mass.

	\warning #NxCreatePhysicsSDK() must be called before using this function.

	\param[in] extents The extents/radii of the ellipsoid. <b>Range:</b> direction vector
	\param[in] mass The mass of the ellipsoid. <b>Range:</b> (0,inf)

	\return The density of the ellipsoid.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxComputeEllipsoidMass(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
	\brief Computes mass of a homogeneous ellipsoid according to ellipsoid density.

	\warning #NxCreatePhysicsSDK() must be called before using this function.

	\param[in] extents The extents/radii of the ellipsoid. <b>Range:</b> direction vector
	\param[in] density The density of the ellipsoid. <b>Range:</b> (0,inf)

	\return The mass of the ellipsoid.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxComputeBoxDensity(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
	\brief Computes density of a homogeneous box according to box mass.

	\warning #NxCreatePhysicsSDK() must be called before using this function.

	\param[in] extents The extents/radii, that is the full side length along each axis, of the box. <b>Range:</b> direction vector
	\param[in] mass The mass of the box. <b>Range:</b> (0,inf)

	\return  The density of the box.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxComputeBoxMass(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
	\brief Computes mass of a homogeneous box according to box density.

	\warning #NxCreatePhysicsSDK() must be called before using this function.

	\param[in] extents The extents/radii, that is the full side length along each axis, of the box. <b>Range:</b> direction vector
	\param[in] density The density of the box. <b>Range:</b> (0,inf)

	\return The mass of the box.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxComputeSphereDensity(System.Single,System.Single)">
	\brief Computes density of a homogeneous sphere according to sphere mass.

	\warning #NxCreatePhysicsSDK() must be called before using this function.

	\param[in] radius Radius of the sphere. <b>Range:</b> (0,inf)
	\param[in] mass Mass of the sphere. <b>Range:</b> (0,inf)

	\return The density of the sphere.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxComputeSphereMass(System.Single,System.Single)">
\addtogroup physics
  @{

	\brief Computes mass of a homogeneous sphere according to sphere density.

	\warning #NxCreatePhysicsSDK() must be called before using this function.

	\param[in] radius Radius of the sphere. <b>Range:</b> (0,inf)
	\param[in] density Density of the sphere. <b>Range:</b> (0,inf)

	\return The mass of the sphere.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxWheelShape.getUserWheelContactModify">
	\brief Returns the callback function used for wheel contact modification on the WheelShape.

	\return The current wheel contact modification callback. NULL if no contact modification is being used.

	@see NxWheelShapeDesc.wheelContactModify NxUserWheelContactModify

</member>
        <member name="M:NxWheelShape.setUserWheelContactModify(NxUserWheelContactModify*)">
	\brief Sets a callback function for wheel contact modification. NULL deactivates this functionality for the WheelShape.

	\param callback The callback function

	@see NxWheelShapeDesc.wheelContactModify NxUserWheelContactModify

</member>
        <member name="M:NxWheelShape.getContact(NxWheelContactData*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Return contact information for the wheel.

	when getContact() returns nonzero the wheel is in contact with another shape. (if there are several objects, this is the closest one hit by the wheel.)
	returns most recent contact normal and contact force for the wheel.  
	longitudalDirection and lateralDirection are tangential to the returned shape, and form a basis together with the contactNormal.
	otherShapeMaterialIndex is the material of the returned shape at the point of contact.  Because the tire model does not automatically respond to the material
	of objects it is in contact with (because it is an inherently different kind of material simulation) any adaptation of the tire force curves must be done by the
	user in response to the ground material returned here.

	\param[out] dest Description of the contact. (only valid if there is a contact)
	\return Returns the shape the wheel is in contact with. Or NULL if there is no contact.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback for collision)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxWheelContactData NxShape

</member>
        <member name="M:NxWheelShape.getAxleSpeed">
	\brief Current axle rotation speed

	\return The current axle speed.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setAxleSpeed()

</member>
        <member name="M:NxWheelShape.setAxleSpeed(System.Single)">
	\brief Current axle rotation speed  NOTE: NX_WF_AXLE_SPEED_OVERRIDE flag must be raised for this to have effect!

	<b>Sleeping:</b> Does <b>NOT</b> wake any actors associated with the shape.

	\param[in] speed The new axle speed. <b>Range:</b> (-inf,inf)

	NOTE: NX_WF_AXLE_SPEED_OVERRIDE flag must be raised for this to have effect!

	An overridden axle speed of course renders the axle motor and brake torques ineffective.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getAxleSpeed()

</member>
        <member name="M:NxWheelShape.getSteerAngle">
	\brief steering angle, around shape Y axis.

	\return The current steering angle(in radians)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setSteerAngle()

</member>
        <member name="M:NxWheelShape.getBrakeTorque">
	\brief Must be positive.  Very large values should lock wheel but should be stable.

	\return The current brake torque.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setBrakeTorque()

</member>
        <member name="M:NxWheelShape.getMotorTorque">
	\brief Sum engine torque on the wheel axle.  Positive or negative depending on direction.

	\return The current motor torque.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setMotorTorque()

</member>
        <member name="M:NxWheelShape.setSteerAngle(System.Single)">
	\brief steering angle, around shape Y axis.

	<b>Sleeping:</b> Does <b>NOT</b> wake any actors associated with the shape.

	\param[in] angle The new steering angle(in radians). <b>Range:</b> (-PI,PI)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getSteerAngle()

</member>
        <member name="M:NxWheelShape.setBrakeTorque(System.Single)">
	\brief Must be nonnegative.  Very large values should lock wheel but should be stable.

	<b>Sleeping:</b> Does <b>NOT</b> wake any actors associated with the shape.

	\param[in] torque The brake torque to apply. <b>Range:</b> [0,inf)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getBrakeTorque()

</member>
        <member name="M:NxWheelShape.setMotorTorque(System.Single)">
	\brief Sum engine torque on the wheel axle.  Positive or negative depending on direction.

	<b>Sleeping:</b> Does <b>NOT</b> wake any actors associated with the shape.

	\param[in] torque The motor torque to apply. <b>Range:</b> (-inf,inf)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getMotorTorque()

</member>
        <member name="M:NxWheelShape.getWheelFlags">
	\brief flags from NxWheelShapeFlags

	\return The wheel flags.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxWheelShapeFlags setWheelFlags()

</member>
        <member name="M:NxWheelShape.getInverseWheelMass">
	\brief inverse mass of the wheel.  Determines the wheel velocity that wheel torques can achieve.

	\return Inverse wheel mass. 

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setInverseWheelMass()

</member>
        <member name="M:NxWheelShape.getLateralTireForceFunction">
	\brief cubic Hermite spline coefficients describing the lateral tire force curve.

	\return Description of the lateral tire force.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxTireFunctionDesc setLateralTireForceFunction()

</member>
        <member name="M:NxWheelShape.getLongitudalTireForceFunction">
	\brief cubic Hermite spline coefficients describing the longitudinal tire force curve.

	\return Description of the longitudinal tire force.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxTireFunctionDesc setLongitudalTireForceFunction()

</member>
        <member name="M:NxWheelShape.getSuspension">
	\brief data intended for car wheel suspension effects.

	\return Description of the suspension spring.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setSuspension() NxSpringDesc

</member>
        <member name="M:NxWheelShape.setWheelFlags(System.UInt32)">
	\brief flags from NxWheelShapeFlags

	\param[in] flags The new wheel flags.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxWheelShapeFlags getWheelFlags()

</member>
        <member name="M:NxWheelShape.setInverseWheelMass(System.Single)">
	\brief inverse mass of the wheel.  Determines the wheel velocity that wheel torques can achieve.

	<b>Sleeping:</b> Does <b>NOT</b> wake any actors associated with the shape.

	\param[in] invMass The inverse wheel mass. <b>Range:</b> (0,inf)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getInverseWheelMass()

</member>
        <member name="M:NxWheelShape.setLateralTireForceFunction(NxTireFunctionDesc)">
	\brief cubic Hermite spline coefficients describing the lateral tire force curve.

	<b>Sleeping:</b> Does <b>NOT</b> wake any actors associated with the shape.

	\param[in] tireFunc Description of the lateral tire forces. <b>Range:</b> See #NxTireFunctionDesc

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getLateralTireForceFunction() NxTireFunctionDesc

</member>
        <member name="M:NxWheelShape.setLongitudalTireForceFunction(NxTireFunctionDesc)">
	\brief cubic Hermite spline coefficients describing the longitudinal tire force curve.

	<b>Sleeping:</b> Does <b>NOT</b> wake any actors associated with the shape.

	\param[in] tireFunc Description of the longitudinal tire forces. <b>Range:</b> See #NxTireFunctionDesc

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getLongitudalTireForceFunction NxTireFunctionDesc

</member>
        <member name="M:NxWheelShape.getSuspensionTravel">
	\brief maximum extension distance of suspension along shape's -Y axis.  The minimum extension is always 0.  

	\return The suspension travel.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setSuspensionTravel()

</member>
        <member name="M:NxWheelShape.getRadius">
	\brief distance from wheel axle to a point on the contact surface.

	\return The wheel radius.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setRadius()

</member>
        <member name="M:NxWheelShape.setSuspensionTravel(System.Single)">
	\brief maximum extension distance of suspension along shape's -Y axis.  The minimum extension is always 0.  

	<b>Sleeping:</b> Does <b>NOT</b> wake any actors associated with the shape.

	\param[in] travel The suspension travel. <b>Range:</b> [0,inf)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getSuspensionTravel()

</member>
        <member name="M:NxWheelShape.setRadius(System.Single)">
	\brief distance from wheel axle to a point on the contact surface.

	<b>Sleeping:</b> Does <b>NOT</b> wake any actors associated with the shape.

	\param[in] radius The new wheel radius. <b>Range:</b> (0,inf)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getRadius()

</member>
        <member name="M:NxWheelShape.saveToDesc(NxWheelShapeDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Saves the state of the shape object to a descriptor.

	\param[out] desc Descriptor to retrieve shape properties.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxWheelShapeDesc

</member>
        <member name="T:NxWheelShape">
\brief A special shape used for simulating a car wheel.

The -Y axis should be directed toward the ground.  A ray is cast from the shape's origin along the -Y axis.  

When the ray strikes something, and the distance is:

	\li less than wheelRadius from the shape origin: a hard contact is created
	\li between wheelRadius and (suspensionTravel + wheelRadius): a soft suspension contact is created
	\li greater than (suspensionTravel + wheelRadius): no contact is created.

Thus at the point of greatest possible suspension compression the wheel axle will pass through at the shape's origin.
At the point greatest suspension extension the wheel axle will be a distance of suspensionTravel from the shape's origin.

The suspension's targetValue is 0 for real cars, which means that the suspension tries to extend all the way.  Otherwise one can specify values
[0,1] for suspensions which have a spring to pull the wheel up when it is extended too far.  0.5 will then fall halfway along suspensionTravel.

The +Z axis is the 'forward' direction of travel for the wheel.  -Z is backwards.
The wheel rolls forward when rotating around the positive direction around the X axis.

A positive wheel steering angle corresponds to a positive rotation around the shape's Y axis.  (Castor angles are not modeled.)

The coordinate frame of the shape is rigidly fixed on the car.  

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes (Software fallback for collision)
\li PS3  : Yes
\li XB360: Yes

<h3>Visualizations</h3>
\li NX_VISUALIZE_COLLISION_AABBS
\li NX_VISUALIZE_COLLISION_SHAPES
\li NX_VISUALIZE_COLLISION_AXES

@see NxShape NxWheelShapeDesc

</member>
        <member name="F:NxWheelContactData.contactPosition">
\brief The distance on the spring travel distance where the wheel would end up if it was resting on the contact point.

</member>
        <member name="F:NxWheelContactData.otherShapeMaterialIndex">
	\brief The material index of the shape in contact with the wheel.

	@see NxMaterial NxMaterialIndex

</member>
        <member name="F:NxWheelContactData.longitudalImpulse">
\brief the clipped impulses applied at the wheel.

</member>
        <member name="F:NxWheelContactData.longitudalSlip">
\brief What these exactly are depend on NX_WF_INPUT_LAT_SLIPVELOCITY and NX_WF_INPUT_LNG_SLIPVELOCITY flags for the wheel.

</member>
        <member name="F:NxWheelContactData.contactForce">
\brief The magnitude of the force being applied for the contact.

</member>
        <member name="F:NxWheelContactData.lateralDirection">
\brief The sideways direction for the wheel(at right angles to the longitudinal direction).

</member>
        <member name="F:NxWheelContactData.longitudalDirection">
\brief The direction the wheel is pointing in.

</member>
        <member name="F:NxWheelContactData.contactNormal">
	\brief The normal at the point of contact.


</member>
        <member name="F:NxWheelContactData.contactPoint">
	\brief The point of contact between the wheel shape and the ground.


</member>
        <member name="T:NxWheelContactData">
\brief Contact information used by NxWheelShape

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

@see NxWheelShape NxWheelShape.getContact()

</member>
        <member name="M:NxWheelShapeDesc.isValid">
\brief returns true if the current settings are valid

</member>
        <member name="M:NxWheelShapeDesc.setToDefault(System.Boolean)">
\brief (re)sets the structure to the default.
 \param[in] fromCtor Avoid redundant work if called from constructor.

</member>
        <member name="M:NxWheelShapeDesc.#ctor">
constructor sets to default.

</member>
        <member name="F:NxWheelShapeDesc.wheelContactModify">
	\brief callback used for modifying the wheel contact point before the wheel constraints are created.

	<b>Default:</b> NULL

	@see NxUserWheelContactModify

</member>
        <member name="F:NxWheelShapeDesc.wheelFlags">
	\brief flags from NxWheelShapeFlags

	<b>Default:</b> 0

	@see NxWheelShapeFlags NxWheelShape.getWheelFlags() NxWheelShape.setWheelFlags()

</member>
        <member name="T:NxWheelShapeDesc">
 \brief Descriptor for an #NxWheelShape.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes (Software fallback for collision)
\li PS3  : Yes
\li XB360: Yes

 @see NxWheelShape NxActor.createActor()

</member>
        <member name="F:NX_WF_CLAMPED_FRICTION">
\brief If set, the NxWheelShape will clamp the force in the friction constraints.
See #NxTireFunctionDesc

</member>
        <member name="F:NX_WF_EMULATE_LEGACY_WHEEL">
\brief If set, the NxWheelShape will emulate the legacy raycast capsule based wheel.
See #NxTireFunctionDesc

</member>
        <member name="F:NX_WF_AXLE_SPEED_OVERRIDE">
\brief If set, the axle speed is not computed by the simulation but is rather expected to be provided by the user every simulation step via NxWheelShape::setAxleSpeed().

</member>
        <member name="F:NX_WF_UNSCALED_SPRING_BEHAVIOR">
\brief If set, does not factor out the suspension travel and wheel radius from the spring force computation.  This is the legacy behavior from the raycast capsule approach.

</member>
        <member name="F:NX_WF_INPUT_LNG_SLIPVELOCITY">
\brief If set, the longutudal slip velocity is used as the input to the tire function, rather than the slip ratio.  

</member>
        <member name="F:NX_WF_INPUT_LAT_SLIPVELOCITY">
	\brief If set, the laterial slip velocity is used as the input to the tire function, rather than the slip angle.


</member>
        <member name="F:NX_WF_WHEEL_AXIS_CONTACT_NORMAL">
	\brief Determines whether the suspension axis or the ground contact normal is used for the suspension constraint.


</member>
        <member name="M:NxTireFunctionDesc.hermiteEval(System.Single)">
evaluates the Force(Slip) function

</member>
        <member name="M:NxTireFunctionDesc.isValid">
returns true if the current settings are valid

</member>
        <member name="M:NxTireFunctionDesc.setToDefault">
(re)sets the structure to the default.	

</member>
        <member name="F:NxHeightFieldSample.unused">
\brief Reserved for future use. Should be set to zero.

</member>
        <member name="F:NxHeightFieldSample.materialIndex1">
	\brief The low 7 bits of a triangle material index.

	These low bits are concatenated with the high bits from NxHeightFieldShapeDesc::materialIndexHighBits,
	to produce an index into the scene's material array. This index determines the material of the upper
	of the quad's two triangles (i.e. the quad whose upper-left corner is this sample, see the Guide for illustrations).

	@see NxHeightFieldShapeDesc materialIndex0

</member>
        <member name="F:NxHeightFieldSample.tessFlag">
	\brief Tessellation flag.

	This flag specifies which way the quad is split whose upper left corner is this sample.
	If the flag is set, the diagonal of the quad will run from this sample to the opposite vertex; if not,
	it will run between the other two vertices (see the Guide for illustrations).

</member>
        <member name="F:NxHeightFieldSample.materialIndex0">
	\brief The low 7 bits of a triangle material index.

	These low bits are concatenated with the high bits from NxHeightFieldShapeDesc::materialIndexHighBits,
	to produce an index into the scene's material array. This index determines the material of the lower
	of the quad's two triangles (i.e. the quad whose upper-left corner is this sample, see the Guide for illustrations).

	@see NxHeightFieldShapeDesc materialIndex1

</member>
        <member name="F:NxHeightFieldSample.height">
	\brief The height of the heightfield sample

	This value is scaled by NxHeightFieldShapeDesc::heightScale.

	@see NxHeightFieldShapeDesc

</member>
        <member name="T:NxHeightFieldSample">
@} 
\addtogroup physics
  @{

\brief Heightfield sample format.

This format corresponds to the #NxHeightFieldFormat member NX_HF_S16_TM.

An array of heightfield samples are used when creating a NxHeightField to specify
the elevation of the heightfield points. In addition the material and tessellation of the adjacent 
triangles are specified.

@see NxHeightField NxHeightFieldDesc NxHeightFieldDesc.samples

</member>
        <member name="M:NxHeightFieldShapeDesc.isValid">
\brief Returns true if the descriptor is valid.
\return true if the current settings are valid

</member>
        <member name="M:NxHeightFieldShapeDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxHeightFieldShapeDesc.#ctor">
\brief Constructor sets to default.

</member>
        <member name="F:NxHeightFieldShapeDesc.meshFlags">
	\brief Combination of ::NxMeshShapeFlag.
	So far the only value permitted here is 0 or NX_MESH_SMOOTH_SPHERE_COLLISIONS.

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxMeshShapeFlag

</member>
        <member name="F:NxHeightFieldShapeDesc.holeMaterial">
	\brief The the material index that designates holes in the height field.

	This number is compared directly to sample materials.
	Consequently the high 9 bits must be zero.

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxHeightField NxHeightFieldDesc

</member>
        <member name="F:NxHeightFieldShapeDesc.materialIndexHighBits">
	\brief The high 9 bits of this number are used to complete the material indices in the samples. 

	The remaining low 7 bits must be zero.

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxHeightField NxHeightFieldDesc

</member>
        <member name="F:NxHeightFieldShapeDesc.heightField">
	\brief References the height field that we want to instance.

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxHeightField

</member>
        <member name="T:NxHeightFieldShapeDesc">
@} 
\addtogroup physics
  @{

\brief Descriptor class for #NxHeightFieldShape.

@see NxHeightFieldShape

</member>
        <member name="M:NxHeightFieldShape.getMaterialAtShapePoint(System.Single,System.Single)">
	\brief Returns the material index at the given point in shape space.
	The return value is the 7 low order bits as set in the samples array.
	The value may be compared directly with the hole material to determine
	if the heightfield has a hole at the given point.

	\return The low bits material index, or 0xFFFF if the point is out of range. 

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxHeightFieldShapeDesc.holeMaterial

</member>
        <member name="M:NxHeightFieldShape.getHeightAtShapePoint(System.Single,System.Single)">
	\brief Returns the interpolated height at the given point in shape space.
	\return The interpolated height at the given point, or 0 if the point is out of range. 

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxHeightFieldShape.isShapePointOnHeightField(System.Single,System.Single)">
	\brief Checks if the point in shape space projects onto the height field surface.
	\return True if the point projects onto the height field surface, false otherwise.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxHeightFieldShape.overlapAABBTriangles(NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,NxUserEntityReport&lt;System.UInt32&gt;*)">
	\brief Finds triangles touching the input bounds.

	The triangle indices returned by overlapAABBTriangles() can be used with #getTriangle() to retrieve the triangle properties.

	\param[in] bounds Bounds to test against. In object or world space depending on #NxQueryFlags. <b>Range:</b> See #NxBounds3
	\param[in] flags Controls if the bounds are in object or world space and if we return first contact only. See #NxQueryFlags.
	\param[in] callback Used to return triangles which intersect the AABB
	\return True if there is an overlap.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBounds3 NxQueryFlags NxScene.overlapAABBShapes() getTriangle() NxUserEntityReport

</member>
        <member name="M:NxHeightFieldShape.getTriangle(NxTriangle*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxTriangle*,System.UInt32*,System.UInt32,System.Boolean,System.Boolean)">
	\brief Retrieves triangle data from a triangle ID.

	\param[out] worldTri World space triangle points.
	\param[out] edgeTri World space edge normals for triangle (NULL to not compute).
	\param[out] flags Flags which show if an edge is convex. See #NxTriangleFlags
	\param[in] triangleIndex The index of the triangle to retrieve.
	\param[in] worldSpaceTranslation True if the triangle should be translated to world space.
	\param[in] worldSpaceRotation True if the triangle should be rotated to world space.

	\return Zero if the triangle does not exist or has the hole material. Nonzero otherwise.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxTriangle NxTriangleFlags NxTriangleID

</member>
        <member name="M:NxHeightFieldShape.setColumnScale(System.Single)">
	\brief Sets the multiplier to transform height field columns to shape space z coordinates.
	
	\param scale The multiplier to transform height field columns to shape space z coordinates. <b>Range:</b> (-inf,0), (0,inf)
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxHeightFieldShapeDesc.columnScale

</member>
        <member name="M:NxHeightFieldShape.setRowScale(System.Single)">
	\brief Sets the multiplier to transform height field rows to shape space x coordinates.
	
	\param scale The multiplier to transform height field rows to shape space x coordinates. <b>Range:</b> (-inf,0), (0,inf)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxHeightFieldShapeDesc.rowScale

</member>
        <member name="M:NxHeightFieldShape.setHeightScale(System.Single)">
	\brief Sets the multiplier to transform sample height values to shape space y coordinates.
	
	\param scale The multiplier to transform sample height values to shape space y coordinates. <b>Range:</b> (0,inf)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxHeightFieldShapeDesc.heightScale

</member>
        <member name="M:NxHeightFieldShape.getColumnScale">
	\brief Retrieves the multiplier to transform height field columns to shape space z coordinates.
	
	\return The multiplier to transform height field columns to shape space z coordinates.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes
	
	@see NxHeightFieldShapeDesc.columnScale

</member>
        <member name="M:NxHeightFieldShape.getRowScale">
	\brief Retrieves the multiplier to transform height field rows to shape space x coordinates.
	
	\return The multiplier to transform height field rows to shape space x coordinates.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxHeightFieldShapeDesc.rowScale

</member>
        <member name="M:NxHeightFieldShape.getHeightScale">
	\brief Retrieves the multiplier to transform sample height values to shape space y coordinates.
	
	\return The multiplier to transform sample height values to shape space y coordinates.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxHeightFieldShapeDesc.heightScale

</member>
        <member name="M:NxHeightFieldShape.getHeightField">
	\brief Retrieves the height field data associated with this instance.

	\return The height field associated with this shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxHeightField

</member>
        <member name="M:NxHeightFieldShape.saveToDesc(NxHeightFieldShapeDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Saves the state of the shape object to a descriptor.

	\param[out]  desc The descriptor used to retrieve the state of the object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxHeightFieldShapeDesc

</member>
        <member name="T:NxHeightFieldShape">
\brief This class is a shape instance of a height field object of type NxHeightField.

Each shape is owned by an actor that it is attached to.

<h3>Creation</h3>

An instance can be created by calling the createShape() method of the NxActor object
that should own it, with a NxHeightFieldShapeDesc object as the parameter, or by adding the 
shape descriptor into the NxActorDesc class before creating the actor.

The shape is deleted by calling NxActor::releaseShape() on the owning actor.

Example:

\include NxHeightFieldShape_Create.cpp

<h3>Visualizations:</h3>
\li #NX_VISUALIZE_COLLISION_AABBS
\li #NX_VISUALIZE_COLLISION_SHAPES
\li #NX_VISUALIZE_COLLISION_AXES
\li #NX_VISUALIZE_COLLISION_VNORMALS
\li #NX_VISUALIZE_COLLISION_FNORMALS
\li #NX_VISUALIZE_COLLISION_EDGES
\li #NX_VISUALIZE_COLLISION_SPHERES

@see NxHeightFieldShapeDesc NxHeightField

</member>
        <member name="M:NxHeightFieldDesc.isValid">
\brief Returns true if the descriptor is valid.
\return true if the current settings are valid

</member>
        <member name="M:NxHeightFieldDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxHeightFieldDesc.#ctor">
\brief Constructor sets to default.

</member>
        <member name="F:NxHeightFieldDesc.flags">
	\brief Flags bits, combined from values of the enum ::NxHeightFieldFlags
	
	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxHeightFieldFlags

</member>
        <member name="F:NxHeightFieldDesc.samples">
	\brief The samples array.
	
	It is copied to the SDK's storage at creation time.
	
	There are nbRows * nbColumn samples in the array,
	which define nbRows * nbColumn vertices and cells,
	of which (nbRows - 1) * (nbColumns - 1) cells are actually used.

	The array index of sample(row, column) = row * nbColumns + column.
	The byte offset of sample(row, column) = sampleStride * (row * nbColumns + column).
	The sample data follows at the offset and spans the number of bytes defined by the format.
	Then there are zero or more unused bytes depending on sampleStride before the next sample.
	
	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxHeightFormat

</member>
        <member name="F:NxHeightFieldDesc.sampleStride">
	\brief The offset in bytes between consecutive samples in the samples array.
	
	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxHeightFieldDesc.format">
	\brief Format of the sample data.
	
	Currently the only supported format is NX_HF_S16_TM:

	<b>Default:</b> NX_HF_S16_TM

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes
	
	@see NxHeightFormat NxHeightFieldDesc.samples

</member>
        <member name="M:NxHeightField.getReferenceCount">
	\brief Returns the reference count for shared meshes.

	\return the current reference count, not used in any shapes if the count is 0.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxHeightField.getCells">
	\brief Returns a read only pointer directly to the samples array.
	The data format is identical to that in NxHeightFieldDesc.samples.

	\return A const void pointer to the samples array.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxHeightFieldDesc.samples

</member>
        <member name="M:NxHeightField.getHeight(System.Single,System.Single)">
	\brief Retrieves the height at the given coordinates in grid space.
	\return The height at the given coordinates or 0 if the coordinates are out of range.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxHeightField.getFlags">
	\brief Retrieves the flags bits, combined from values of the enum ::NxHeightFieldFlags.

	\return The flags bits, combined from values of the enum ::NxHeightFieldFlags.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxHeightFieldDesc.flags NxHeightFieldFlags

</member>
        <member name="M:NxHeightField.getConvexEdgeThreshold">
	\brief Retrieves the convex edge threshold.

	\return The convex edge threshold.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxHeightFieldDesc.convexEdgeThreshold

</member>
        <member name="M:NxHeightField.getThickness">
	\brief Retrieves the thickness of the height volume in the vertical direction.

	\return The thickness of the height volume in the vertical direction.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxHeightFieldDesc.thickness

</member>
        <member name="M:NxHeightField.getVerticalExtent">
	\brief Deprecated: Retrieves the extent of the height volume in the vertical direction.

	\return The extent of the height volume in the vertical direction.

	<b>Platform:</b>
	\li PC SW: Deprecated
	\li PPU  : Deprecated
	\li PS3  : Deprecated
	\li XB360: Deprecated

	@see NxHeightFieldDesc.verticalExtent

</member>
        <member name="M:NxHeightField.getSampleStride">
	\brief Retrieves the offset in bytes between consecutive samples in the array.

	\return The offset in bytes between consecutive samples in the array.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxHeightFieldDesc.sampleStride

</member>
        <member name="M:NxHeightField.getFormat">
	\brief Retrieves the format of the sample data.
	
	\return The format of the sample data.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxHeightFieldDesc.format NxHeightFieldFormat

</member>
        <member name="M:NxHeightField.getNbColumns">
	\brief Retrieves the number of sample columns in the samples array.

	\return The number of sample columns in the samples array.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxHeightFieldDesc.nbColumns

</member>
        <member name="M:NxHeightField.getNbRows">
	\brief Retrieves the number of sample rows in the samples array.

	\return The number of sample rows in the samples array.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxHeightFieldDesc.nbRows

</member>
        <member name="M:NxHeightField.saveCells(System.Void*,System.UInt32)">
    \brief Writes out the sample data array.
	
	The user provides destBufferSize bytes storage at destBuffer.
	The data is formatted and arranged as NxHeightFieldDesc.samples.

	\param[out] destBuffer The destination buffer for the sample data.
	\param[in] destBufferSize The size of the destination buffer.
	\return The number of bytes written.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxHeightFieldDesc.samples

</member>
        <member name="M:NxHeightField.loadFromDesc(NxHeightFieldDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Load the height field from a description.

    \param[in] desc The descriptor to load the object from.

	\return True if the height field was successfully loaded.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxHeightFieldDesc

</member>
        <member name="M:NxHeightField.saveToDesc(NxHeightFieldDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Saves the HeightField descriptor.
	
	This does not save out the cells member of the desc because the user must provide destination memory for that.
	Instead, use the saveCells method obtain the sample data.

	\param[out] desc The descriptor used to retrieve the state of the object.

	\return True on success.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="T:NxHeightField">
\brief A height field object.  

Height fields work in a similar way as triangle meshes specified to act as height fields, with some important differences:

Triangle meshes can be made of nonuniform geometry, while height fields are regular, rectangular grids.
This means that with NxHeightField, you sacrifice flexibility in return for improved performance and decreased memory consumption.

Like Convexes and TriangleMeshes, HeightFields are referenced by shape instances of type NxHeightFieldShape.

To avoid duplicating data when you have several instances of a particular 
height field differently, you do not use this class to represent a 
height field object directly. Instead, you create an instance of this height field 
via the NxHeightFieldShape class.

<h3>Creation</h3>

To create an instance of this class call NxPhysicsSDK::createHeightField(),
and NxPhysicsSDK::releaseHeightField() to delete it. This is only possible
once you have released all of its NxHeightFiedShape instances.

Example:

\include NxHeightField_Create.cpp

<h3>Visualizations:</h3>
\li #NX_VISUALIZE_COLLISION_AABBS
\li #NX_VISUALIZE_COLLISION_SHAPES
\li #NX_VISUALIZE_COLLISION_AXES
\li #NX_VISUALIZE_COLLISION_VNORMALS
\li #NX_VISUALIZE_COLLISION_FNORMALS
\li #NX_VISUALIZE_COLLISION_EDGES
\li #NX_VISUALIZE_COLLISION_SPHERES

@see NxHeightFieldDesc NxHeightFieldShape NxPhysicsSDK.createHeightField()

</member>
        <member name="T:NxHeightFieldDesc">
@} 
\addtogroup physics
  @{


@} 
\addtogroup physics
  @{

\brief Descriptor class for #NxHeightField.

The heightfield data is *copied* when a NxHeightField object is created from this descriptor. After the call the
user may discard the height data.

@see NxHeightField NxHeightFieldShape NxPhysicsSDK.createHeightField()

</member>
        <member name="M:NxConvexShapeDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return returns true if the current settings are valid

</member>
        <member name="M:NxConvexShapeDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxConvexShapeDesc.#ctor">
\brief Constructor sets to default.

</member>
        <member name="F:NxConvexShapeDesc.meshFlags">
	\brief Combination of ::NxMeshShapeFlag

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxMeshShapeFlag

</member>
        <member name="F:NxConvexShapeDesc.meshData">
	\brief References the triangle mesh that we want to instance.

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxConvexMesh NxConvexMeshDesc NxPhysicsSDK.createConvexMesh()

</member>
        <member name="M:NxConvexShape.getConvexMesh">
	\brief Retrieves the convex mesh data associated with this instance.

	\return The convex mesh associated with this shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxConvexMesh


	\brief Retrieves the convex mesh data associated with this instance.

	Const version.

	\return The convex mesh associated with this shape.

	@see NxConvexMesh

</member>
        <member name="M:NxConvexShape.saveToDesc(NxConvexShapeDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">

	\brief Save shape to desc.

	\param[out] desc The descriptor used to retrieve the state of the object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxConvexShapeDesc

</member>
        <member name="T:NxConvexShape">
\brief Used to represent an instance of an #NxConvexMesh.

<h3>Creation</h3>

Example:

\include NxConvexMesh_Create.cpp

<h3>Visualizations:</h3>
\li #NX_VISUALIZE_COLLISION_AABBS
\li #NX_VISUALIZE_COLLISION_SHAPES
\li #NX_VISUALIZE_COLLISION_AXES
\li #NX_VISUALIZE_COLLISION_VNORMALS
\li #NX_VISUALIZE_COLLISION_FNORMALS
\li #NX_VISUALIZE_COLLISION_EDGES
\li #NX_VISUALIZE_COLLISION_SPHERES

@see NxConvexShapeDesc NxConvexMesh NxShape NxPhysicsSDK.createConvexMesh() NxActor.createShape()

</member>
        <member name="T:NxConvexShapeDesc">
@} 
\addtogroup physics
  @{


\brief Descriptor class for #NxConvexShape.

@see NxConvexShape NxShapeDesc NxActor.createShape() NxConvexMesh NxPhysicsSDK.createConvexMesh()

</member>
        <member name="M:NxConvexMeshDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return True if the current settings are valid

</member>
        <member name="M:NxConvexMeshDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxConvexMeshDesc.#ctor">
\brief constructor sets to default.

</member>
        <member name="F:NxConvexMeshDesc.flags">
	\brief Flags bits, combined from values of the enum ::NxConvexFlags

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxConvexMeshDesc.triangles">
	\brief Pointer to array of triangle indices.
	<p>Pointer to first triangle. Caller may add triangleStrideBytes bytes to the pointer to access the next triangle.</p><p><pre>These are triplets of 0 based indices:
	vert0 vert1 vert2
	vert0 vert1 vert2
	vert0 vert1 vert2
	...</pre></p><p>Where vertex is either a 32 or 16 bit unsigned integer. There are numTriangles*3 indices.</p><p>This is declared as a void pointer because it is actually either an NxU16 or a NxU32 pointer.</p><b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxConvexFlags.NX_CF_16_BIT_INDICES

</member>
        <member name="F:NxConvexMeshDesc.points">
	\brief Pointer to array of vertex positions.
	Pointer to first vertex point. Caller may add pointStrideBytes bytes to the pointer to access the next point.

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxConvexMeshDesc.triangleStrideBytes">
	\brief Offset between triangles in bytes.

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxConvexMeshDesc.pointStrideBytes">
	\brief Offset between vertex points in bytes.

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxConvexMeshDesc.numTriangles">
	\brief Number of triangles.

	Hardware rigid body scenes have a limit of 32 faces per convex.
	Fluid scenes have a limit of 64 faces per cooked convex for dynamic actors.

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Max 32 faces)
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxConvexMeshDesc.numVertices">
	\brief Number of vertices.

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Max limit of 32 vertices for hardware rigid bodies)
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="T:NxConvexMeshDesc">
\brief Descriptor class for #NxConvexMesh.

@see NxConvexMesh NxConvexShape NxPhysicsSDK.createConvexMesh()


</member>
        <member name="T:NxConvexFlags">
@} 
\addtogroup physics
  @{

\brief Flags which describe the format and behavior of a convex mesh.

</member>
        <member name="F:NX_CF_USE_UNCOMPRESSED_NORMALS">
	\brief Instructs cooking to save normals uncompressed.  The cooked hull data will be larger, but will load faster.

	@see NxCookingParams

</member>
        <member name="F:NX_CF_INFLATE_CONVEX">
	\brief Inflates the convex object according to skin width

	\note This flag is only used in combination with NX_CF_COMPUTE_CONVEX.

	@see NxCookingParams

</member>
        <member name="F:NX_CF_COMPUTE_CONVEX">
Automatically recomputes the hull from the vertices. If this flag is not set, you must provide the entire geometry manually.

</member>
        <member name="F:NX_CF_16_BIT_INDICES">
Denotes the use of 16-bit vertex indices in NxConvexMeshDesc::triangles.
(otherwise, 32-bit indices are assumed)
@see #NxConvexMeshDesc.triangles

</member>
        <member name="F:NX_CF_FLIPNORMALS">
	\brief Used to flip the normals if the winding order is reversed.

	The Nx libraries assume that the face normal of a triangle with vertices [a,b,c] can be computed as:
	edge1 = b-a
	edge2 = c-a
	face_normal = edge1 x edge2.

	Note: this is the same as counterclockwise winding in a right handed graphics coordinate system.

	If this does not match the winding order for your triangles, raise the below flag.

</member>
        <member name="M:NxConvexMesh.getMassInformation(System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat33*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Returns the mass properties of the mesh.

	\param[out] mass The mass of the mesh.
	\param[out] localInertia The inertia tensor in mesh local space.
	\param[out] localCenterOfMass Position of center of mass in mesh local space.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxConvexMesh.getReferenceCount">
	\brief Returns the reference count for shared meshes.

	\return the current reference count, not used in any shapes if the count is 0.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxConvexMesh.load(NxStream!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Load the contents of this mesh from the provided stream.

	A stream of an appropriate format can be creating with the cooking library.

	\param[in] stream Stream to load this mesh from. See #NxStream.
	\return True if successfully loaded. Otherwise False.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback for &gt; 32 faces or vertices)
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxConvexMesh.getStride(System.UInt32,NxInternalArray)">
	\brief Retrieves the stride value of a given internal array.

	The stride value is always a number of bytes. You have to skip this number of bytes
	to go from one element to the other in an array, starting from the base.

	\param[in] submeshIndex Reserved for future use, must be 0.
	\param[in] intArray The internal array stride to retrieve (e.g. triangles, vertices etc). See #NxInternalArray.
	
	\return The stride(number of bytes from one element to the next) for the internal array.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes
	
	@see getCount() getFormat() getBase()

</member>
        <member name="M:NxConvexMesh.getBase(System.UInt32,NxInternalArray)">
	\brief Retrieves the base pointer of a given internal array.

	Make sure you take into account the given format and stride.

	@see getStride
	@see getFormat

	\param[in] submeshIndex Reserved for future use, must be 0.
	\param[in] intArray The internal array pointer to retrieve (e.g. triangles, vertices etc). See #NxInternalArray.
	
	\return A pointer to the first element of the internal array.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getCount() getFormat() getStride()

</member>
        <member name="M:NxConvexMesh.getFormat(System.UInt32,NxInternalArray)">
	\brief Retrieves the format of a given internal array.

	\param[in] submeshIndex Reserved for future use, must be 0.
	\param[in] intArray The internal array format to retrieve (e.g. triangles, vertices etc). See #NxInternalArray.
	
	\return The format of the internal array. See #NxInternalFormat.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getCount() getBase() getStride()

</member>
        <member name="M:NxConvexMesh.getCount(System.UInt32,NxInternalArray)">
	\brief Retrieves the number of elements of a given internal array.

	\param[in] submeshIndex Reserved for future use, must be 0.
	\param[in] intArray The internal array size to retrieve (e.g. triangles, vertices etc). See #NxInternalArray.
	
	\return The number of elements in the internal array.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes
	
	@see getFormat() getBase() getStride()

</member>
        <member name="M:NxConvexMesh.getSubmeshCount">
	\brief Not used.


</member>
        <member name="M:NxConvexMesh.saveToDesc(NxConvexMeshDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Saves the mesh to a descriptor.

	\param[out] desc Descriptor to store the state of the convex mesh into.
	
	\return true on success.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxConvexMeshDesc 

</member>
        <member name="T:NxConvexMesh">
\brief A Convex Mesh.

Internally represented as a list of convex polygons. The number
of polygons is limited to 256.

To avoid duplicating data when you have several instances of a particular 
mesh positioned differently, you do not use this class to represent a 
convex object directly. Instead, you create an instance of this mesh via
the NxConvexShape class.

<h3>Creation</h3><h3>Creation</h3>

To create an instance of this class call NxPhysicsSDK::createConvexMesh(),
and NxPhysicsSDK::releaseConvexMesh() to delete it. This is only possible
once you have released all of its #NxConvexShape instances.

Example:

\include NxConvexMesh_Create.cpp

<h3>Visualizations:</h3>
\li #NX_VISUALIZE_COLLISION_AABBS
\li #NX_VISUALIZE_COLLISION_SHAPES
\li #NX_VISUALIZE_COLLISION_AXES
\li #NX_VISUALIZE_COLLISION_VNORMALS
\li #NX_VISUALIZE_COLLISION_FNORMALS
\li #NX_VISUALIZE_COLLISION_EDGES
\li #NX_VISUALIZE_COLLISION_SPHERES

@see NxConvexMeshDesc NxPhysics.createConvexMesh()


@} 
\addtogroup physics
  @{

</member>
        <member name="M:NxTriangleMeshShapeDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return true if the current settings are valid

</member>
        <member name="M:NxTriangleMeshShapeDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxTriangleMeshShapeDesc.#ctor">
\brief Constructor sets to default.

</member>
        <member name="F:NxTriangleMeshShapeDesc.meshPagingMode">
	\brief Mesh paging scheme.

	<b>Default:</b> NX_MESH_PAGING_MANUAL

	<b>Platform:</b>
	\li PC SW: No
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: No

	@see NxMeshPagingMode

</member>
        <member name="F:NxTriangleMeshShapeDesc.meshFlags">
	\brief Combination of ::NxMeshShapeFlag.

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxMeshShapeFlag

</member>
        <member name="F:NxTriangleMeshShapeDesc.meshData">
	\brief References the triangle mesh that we want to instance.

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxTriangleMesh

</member>
        <member name="T:NxTriangleMeshShapeDesc">
@} 
\addtogroup physics
  @{

\brief Descriptor class for #NxTriangleMeshShape.

@see NxTriangleMeshShape

</member>
        <member name="M:NxTriangleMeshShape.isPageInstanceMapped(System.UInt32)">
	\brief Determine whether a page instance is present from the PhysX processor.

	\param[in] pageIndex the index of the page being queried. Pages are indexed sequentially starting from zero.
	\return False if the page is not mapped or if the PhysX processor is not present. False is also returned 
	when the mesh is being emulated in software.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see mapPageInstance() unmapPageInstance()

</member>
        <member name="M:NxTriangleMeshShape.unmapPageInstance(System.UInt32)">
	\brief Release a page instance from the PhysX processor.

	Release a page instance corresponding to a mesh page from the PhysX processor. no other page instances
	reference the mesh page, the page is also released. If the PhysX card is not present, this call has no effect.

	\param[in] pageIndex the index of the page to unmap. Pages are indexed sequentially starting from zero.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see isPageInstanceMapped() mapPageInstance()

</member>
        <member name="M:NxTriangleMeshShape.mapPageInstance(System.UInt32)">
	\brief Send a page to the PhysX processor.

	Ensure that a mesh instance corresponding to a mesh page is present on the PhysX processor. If the 
	page is not present on the processor, it is also sent. If the PhysX processor is not present, this call has
	no effect and returns false. If the page instance is already on the processor, this call has no effect and
	returns true.

	If the mesh is emulated in software then collision detection will still be performed, even if the pages
	of the mesh are not mapped. Since the software versions of the collision detection routines do not require
	the mesh to be mapped into hardware memory. 
	
	Cases where a mesh will be emulated in software(for 2.5):

	\li Dynamic(movable) triangle meshes.
	\li Triangle meshes with per triangle materials.
	\li mesh-mesh collision (pmaps).
	\li Heightfield triangle meshes.
	
	\param[in] pageIndex the index of the page to map. Pages are indexed sequentially starting from zero.
	\return False if there are insufficient resources available on the processor to accommodate the page or page
	instance. False is also returned when the mesh is being run in software.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see unmapPageInstance() isPageInstanceMapped()

</member>
        <member name="M:NxTriangleMeshShape.overlapAABBTriangles(NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,NxUserEntityReport&lt;System.UInt32&gt;*)">
	\brief Finds triangles touching the input bounds.

	The triangle indices returned by overlapAABBTriangles() can be used with #getTriangle() to retrieve the triangle properties.

	\param[in] bounds Bounds to test against. In object or world space depending on #NxQueryFlags. <b>Range:</b> See #NxBounds3
	\param[in] flags Controls if the bounds are in object or world space and if we return first contact only. See #NxQueryFlags.
	\param[in] callback Used to return triangles which intersect the AABB
	\return True if there is an overlap.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBounds3 NxQueryFlags NxScene.overlapAABBShapes() getTriangle() NxUserEntityReport

</member>
        <member name="M:NxTriangleMeshShape.getTriangle(NxTriangle*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxTriangle*,System.UInt32*,System.UInt32,System.Boolean,System.Boolean)">
	\brief Retrieves triangle data from a triangle ID.

	This function can be used together with #overlapAABBTriangles() to retrieve triangle properties.

	\param[out] triangle triangle points in local or world space.
	\param[out] edgeTri World space edge normals for triangle (NULL to not compute).
	\param[out] flags Flags which show if an edge is convex. See #NxTriangleFlags
	\param[in] triangleIndex The index of the triangle to retrieve.
	\param[in] worldSpaceTranslation true to return triangle's position in world space, else false for local space
	\param[in] worldSpaceRotation true to return triangle's orientation in world space, else false for local space
	\return Unused.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxTriangle NxTriangleFlags NxTriangleID overlapAABBTriangles()

</member>
        <member name="M:NxTriangleMeshShape.getTriangleMesh">
	\brief Retrieves the triangle mesh data associated with this instance.

	\return The triangle mesh associated with this shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxTriangleMesh

</member>
        <member name="M:NxTriangleMeshDesc.isValid">
\brief Returns true if the descriptor is valid.
\return true if the current settings are valid

</member>
        <member name="M:NxTriangleMeshDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxTriangleMeshDesc.#ctor">
\brief Constructor sets to default.

</member>
        <member name="F:NxTriangleMeshDesc.pmap">
	The pmap is an optional data structure which makes mesh-mesh collision detection more robust at the cost of higher
	memory consumption. A pmap can be created with ::NxCreatePMap and released with ::NxReleasePMap.
	You may also save the output of ::NxCreatePMap do disc to avoid this preprocessing step.

	\warning Legacy member

	The pmap data will not be copied. For this reason the caller does not need to keep it around for the lifetime of 
	the NxTriangleMesh object.

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxTriangleMesh.loadPMap

</member>
        <member name="F:NxTriangleMeshDesc.heightFieldVerticalAxis">
	\brief Deprecated

	\warning This member is deprecated and will no longer be supported. Use the specialized	#NxHeightField
	class instead.

	The mesh may represent either an arbitrary mesh or a height field. The advantage of a height field
	is that it is assumed to be semi-infinite along one axis, and therefore it doesn't have the problem
	of fast moving objects 'popping' through it due to temporal under sampling.

	However, height fields must be 'flat' in the sense that the projections of all triangles onto the
	height field plane must be disjoint. (If the height field vertical axis is Y, the height field plane is spanned by X and Z.)

	To create a height field, set heightFieldVerticalAxis to NX_X, NX_Y or NX_Z, 
	or leave it set to NX_NOT_HEIGHTFIELD for an arbitrary mesh.

	<b>Default:</b> NX_NOT_HEIGHTFIELD

	<b>Platform:</b>
	\li PC SW: Deprecated
	\li PPU  : Deprecated
	\li PS3  : Deprecated
	\li XB360: Deprecated

	@see NxHeightFieldAxis heightFieldVerticalExtent

</member>
        <member name="F:NxTriangleMeshDesc.materialIndices">
	Optional pointer to first material index, or NULL. There are NxSimpleTriangleMesh::numTriangles indices in total.
	Caller may add materialIndexStride bytes to the pointer to access the next triangle.

	When a triangle mesh collides with another object, a material is required at the collision point.
	If materialIndices is NULL, then the material of the NxTriangleMeshShape instance (specified via NxShapeDesc::materialIndex) is used.
	Otherwise, if the point of contact is on a triangle with index i, then the material index is determined as: 
	NxMaterialIndex	index = *(NxMaterialIndex *)(((NxU8*)materialIndices) + materialIndexStride * i);

	If the contact point falls on a vertex or an edge, a triangle adjacent to the vertex or edge is selected, and its index
	used to look up a material. The selection is arbitrary but consistent over time. 

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fall-back)
	\li PS3  : Yes
	\li XB360: Yes

	@see materialIndexStride

</member>
        <member name="F:NxTriangleMeshDesc.materialIndexStride">
	If materialIndices is NULL (not used) then this should be zero. Otherwise this is the
	offset between material indices in bytes. This is at least sizeof(NxMaterialIndex).

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fall-back)
	\li PS3  : Yes
	\li XB360: Yes

	@see materialIndices

</member>
        <member name="T:NxTriangleMeshDesc">
@} 
\addtogroup physics
  @{

\brief Descriptor class for #NxTriangleMesh.

Note that this class is derived from NxSimpleTriangleMesh which contains the members that describe the basic mesh.
The mesh data is *copied* when an NxTriangleMesh object is created from this descriptor. After the call the
user may discard the triangle data.

@see NxTriangleMesh NxTriangleMeshShape

</member>
        <member name="M:NxTriangleMesh.getMassInformation(System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat33*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Returns the mass properties of the mesh.

	\param[out] mass The mass of the mesh.
	\param[out] localInertia The inertia tensor in mesh local space.
	\param[out] localCenterOfMass Position of center of mass in mesh local space.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxTriangleMesh.getReferenceCount">
	\brief Returns the reference count for shared meshes.

	\return the current reference count, not used in any shapes if the count is 0.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxTriangleMesh.getTriangleMaterial(System.UInt32)">
	\brief Returns material index of given triangle

	This function takes a post cooking triangle index.

	\param[in] triangleIndex (internal) index of desired triangle
	\return Material index, or 0xffff if no per-triangle materials are used

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxTriangleMesh.load(NxStream!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Load the triangle mesh from a stream.

	You can create an appropriate stream using the cooking library.

	\param[in] stream Stream to load triangle mesh from.
	\return True if the triangle mesh was successfully loaded.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxStream

</member>
        <member name="M:NxTriangleMesh.getPMapDensity">
	\brief Gets the density of the pmap.

	\warning Legacy function

	\return The density(resolution) of the PMap, on all axis.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxTriangleMeshDesc.pmap NxPMap loadPMap() hasPMap() getPMapSize() hasPMap()

</member>
        <member name="M:NxTriangleMesh.getPMapData(NxPMap*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Gets pmap data.
	
	\warning Legacy function

	You must first query expected size with getPmapSize(), then allocate a buffer large
	enough to contain that amount of bytes, then call this function to dump data in preallocated buffer.
	The system checks that pmap.dataSize is equal to expected data size, so you must initialize that
	member as well before the query.

	\param[out] pmap Descriptor for PMap to retrieve.
	\return True if the PMap is successfully extracted.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes
	
	@see NxTriangleMeshDesc.pmap NxPMap loadPMap() hasPMap() getPMapSize()

</member>
        <member name="M:NxTriangleMesh.getPMapSize">
	\brief Gets the size of the pmap.

	\warning Legacy function

	\return The size (in bytes) necessary to store the associated PMap.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxTriangleMeshDesc.pmap NxPMap loadPMap() hasPMap()

</member>
        <member name="M:NxTriangleMesh.hasPMap">
	\brief Checks the mesh has a pmap or not.

	\warning Legacy function

	\return True if the mesh has a PMap associated with it.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxTriangleMeshDesc.pmap NxPMap loadPMap()

</member>
        <member name="M:NxTriangleMesh.loadPMap(NxPMap!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief This call lets you supply a pmap if you have not done so at creation time.

	\warning Legacy function

	<h3>Example</h3>
	
	\include NxPMap_Create.cpp

	\param[in] pmap The PMap to apply.
	\return True on success.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxTriangleMeshDesc.pmap NxPMap

</member>
        <member name="M:NxTriangleMesh.getPageBBox(System.UInt32)">
	\brief Retrieves the bounding box of a PhysX processor mesh page in the local space of the mesh

	\param pageIndex The index of the mesh page. Pages are indexed sequentially starting from 0.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxTriangleMesh.getPageCount">
\brief Retrieves the number of PhysX processor pages into which a mesh is divided.

Meshes used for PhysX processor collision are divided into a number of fixed-size pages. This 
returns the number of such pages for this mesh.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

</member>
        <member name="M:NxTriangleMesh.getStride(System.UInt32,NxInternalArray)">
	\brief Retrieves the stride value of a given internal array.

	The stride value is always a number of bytes. You have to skip this number of bytes
	to go from one element to the other in an array, starting from the base.

	\param[in] submeshIndex Reserved for future use, must be 0.
	\param[in] intArray The internal array stride to retrieve(e.g. triangles, points etc). See #NxInternalArray.
	\return The stride(number of bytes from one element to the next) for the internal array.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getCount() getFormat() getBase()

</member>
        <member name="M:NxTriangleMesh.getBase(System.UInt32,NxInternalArray)">
	\brief Retrieves the base pointer of a given internal array.

	Example:

	\include NxTriangleMesh_getBase.cpp

	
	\param[in] submeshIndex Reserved for future use, must be 0.
	\param[in] intArray The internal array pointer to retrieve(e.g. triangles, points etc). See #NxInternalArray.
	\return A pointer to the first element of the internal array.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getCount() getFormat() getStride()

</member>
        <member name="M:NxTriangleMesh.getFormat(System.UInt32,NxInternalArray)">
	\brief Retrieves the format of a given internal array.

	\param[in] submeshIndex Reserved for future use, must be 0.
	\param[in] intArray The internal array format to retrieve(e.g. triangles, points etc). See #NxInternalArray.
	\return The format of the internal array. See #NxInternalFormat

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getCount() getStride() getBase()

</member>
        <member name="M:NxTriangleMesh.getCount(System.UInt32,NxInternalArray)">
	\brief Retrieves the number of elements of a given internal array.

	\param[in] submeshIndex Reserved for future use, must be 0.
	\param[in] intArray The internal array size to retrieve(e.g. triangles, points etc). See #NxInternalArray.
	\return The number of elements in the internal array.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getFormat() getStride() getBase()

</member>
        <member name="M:NxTriangleMesh.getSubmeshCount">
\brief Not used.

</member>
        <member name="M:NxTriangleMesh.saveToDesc(NxTriangleMeshDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Saves the Mesh descriptor.

	\param[out] desc The descriptor used to retrieve the state of the object.
	\return True on success.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="T:NxTriangleMesh">

\brief A triangle mesh, also called a 'polygon soup'.

It is represented as an indexed triangle list. There are no restrictions on the
triangle data. 

To avoid duplicating data when you have several instances of a particular 
mesh positioned differently, you do not use this class to represent a 
mesh object directly. Instead, you create an instance of this mesh via
the NxTriangleMeshShape class.

<h3>Creation</h3>

To create an instance of this class call NxPhysicsSDK::createTriangleMesh(),
and NxPhysicsSDK::releaseTriangleMesh() to delete it. This is only possible
once you have released all of its NxTriangleMeshShape instances.


Example:

\include NxTriangleMesh_Create.cpp

<h3>Visualizations:</h3>
\li #NX_VISUALIZE_COLLISION_AABBS
\li #NX_VISUALIZE_COLLISION_SHAPES
\li #NX_VISUALIZE_COLLISION_AXES
\li #NX_VISUALIZE_COLLISION_VNORMALS
\li #NX_VISUALIZE_COLLISION_FNORMALS
\li #NX_VISUALIZE_COLLISION_EDGES
\li #NX_VISUALIZE_COLLISION_SPHERES

@see NxTriangleMeshDesc NxTriangleMeshShape NxPhysicsSDK.createTriangleMesh()

</member>
        <member name="T:NxTriangleMeshShape">
@} 
\addtogroup physics
  @{


\brief This class is a shape instance of a triangle mesh object of type NxTriangleMesh.

Each shape is owned by an actor that it is attached to.

<h3>Creation</h3>

An instance can be created by calling the createShape() method of the NxActor object
that should own it, with a NxTriangleMeshShapeDesc object as the parameter, or by adding the 
shape descriptor into the NxActorDesc class before creating the actor.

The shape is deleted by calling NxActor::releaseShape() on the owning actor.

PPU: Collision detection will only be performed against mesh pages which have been mapped into
PPU memory using #mapPageInstance()

Example:

\include NxTriangleMeshShape_Create.cpp

<h3>Visualizations:</h3>
\li #NX_VISUALIZE_COLLISION_AABBS
\li #NX_VISUALIZE_COLLISION_SHAPES
\li #NX_VISUALIZE_COLLISION_AXES
\li #NX_VISUALIZE_COLLISION_VNORMALS
\li #NX_VISUALIZE_COLLISION_FNORMALS
\li #NX_VISUALIZE_COLLISION_EDGES
\li #NX_VISUALIZE_COLLISION_SPHERES

@see NxTriangleMeshShapeDesc NxTriangleMesh

</member>
        <member name="M:NxSphereShapeDesc.isValid">
\brief Returns true if the descriptor is valid.
\return true if the current settings are valid

</member>
        <member name="M:NxSphereShapeDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxSphereShapeDesc.#ctor">
\brief constructor sets to default.

</member>
        <member name="M:NxSphereShape.getWorldSphere(NxSphere*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Gets the sphere data in world space.

	\param[out] worldSphere Retrieves the description of the sphere in world space.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSphere

</member>
        <member name="M:NxSphereShape.getRadius">
	\brief Retrieves the radius of the sphere.

	\return The radius of the sphere.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxSphereShape.setRadius(System.Single)">
	\brief Sets the sphere radius.

	Call this to initialize or alter the sphere. If this is not called,
	then the default settings create a unit sphere at the origin.

	<b>Sleeping:</b> Does <b>NOT</b> wake any actors associated with the shape.

	\param[in] radius The new radius for the sphere. <b>Range:</b> (0,inf)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="T:NxSphereShape">
\brief A sphere shaped collision detection primitive.

Each shape is owned by an actor that it is attached to.

<h3>Creation</h3>

An instance can be created by calling the createShape() method of the NxActor object
that should own it, with a NxSphereShapeDesc object as the parameter, or by adding the 
shape descriptor into the NxActorDesc class before creating the actor.

The shape is deleted by calling NxActor::releaseShape() on the owning actor.

Example:

\include NxSphereShape_Create.cpp

<h3>Visualizations</h3>
\li NX_VISUALIZE_COLLISION_AABBS
\li NX_VISUALIZE_COLLISION_SHAPES
\li NX_VISUALIZE_COLLISION_AXES

@see NxSphereShapeDesc NxShape

</member>
        <member name="T:NxSphereShapeDesc">
@} 
\addtogroup physics
  @{


@} 
\addtogroup physics
  @{

\brief Descriptor class for #NxSphereShape.
  
@see NxSphereShape NxShapeDesc


</member>
        <member name="M:NxPlaneShapeDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return return true if the current settings are valid

</member>
        <member name="M:NxPlaneShapeDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxPlaneShapeDesc.#ctor">
\brief constructor sets to default.

</member>
        <member name="T:NxPlaneShapeDesc">
@} 
\addtogroup physics
  @{

\brief Descriptor class for #NxPlaneShape.

See also the #NxPlane.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes (Hardware rigid body only)
\li PS3  : Yes
\li XB360: Yes

@see NxPlane NxPlaneShape NxShapeDesc NxActor.createShape()

</member>
        <member name="M:NxPlaneShape.getPlane">
	\brief retrieves the plane

	Note: 
	There is an inconsistency between the definition of a plane in the 
	NxPlane class and the NxPlaneShape and NxPlaneShapeDesc classes.
	The NxPlane class defines a point (X, Y, Z) in the plane when:
		normal.x*X + normal.y*Y + normal.z*Z + d = 0
	The NxPlaneShapeDesc and NxPlaneShape::setPlane() use the following definition:
		normal.x*X + normal.y*Y + normal.z*Z - d = 0
	Although the data is the same, the interpretation is different:
	<code>
	NxPlane plane;
	NxPlaneShape *planeShape;
	...
	planeShape-&gt;setPlane(plane.normal, plane.d);
	// At this point plane == planeShape-&gt;getPlane() will be true.
	// But plane.pointInPlane() will not return a point in 'planeShape'
 	...
	// To use the plane methods the following conversions are required:
	...
	// Assignment NxPlane -&gt; NxPlaneShape
	planeShape-&gt;setPlane(plane.normal, -plane.d); 
	// 'planeShape' now represents the same plane as 'plane'
	...
	// Assignment NxPlaneShape -&gt; NxPlane
	plane = planeShape-&gt;getPlane();
	plane.d *= -plane.d;
	// 'plane' now represents the same plane as 'planeShape'
	</code>

	\return The description of this plane. See #NxPlane.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Hardware rigid body only)
	\li PS3  : Yes
	\li XB360: Yes

	@see setPlane NxPlane

</member>
        <member name="M:NxPlaneShape.setPlane(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
	\brief sets the plane equation.

	<b>Sleeping:</b> Does <b>NOT</b> wake any actors associated with the shape.

	\param[in] normal Normal for the plane, in the global frame. <b>Range:</b> direction vector
	\param[in] d 'd' coefficient of the plane equation. <b>Range:</b> (-inf,inf)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Hardware rigid body only)
	\li PS3  : Yes
	\li XB360: Yes

	@see getPlane() NxPlane

</member>
        <member name="M:NxCapsuleShapeDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return True if the current settings are valid

</member>
        <member name="M:NxCapsuleShapeDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxCapsuleShapeDesc.#ctor">
\brief constructor sets to default.

</member>
        <member name="F:NxCapsuleShapeDesc.flags">
	\brief Combination of ::NxCapsuleShapeFlag

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCapsuleShapeFlag

</member>
        <member name="T:NxCapsuleShapeDesc">
@} 
\addtogroup physics
  @{

\brief Descriptor class for #NxCapsuleShape.

@see NxCapsuleShape NxShapeDesc NxActor.createShape() NxCapsule

</member>
        <member name="M:NxCapsuleShape.getWorldCapsule(NxCapsule*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Retrieves the capsule parameters in world space. See #NxCapsule.

	\param[out] worldCapsule Use to retrieve the capsule parameters in world space.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes
	
	@see NxCapsule

</member>
        <member name="M:NxCapsuleShape.getHeight">
	\brief Retrieves the height of the capsule.

	\return The height of the capsule measured from end to end.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes
	
	@see setHeight() setRadius() NxCapsuleShapeDesc.height

</member>
        <member name="M:NxCapsuleShape.setHeight(System.Single)">
	\brief Alters the height of the capsule. 

	<b>Sleeping:</b> Does <b>NOT</b> wake the associated actor up automatically.

	\param[in] height The new height of the capsule. <b>Range:</b> (0,inf)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes
	
	@see getHeight() NxCapsuleShapeDesc.height getRadius() setDimensions()

</member>
        <member name="M:NxCapsuleShape.getRadius">
	\brief Retrieves the radius of the capsule.

	\return The radius of the capsule.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes
	
	@see setRadius() setDimensions() NxCapsuleShapeDesc.radius

</member>
        <member name="M:NxCapsuleShape.setRadius(System.Single)">
	\brief Alters the radius of the capsule.

	<b>Sleeping:</b> Does <b>NOT</b> wake the associated actor up automatically.

	\param[in] radius The new radius of the capsule. <b>Range:</b> (0,inf)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setDimensions() NxCapsuleShapeDesc.radius getRadius()

</member>
        <member name="M:NxCapsuleShape.setDimensions(System.Single,System.Single)">
	\brief Call this to initialize or alter the capsule. 

	<b>Sleeping:</b> Does <b>NOT</b> wake the associated actor up automatically.

	\param[in] radius The new radius of the capsule. <b>Range:</b> (0,inf)
	\param[in] height The new height of the capsule. <b>Range:</b> (0,inf)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setRadius() setHeight()

</member>
        <member name="T:NxCapsuleShape">
\brief A capsule shaped collision detection primitive, also known as a line swept sphere.

'radius' is the radius of the capsule's hemispherical ends and its trunk.
'height' is the distance between the two hemispherical ends of the capsule.
The height is along the capsule's Y axis.

Each shape is owned by an actor that it is attached to.

<h3>Creation</h3>

An instance can be created by calling the createShape() method of the NxActor object
that should own it, with a NxCapsuleShapeDesc object as the parameter, or by adding the 
shape descriptor into the NxActorDesc class before creating the actor.

Example:

\include NxCapsuleShape_Create.cpp

The shape is deleted by calling NxActor::releaseShape() on the owning actor.

<h3>Visualizations</h3>
\li NX_VISUALIZE_COLLISION_AABBS
\li NX_VISUALIZE_COLLISION_SHAPES
\li NX_VISUALIZE_COLLISION_AXES

@see NxCapsuleShapeDesc NxShape NxActor.createShape()

</member>
        <member name="M:NxBoxShapeDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return True if the current settings are valid

</member>
        <member name="M:NxBoxShapeDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxBoxShapeDesc.#ctor">
\brief constructor sets to default.

</member>
        <member name="F:NxBoxShapeDesc.dimensions">
	\brief Dimensions of the box.
	
	The dimensions are the 'radii' of the box, meaning 1/2 extents in x dimension, 
	1/2 extents in y dimension, 1/2 extents in z dimension. All three must be positive.

	<b>Range:</b> .x (0,inf)
	<b>Range:</b> .y (0,inf)
	<b>Range:</b> .x (0,inf)
	<b>Default:</b> Zero

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBoxShape.setDimensions() NxBoxShape.getDimensions()

</member>
        <member name="T:NxBoxShapeDesc">
@} 
\addtogroup physics
  @{

\brief Descriptor class for #NxBoxShape.

@see NxBox NxShapeDesc NxActor.createShape()

</member>
        <member name="M:NxBoxShape.saveToDesc(NxBoxShapeDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Saves the state of the shape object to a descriptor.

	\param[out] desc Descriptor to save to.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBoxShapeDesc

</member>
        <member name="M:NxBoxShape.getWorldOBB(NxBox*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Gets the box represented as a world space OBB.

	\param[out] obb The orientated bounding box in the global frame. See #NxBox.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBox

</member>
        <member name="M:NxBoxShape.getDimensions">
	\brief Retrieves the dimensions of the box.

	The dimensions are the 'radii' of the box, meaning 1/2 extents in x dimension, 
	1/2 extents in y dimension, 1/2 extents in z dimension.

	\return The 'radii' of the box.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBoxShapeDesc.dimensions setDimensions()

</member>
        <member name="M:NxBoxShape.setDimensions(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the box dimensions.

	The dimensions are the 'radii' of the box, meaning 1/2 extents in x dimension, 
	1/2 extents in y dimension, 1/2 extents in z dimension. 

	<b>Sleeping:</b> Does <b>NOT</b> wake the associated actor up automatically.

	\param[in] vec The new 'radii' of the box. <b>Range:</b> direction vector

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBoxShapeDesc.dimensions getDimensions()

</member>
        <member name="T:NxBoxShape">
\brief A box shaped collision detection primitive.

Each shape is owned by the actor which it is attached to.

<h3>Creation</h3>

An instance can be created by calling the createShape() method of the NxActor object
that will own it, with a NxBoxShapeDesc object as the parameter, or by adding the 
shape descriptor to the NxActorDesc class before creating the actor.

Example (adding shape descriptor to an NxActorDesc):

\include NxBoxShape_CreateDesc.cpp

Example (creating for an already existing actor):

\include NxBoxShape_CreateWithActor.cpp

The shape is deleted by calling NxActor::releaseShape() on the owning actor.

<h3>Visualizations</h3>
\li NX_VISUALIZE_COLLISION_AABBS
\li NX_VISUALIZE_COLLISION_SHAPES
\li NX_VISUALIZE_COLLISION_AXES

@see NxBoxShapeDesc NxShape NxActor.createShape()

</member>
        <member name="M:NxD6JointDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return returns true if the current settings are valid

</member>
        <member name="M:NxD6JointDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxD6JointDesc.#ctor">
\brief constructor sets to default.

</member>
        <member name="F:NxD6JointDesc.flags">
	\brief This is a combination of the bits defined by ::NxD6JointFlag

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Partial (Slerp drive not supported)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxD6JointFlag

</member>
        <member name="F:NxD6JointDesc.projectionMode">
	\brief If projectionMode is NX_JPM_NONE, projection is disabled. If NX_JPM_POINT_MINDIST, bodies are projected to limits leaving an linear error of projectionDistance and an angular error of projectionAngle

	<b>Default:</b> NX_JPM_NONE

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxJointProjectionMode projectionDistance projectionAngle

</member>
        <member name="F:NxD6JointDesc.swing1Motion">
	\brief Define the angular degrees of freedom

	<b>Default:</b> NX_D6JOINT_MOTION_FREE

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxD6JointMotion swing1Motion swing2Motion twistMotion

</member>
        <member name="F:NxD6JointDesc.xMotion">
	\brief Define the linear degrees of freedom

	<b>Default:</b> NX_D6JOINT_MOTION_FREE

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxD6JointMotion xMotion yMotion zMotion

</member>
        <member name="M:NxJointLimitSoftPairDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return true if the current settings are valid

</member>
        <member name="M:NxJointLimitSoftPairDesc.setToDefault">
\brief Sets members to default values.

</member>
        <member name="M:NxJointLimitSoftPairDesc.#ctor">
\brief Constructor, sets members to default values.

</member>
        <member name="T:NxJointLimitSoftPairDesc">
@} 
\brief Describes a pair of joint limits

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

@see NxD6Joint NxD6JointDesc

</member>
        <member name="M:NxJointLimitSoftDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return true if the current settings are valid

</member>
        <member name="M:NxJointLimitSoftDesc.setToDefault">
\brief Sets members to default values.

</member>
        <member name="M:NxJointLimitSoftDesc.#ctor">
\brief Constructor, sets members to default values.

</member>
        <member name="T:NxJointLimitSoftDesc">
@} 
\addtogroup physics
  @{

\addtogroup physics
  @{

\brief Describes a joint limit.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

@see NxD6Joint NxD6JointDesc NxJointSoftLimitPairDesc

</member>
        <member name="M:NxD6Joint.setDriveAngularVelocity(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Set the drive angular velocity goal when it is being driven.

	The drive angular velocity is specified relative to the drive orientation target in the case of a slerp drive.

	The drive angular velocity is specified in the actor[0] joint frame in all other cases.
	
	<b>Sleeping:</b> This call wakes the actor(s) if they are sleeping.

	\param angVel The goal angular velocity if NX_D6JOINT_DRIVE_VELOCITY is set for swingDrive or 
	twistDrive. <b>Range:</b> angular velocity vector

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setDriveLinearVelocity() NxD6JointDesc.driveAngularVelocity

</member>
        <member name="M:NxD6Joint.setDriveLinearVelocity(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Set the drive goal linear velocity when it is being driven.

	The drive linear velocity is specified relative to the actor[0] joint frame.

	<b>Sleeping:</b> This call wakes the actor(s) if they are sleeping.

	\param linVel The goal velocity if NX_D6JOINT_DRIVE_VELOCITY is set for xDrive,yDrive or zDrive.
	See #NxD6JointDesc. <b>Range:</b> velocity vector

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setDriveAngularVelocity NxD6JointDesc.driveLinearVelocity

</member>
        <member name="M:NxD6Joint.setDriveOrientation(NxQuat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Set the drive goal orientation when it is being driven.

	The goal orientation is specified relative to the joint frame corresponding to actor[0].

	<b>Sleeping:</b> This call wakes the actor(s) if they are sleeping.

	\param orientation The goal orientation if NX_D6JOINT_DRIVE_POSITION is set for swingDrive or
	twistDrive. <b>Range:</b> unit quaternion

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setDrivePosition NxD6JointDesc.driveOrientation

</member>
        <member name="M:NxD6Joint.setDrivePosition(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Set the drive position goal position when it is being driven.

	The goal position is specified relative to the joint frame corresponding to actor[0].

	<b>Sleeping:</b> This call wakes the actor(s) if they are sleeping.

	\param position The goal position if NX_D6JOINT_DRIVE_POSITION is set for xDrive,yDrive or zDrive. <b>Range:</b> position vector

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setDriveOrientation() NxD6JointDesc.drivePosition
	@see NxD6JointDesc

</member>
        <member name="M:NxD6Joint.saveToDesc(NxD6JointDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Writes all of the object's attributes to the desc struct  

	\param[out] desc The descriptor used to retrieve the state of the object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see loadFromDesc NxD6JointDesc

</member>
        <member name="M:NxD6Joint.loadFromDesc(NxD6JointDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Use this for changing a significant number of joint parameters at once.

	Use the set() methods for changing only a single property at once.

	Please note that you can not change the actor pointers using this function, if you do so the joint will be marked as broken and will stop working.
	
	Calling the loadFromDesc() method on a broken joint will result in an error message.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] desc The descriptor used to set the state of the object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see saveToDesc NxD6JointDesc

</member>
        <member name="T:NxD6Joint">
 \brief A D6 joint is a general constraint between two actors.
 
 It allows the user to individually define the linear and rotational degrees of freedom. 
 It also allows the user to configure the joint with limits and driven degrees of freedom as they wish.

 For example to create a fixed joint we would need to do:

 \code
	...
	d6Desc.twistMotion = NX_D6JOINT_MOTION_LOCKED;
    d6Desc.swing1Motion = NX_D6JOINT_MOTION_LOCKED;
    d6Desc.swing2Motion = NX_D6JOINT_MOTION_LOCKED;

    d6Desc.xMotion = NX_D6JOINT_MOTION_LOCKED;
    d6Desc.yMotion = NX_D6JOINT_MOTION_LOCKED;
    d6Desc.zMotion = NX_D6JOINT_MOTION_LOCKED;
	...
 \endcode

 Or a Revolute joint:

 \code
	...
	d6Desc.twistMotion = NX_D6JOINT_MOTION_FREE;
    d6Desc.swing1Motion = NX_D6JOINT_MOTION_LOCKED;
    d6Desc.swing2Motion = NX_D6JOINT_MOTION_LOCKED;

    d6Desc.xMotion = NX_D6JOINT_MOTION_LOCKED;
    d6Desc.yMotion = NX_D6JOINT_MOTION_LOCKED;
    d6Desc.zMotion = NX_D6JOINT_MOTION_LOCKED;
	...

 \endcode

 And a spherical joint:

 \code
	...
	d6Desc.twistMotion = NX_D6JOINT_MOTION_FREE;
    d6Desc.swing1Motion = NX_D6JOINT_MOTION_FREE;
    d6Desc.swing2Motion = NX_D6JOINT_MOTION_FREE;

    d6Desc.xMotion = NX_D6JOINT_MOTION_LOCKED;
    d6Desc.yMotion = NX_D6JOINT_MOTION_LOCKED;
    d6Desc.zMotion = NX_D6JOINT_MOTION_LOCKED;
	...
 \endcode


<h3>Creation</h3>

Example:

\include NxD6Joint_Create.cpp

<h3>Visualizations:</h3>
\li #NX_VISUALIZE_JOINT_LOCAL_AXES
\li #NX_VISUALIZE_JOINT_WORLD_AXES
\li #NX_VISUALIZE_JOINT_LIMITS

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Partial(some features are not supported. Hardware D6 joints have different properties to 
software joints so may behave slightly differently. See the user guide for details)
\li PS3  : Yes
\li XB360: Yes

@see NxD6JointDesc NxJoint NxScene.createJoint()

</member>
        <member name="T:NxD6JointDesc">
@} 
\addtogroup physics
  @{


@} 
\addtogroup physics
  @{

\brief Descriptor class for the D6Joint. See #NxD6Joint.

 <p>In the D6Joint, the axes are assigned as follows:
 <ul><li>x-axis = joint axis</li><li>y-axis = joint normal axis</li><li>z-axis = x-axis cross y-axis</li></ul>
 These are defined relative to the parent body (0) of the joint.</p><p>
 Swing is defined as the rotation of the x-axis with respect to the y- and z-axis.
 </p><p>
 Twist is defined as the rotation about the x-axis.
 </p><b>Platform:</b>
\li PC SW: Yes
\li PPU  : Partial(some features not supported)
\li PS3  : Yes
\li XB360: Yes

 @see NxD6Joint NxJointDesc NxScene.createJoint() 

</member>
        <member name="M:NxPulleyJointDesc.isValid">
\brief Returns true if the descriptor is valid.
\return true if the current settings are valid

</member>
        <member name="M:NxPulleyJointDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxPulleyJointDesc.#ctor">
\brief constructor sets to default.

</member>
        <member name="F:NxPulleyJointDesc.flags">
	\brief This is a combination of the bits defined by ::NxPulleyJointFlag.

	<b>Default:</b> 0

	@see NxPulleyJointFlag.

</member>
        <member name="M:NxPulleyJoint.getFlags">
	\brief returns the current flag settings. see #NxPulleyJointFlag

	\return The flag settings for this object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setFlags() NxPulleyJointFlag

</member>
        <member name="M:NxPulleyJoint.setFlags(System.UInt32)">
	\brief Sets the flags.	This is a combination of the ::NxPulleyJointFlag bits.

	<b>Sleeping:</b> This call wakes the actor(s) if they are sleeping.

	\param[in] flags New set of flags for this joint. See #NxPulleyJointFlag

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxPulleyJointFlag getFlags()

</member>
        <member name="M:NxPulleyJoint.getMotor(NxMotorDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Reads back the motor parameters. Returns true if it is enabled.

	\param[out] motorDesc Used to retrieve the settings for this joint.
	\return True if the motor is enabled.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setMotor NxMotorDesc

</member>
        <member name="M:NxPulleyJoint.setMotor(NxMotorDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets motor parameters for the joint.
	
	For a positive velTarget, the motor pulls the first body towards its pulley, 
	for a negative velTarget, the motor pulls the second body towards its pulley.
	
	<ul><li>velTarget - the relative velocity the motor is trying to achieve. The motor will only be able
				to reach this velocity if the maxForce is sufficiently large. If the joint is 
				moving faster than this velocity, the motor will actually try to brake. If you set this
				to infinity then the motor will keep speeding up, unless there is some sort of resistance
				on the attached bodies. </li><li>maxForce -  the maximum force the motor can exert. Zero disables the motor.
				Default is 0, should be &gt;= 0. Setting this to a very large value if velTarget is also 
				very large may not be a good idea.</li><li>freeSpin -  if this flag is set, and if the joint is moving faster than velTarget, then neither
				braking nor additional acceleration will result.
				default: false.</li></ul>
	This automatically enables the motor.

	<b>Sleeping:</b> This call wakes the actor(s) if they are sleeping.

	\param[in] motorDesc

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxMotorDesc getMotor()

</member>
        <member name="M:NxPulleyJoint.saveToDesc(NxPulleyJointDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Writes all of the object's attributes to the desc struct.  

	\param[out] desc The descriptor used to retrieve the state of the object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see loadFromDesc() NxPulleyJointDesc

</member>
        <member name="M:NxPulleyJoint.loadFromDesc(NxPulleyJointDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Use this for changing a significant number of joint parameters at once.

	Use the set() methods for changing only a single property at once.

	Please note that you can not change the actor pointers using this function, if you do so the joint will be marked as broken and will stop working.
	
	Calling the loadFromDesc() method on a broken joint will result in an error message.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] desc The descriptor used to set the state of the object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see saveToDesc NxPulleyJointDesc

</member>
        <member name="T:NxPulleyJoint">
 \brief A pulley joint simulates a rope between two objects passing over 2 pulleys.

 \image html pulleyJoint.png
 <h3>Creation</h3>

 Example:

 \include NxPulleyJoint_Create.cpp

 <h3>Visualizations:</h3>
\li #NX_VISUALIZE_JOINT_LOCAL_AXES
\li #NX_VISUALIZE_JOINT_WORLD_AXES
\li #NX_VISUALIZE_JOINT_LIMITS

 @see NxJoint NxPulleyJointDesc NxScene.createJoint()

</member>
        <member name="T:NxPulleyJointDesc">
@} 
\addtogroup physics
  @{


@} 
\addtogroup physics
  @{

\brief Desc class for #NxPulleyJoint.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

@see NxPulleyJoint NxJointDesc

</member>
        <member name="M:NxDistanceJointDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return true if the current settings are valid

</member>
        <member name="M:NxDistanceJointDesc.setToDefault(System.Boolean)">
	\brief (re)sets the structure to the default.	

	\param[in] fromCtor skip redundant operations if called from contructor.

</member>
        <member name="M:NxDistanceJointDesc.#ctor">
\brief Constructor sets to default.

</member>
        <member name="F:NxDistanceJointDesc.flags">
	\brief This is a combination of the bits defined by ::NxDistanceJointFlag. 

	<b>Default:</b> 0

</member>
        <member name="M:NxDistanceJoint.saveToDesc(NxDistanceJointDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Writes all of the object's attributes to the desc struct  

	\param[out] desc The descriptor used to retrieve this objects state.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see loadFromDesc() NxDistanceJointDesc

</member>
        <member name="M:NxDistanceJoint.loadFromDesc(NxDistanceJointDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Use this for changing a significant number of joint parameters at once.

	Use the set() methods for changing only a single property at once.

	Please note that you can not change the actor pointers using this function, if you do so the joint will be marked as broken and will stop working.
	
	Calling the loadFromDesc() method on a broken joint will result in an error message.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] desc The descriptor used to set this objects state.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see saveToDesc() NxDistanceJointDesc

</member>
        <member name="T:NxDistanceJoint">
 \brief A distance joint maintains a certain distance between two points on two actors.

 \image html distanceJoint.png

 <h3>Creation</h3>

 Example:

 \include NxDistanceJoint_Create.cpp
 
 <h3>Visualizations:</h3>
\li #NX_VISUALIZE_JOINT_LOCAL_AXES
\li #NX_VISUALIZE_JOINT_WORLD_AXES
\li #NX_VISUALIZE_JOINT_LIMITS

 @see NxDistanceJointDesc NxJoint NxScene.createJoint()

</member>
        <member name="T:NxDistanceJointDesc">
@} 
\addtogroup physics
  @{


@} 
\addtogroup physics
  @{

\brief Desc class for distance joint. See #NxDistanceJoint.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

@see NxDistanceJoint NxJointDesc NxScene.createJoint()


</member>
        <member name="M:NxFixedJointDesc.isValid">
	\brief Return true if the descriptor is valid.

	\return true if the current settings are valid

</member>
        <member name="M:NxFixedJointDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxFixedJointDesc.#ctor">
\brief Constructor sets to default.

</member>
        <member name="M:NxFixedJoint.saveToDesc(NxFixedJointDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Writes all of the object's attributes to the desc struct  

	\param[out] desc The descriptor used to retrieve this objects state.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxFixedJoint.loadFromDesc(NxFixedJointDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Use this for changing a significant number of joint parameters at once.

	Use the set() methods for changing only a single property at once.

	Please note that you can not change the actor pointers using this function, if you do so the joint will be marked as broken and will stop working.
	
	Calling the loadFromDesc() method on a broken joint will result in an error message.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] desc The descriptor used to set this objects state.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="T:NxFixedJoint">
 \brief A fixed joint permits no relative movement between two bodies. ie the bodies are glued together.

  \image html fixedJoint.png

 <h3>Creation</h3>

 Example:

 \include NxFixedJoint_Create.cpp

 <h3>Visualizations:</h3>
\li #NX_VISUALIZE_JOINT_LOCAL_AXES
\li #NX_VISUALIZE_JOINT_WORLD_AXES
\li #NX_VISUALIZE_JOINT_LIMITS

 @see NxFixedJointDesc NxScene.createJoint()

</member>
        <member name="T:NxFixedJointDesc">
@} 
\addtogroup physics
  @{


@} 
\addtogroup physics
  @{

\brief Desc class for fixed joint.


<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

@see NxFixedJoint NxScene.createJoint()

</member>
        <member name="M:NxSphericalJoint.getProjectionMode">
	\brief Returns the current flag settings.

	\return The joints projection mode. See #NxJointProjectionMode.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setProjectionMode() NxJointProjectionMode

</member>
        <member name="M:NxSphericalJoint.setProjectionMode(NxJointProjectionMode)">
	\brief Sets the joint projection mode.

	\param[in] projectionMode The new projection mode for the joint. See #NxJointProjectionMode.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getProjectionMode() NxJointProjectionMode

</member>
        <member name="M:NxSphericalJoint.getFlags">
	\brief Returns the current flag settings.

	\return The flags associated with the joint.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getFlags() NxSphericalJointFlag

</member>
        <member name="M:NxSphericalJoint.setFlags(System.UInt32)">
	\brief Sets the flags to enable/disable the spring/motor/limit.
	
	This is a combination of the bits defined by ::NxSphericalJointFlag.

	\param[in] flags The new value for the joint flags.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSphericalJointFlag getFlags()

</member>
        <member name="M:NxSphericalJoint.saveToDesc(NxSphericalJointDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Writes all of the object's attributes to the desc struct  

	\param[out] desc The descriptor used to retrieve the state of the object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSphericalJointDesc loadFromDesc()

</member>
        <member name="M:NxSphericalJoint.loadFromDesc(NxSphericalJointDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Use this for changing a significant number of joint parameters at once.

	Use the set() methods for changing only a single property at once.

	Please note that you can not change the actor pointers using this function, if you do so the joint will be marked as broken and will stop working.

	Calling the loadFromDesc() method on a broken joint will result in an error message.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] desc The descriptor used to set the state of the object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSphericalJointDesc saveToDesc()

</member>
        <member name="T:NxSphericalJoint">
@} 
 \brief A sphere joint constrains two points on two bodies to coincide.

 This point, specified in world space (this guarantees that the points coincide 
 to start with) is the only parameter that has to be specified.

 \image html sphericalJoint.png

 <h3>Creation</h3>

 Example:

 \include NxSphericalJoint_Create.cpp

 <h3>Visualizations:</h3>
\li #NX_VISUALIZE_JOINT_LOCAL_AXES
\li #NX_VISUALIZE_JOINT_WORLD_AXES
\li #NX_VISUALIZE_JOINT_LIMITS

 @see NxSphericalJointDesc NxScene.createJoint() NxJoint

</member>
        <member name="M:NxSphericalJointDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return true if the current settings are valid

</member>
        <member name="M:NxSphericalJointDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxSphericalJointDesc.#ctor">
\brief Constructor sets to default.

</member>
        <member name="F:NxSphericalJointDesc.projectionMode">
	\brief use this to enable joint projection

	<b>Default:</b> NX_JPM_NONE

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see projectionDistance NxJointProjectionMode

</member>
        <member name="F:NxSphericalJointDesc.flags">
	\brief This is a combination of the bits defined by ::NxSphericalJointFlag . 

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSphericalJointFlag

</member>
        <member name="T:NxSphericalJointDesc">
\brief Desc class for an #NxSphericalJoint.

@see NxSphericalJoint NxScene.createJoint()

</member>
        <member name="M:NxCylindricalJointDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return true if the current settings are valid

</member>
        <member name="M:NxCylindricalJointDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxCylindricalJointDesc.#ctor">
\brief Constructor sets to default.

</member>
        <member name="M:NxCylindricalJoint.saveToDesc(NxCylindricalJointDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Writes all of the object's attributes to the desc struct

	\param[out] desc The descriptor used to retrieve the state of the object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes
	
	@see loadFromDesc() NxCylindricalJointDesc

</member>
        <member name="M:NxCylindricalJoint.loadFromDesc(NxCylindricalJointDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Use this for changing a significant number of joint parameters at once.

	Use the set() methods for changing only a single property at once.

	Please note that you can not change the actor pointers using this function, if you do so the joint will be marked as broken and will stop working.
	
	Calling the loadFromDesc() method on a broken joint will result in an error message.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] desc The descriptor used to set the state of the object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see saveToDesc() NxCylindricalJointDesc

</member>
        <member name="T:NxCylindricalJoint">
\brief Cylindrical Joints permit relative translational movement between two bodies along
 an axis, and also relative rotation along the axis.


 \image html cylinderJoint.png

 <h3>Creation</h3>

 Example:

 \include NxCylindricalJoint_Create.cpp

<h3>Visualizations:</h3>
\li #NX_VISUALIZE_JOINT_LOCAL_AXES
\li #NX_VISUALIZE_JOINT_WORLD_AXES
\li #NX_VISUALIZE_JOINT_LIMITS

 @see NxCylindricalJointDesc NxJoint NxScene.createJoint()

</member>
        <member name="T:NxCylindricalJointDesc">
@} 
\addtogroup physics
  @{


@} 
\addtogroup physics
  @{

\brief Desc class for sliding joint. See #NxCylindricalJoint.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

@see NxCylindricalJoint NxJointDesc NxScene.createJoint()

</member>
        <member name="M:NxPrismaticJointDesc.isValid">
\brief Returns true if the descriptor is valid.
\return true if the current settings are valid

</member>
        <member name="M:NxPrismaticJointDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxPrismaticJointDesc.#ctor">
\brief Constructor sets to default.

</member>
        <member name="M:NxPrismaticJoint.saveToDesc(NxPrismaticJointDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Writes all of the object's attributes to the desc struct  

	\param[out] desc The descriptor used to retrieve the state of the object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see loadFromDesc NxPrismaticJointDesc

</member>
        <member name="M:NxPrismaticJoint.loadFromDesc(NxPrismaticJointDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Use this for changing a significant number of joint parameters at once.

	Use the set() methods for changing only a single property at once.

	Please note that you can not change the actor pointers using this function, if you do so the joint will be marked as broken and will stop working.
	
	Calling the loadFromDesc() method on a broken joint will result in an error message.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] desc The descriptor used to set the state of the object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see saveToDesc NxPrismaticJointDesc

</member>
        <member name="T:NxPrismaticJoint">
 \brief A prismatic joint permits relative translational movement between two bodies along
 an axis, but no relative rotational movement.

 \image html prismJoint.png

 <h3>Creation</h3>

 \include NxPrismaticJoint_Create.cpp

 <h3>Visualizations:</h3>
\li #NX_VISUALIZE_JOINT_LOCAL_AXES
\li #NX_VISUALIZE_JOINT_WORLD_AXES
\li #NX_VISUALIZE_JOINT_LIMITS

 @see NxPrismaticJointDesc NxJoint NxScene.createJoint()

</member>
        <member name="T:NxPrismaticJointDesc">
@} 
\addtogroup physics
  @{


@} 
\addtogroup physics
  @{

\brief Desc class for #NxPrismaticJoint.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

@see NxJointDesc NxPrismaticJoint NxScene.createJoint

</member>
        <member name="M:NxRevoluteJoint.getProjectionMode">
	\brief Retrieves the joints projection mode.

	\return the current flag settings.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setProjectionMode() NxJointProjectionMode NxRevoluteJointDesc.projectionMode

</member>
        <member name="M:NxRevoluteJoint.setProjectionMode(NxJointProjectionMode)">
	\brief Sets the joint projection mode.

	\param[in] projectionMode The new projection mode. See #NxJointProjectionMode.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getProjectionMode() NxJointProjectionMode NxRevoluteJointDesc.projectionMode

</member>
        <member name="M:NxRevoluteJoint.getFlags">
	\brief Retrieve the revolute joints flags.

	\return the current flag settings. See #NxRevoluteJointFlag

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setFlags() NxRevoluteJointFlag

</member>
        <member name="M:NxRevoluteJoint.setFlags(System.UInt32)">
	\brief Sets the flags to enable/disable the spring/motor/limit.
	
	This is a combination of the ::NxRevoluteJointFlag bits.

	\param[in] flags A combination of NxRevoluteJointFlag flags to set for this joint

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxRevoluteJointFlag getFlags()

</member>
        <member name="M:NxRevoluteJoint.getVelocity">
	\brief Retrieves the revolute joint angle's rate of change (angular velocity).

	It is the angular velocity of body1 minus body2 projected along the axis.

	\return The hinge velocity.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getAngle()

</member>
        <member name="M:NxRevoluteJoint.getAngle">
	\brief Retrieves the current revolute joint angle.
	
	The relative orientation of the bodies is stored when the joint is created, or when setAxis() 
	or setAnchor() is called.
	This initial orientation returns an angle of zero, and joint angles are measured
	relative to this pose.
	The angle is in the range [-Pi, Pi], with positive angles CCW around the axis, measured
	from body2 to body1.

	<b>Unit:</b> Radians
	<b>Range:</b> [-PI,PI]

	\return The current hinge angle.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getVelocity()

</member>
        <member name="M:NxRevoluteJoint.getSpring(NxSpringDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Retrieves spring settings.
	
	Returns true if it is enabled.

	@see setSpring

	\param[out] springDesc Used to retrieve the spring parameters for the joint. See #NxSpringDesc.
	\return True if the spring is enabled.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSpringDesc setSpring()

</member>
        <member name="M:NxRevoluteJoint.setSpring(NxSpringDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets spring parameters.
	
	The spring is implicitly integrated so no instability should result for arbitrary
	spring and damping constants. Using these settings together with a motor is not possible -- the motor will have
	priority and the spring settings are ignored.
	If you would like to simulate your motor's internal friction, do this by altering the motor parameters directly.

	spring - The rotational spring acts along the hinge axis and tries to force
				the joint angle to zero. A setting of zero disables the spring. Default is 0, should be &gt;= 0.
	damper - Damping coefficient; acts against the hinge's angular velocity. A setting of zero disables
				the damping. The default is 0, should be &gt;= 0.
	targetValue - The angle at which the spring is relaxed. In [-Pi,Pi]. Default is 0.

	This automatically enables the spring.

	\param[in] springDesc The new spring parameters for the joint. <b>Range:</b> See #NxSpringDesc.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getSpring() NxSpringDesc

</member>
        <member name="M:NxRevoluteJoint.getMotor(NxMotorDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Reads back the motor parameters.
	
	Returns true if it is enabled.

	\param[out] motorDesc Used to store the motor parameters of the joint. See #NxMotorDesc
	\return True if the motor is enabled.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setMotor() NxMotorDesc

</member>
        <member name="M:NxRevoluteJoint.setMotor(NxMotorDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets motor parameters for the joint.
	
	The motor rotates the bodies relative to each other along the hinge axis. The motor has these parameters:
	
	<ul><li>velTarget - the relative velocity the motor is trying to achieve. The motor will only be able
				to reach this velocity if the maxForce is sufficiently large. If the joint is 
				spinning faster than this velocity, the motor will actually try to brake. If you set this
				to infinity then the motor will keep speeding up, unless there is some sort of resistance
				on the attached bodies. The sign of this variable determines the rotation direction,
				with positive values going the same way as positive joint angles.
				Default is infinity.</li><li>maxForce -  the maximum force (torque in this case) the motor can exert. Zero disables the motor.
				Default is 0, should be &gt;= 0. Setting this to a very large value if velTarget is also 
				very large may not be a good idea.</li><li>freeSpin -  if this flag is set, and if the joint is spinning faster than velTarget, then neither
				braking nor additional acceleration will result.
				default: false.</li></ul>

	This automatically enables the motor.

	\param[in] motorDesc The new motor parameters for the joint. <b>Range:</b> See #NxMotorDesc

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxMotorDesc getMotor()

</member>
        <member name="M:NxRevoluteJoint.getLimits(NxJointLimitPairDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Retrieves the joint limits.
	
	Returns true if it is enabled.

	Also returns the limit restitutions.

	\param[in] pair Used to retrieve the joint limit settings.
	\return True if the limit is enabled.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setLimits() NxJointLimitPairDesc NxJointLimitDesc

</member>
        <member name="M:NxRevoluteJoint.saveToDesc(NxRevoluteJointDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Writes all of the object's attributes to the desc struct  .

	\param[out] desc The descriptor used to retrieve the state of the object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see loadFromDesc() NxRevoluteJointDesc

</member>
        <member name="M:NxRevoluteJoint.loadFromDesc(NxRevoluteJointDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Use this for changing a significant number of joint parameters at once.

	Use the set() methods for changing only a single property at once.

	Please note that you can not change the actor pointers using this function, if you do so the joint will be marked as broken and will stop working.
	
	Calling the loadFromDesc() method on a broken joint will result in an error message.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] desc The descriptor used to set the state of the object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see saveToDesc() NxRevoluteJointDesc

</member>
        <member name="T:NxRevoluteJoint">

\brief A joint which behaves in a similar way to a hinge or axel.

 A hinge joint removes all but a single rotational degree of freedom from two objects.
 The axis along which the two bodies may rotate is specified with a point and a direction
 vector.

 \image html revoluteJoint.png

 <h3>Creation</h3>

 Example:

 \include NxRevoluteJoint_Create.cpp

 A revolute joint can be given a motor, so that it can apply a force to rotate the attached actors.

 Example:

 \include NxRevoluteJoint_Motor.cpp

 <h3>Visualizations:</h3>
\li #NX_VISUALIZE_JOINT_LOCAL_AXES
\li #NX_VISUALIZE_JOINT_WORLD_AXES
\li #NX_VISUALIZE_JOINT_LIMITS

 @see NxRevoluteJointDesc NxScene.createJoint() NxJoint

</member>
        <member name="M:NxRevoluteJointDesc.isValid">
\brief Returns true if the descriptor is valid.

\return true if the current settings are valid

</member>
        <member name="M:NxRevoluteJointDesc.setToDefault(System.Boolean)">
	\brief (re)sets the structure to the default.	

	\param[in] fromCtor Avoid redundant work if called from constructor.

</member>
        <member name="M:NxRevoluteJointDesc.#ctor">
\brief constructor sets to default.

</member>
        <member name="F:NxRevoluteJointDesc.projectionMode">
	\brief use this to enable joint projection

	<b>Default:</b> NX_JPM_NONE

	@see NxJointProjectionMode projectionDistance projectionAngle NxRevoluteJoint.setProjectionMode()

</member>
        <member name="F:NxRevoluteJointDesc.flags">
	\brief This is a combination of the bits defined by ::NxRevoluteJointFlag.

	<b>Default:</b> 0

	@see NxRevoluteJointFlag

</member>
        <member name="T:NxRevoluteJointDesc">
@} 
\addtogroup physics
  @{

\addtogroup physics
  @{

\brief Desc class for #NxRevoluteJoint.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

@see NxRevoluteJoint

</member>
        <member name="M:NxPointOnLineJointDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return true if the current settings are valid

</member>
        <member name="M:NxPointOnLineJointDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxPointOnLineJointDesc.#ctor">
\brief Constructor sets to default.

</member>
        <member name="M:NxPointOnLineJoint.saveToDesc(NxPointOnLineJointDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Writes all of the object's attributes to the desc struct  

	\param[out] desc The descriptor used to retrieve the state of the object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see loadFromDesc() NxPointOnLineJointDesc

</member>
        <member name="M:NxPointOnLineJoint.loadFromDesc(NxPointOnLineJointDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Use this for changing a significant number of joint parameters at once.

	Use the set() methods for changing only a single property at once.

	Please note that you can not change the actor pointers using this function, if you do so the joint will be marked as broken and will stop working.
	
	Calling the loadFromDesc() method on a broken joint will result in an error message.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] desc The descriptor used to set the state of the object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see saveToDesc() NxPointOnLineJointDesc

</member>
        <member name="T:NxPointOnLineJoint">
 \brief A point on line joint constrains a point on one body to only move along
 a line attached to another body.

 The starting point of the joint is defined as the anchor point. The line
 through this point is specified by its direction (axis) vector.

 \image html pointOnLineJoint.png

 <h3>Creation</h3>

 \include NxPointOnLineJoint_Create.cpp

 <h3>Visualizations:</h3>
\li #NX_VISUALIZE_JOINT_LOCAL_AXES
\li #NX_VISUALIZE_JOINT_WORLD_AXES
\li #NX_VISUALIZE_JOINT_LIMITS

 @see NxPointOnLineJointDesc NxScene.createJoint() NxJoint

</member>
        <member name="T:NxPointOnLineJointDesc">
@} 
\addtogroup physics
  @{


@} 
\addtogroup physics
  @{

\brief Desc class for point-on-line joint.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

@see NxPointOnLineJoint NxScene.createJoint() NxJointDesc

</member>
        <member name="M:NxPointInPlaneJointDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return true if the current settings are valid

</member>
        <member name="M:NxPointInPlaneJointDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxPointInPlaneJointDesc.#ctor">
\brief Constructor sets to default.

</member>
        <member name="M:NxJointDesc.#ctor(NxJointType)">
	\brief Constructor sets to default.

	\param t Joint type

</member>
        <member name="M:NxJointDesc.getType">
	\brief Retrieves the joint type.

	\return The type of joint this descriptor describes. See #NxJointType.

	@see NxJointType

</member>
        <member name="M:NxJointDesc.setGlobalAxis(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Set the local axis/normal using a world space axis.

	sets the members localAxis[0,1] by transforming the passed world space
	vector into actor1 resp. actor2's local space, and finding arbitrary orthogonals for localNormal[0,1].
	The actor pointers must already be set!

	\param[in] wsAxis Global frame axis. <b>Range:</b> direction vector

	@see setGlobalAnchor() localAnchor

</member>
        <member name="M:NxJointDesc.setGlobalAnchor(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Set the localAnchor[] members using a world space point.

	sets the members localAnchor[0,1] by transforming the passed world space
	vector into actor1 resp. actor2's local space. The actor pointers must already be set!

	\param[in] wsAnchor Global frame anchor point. <b>Range:</b> position vector

	@see setGlobalAxis() localAxis

</member>
        <member name="M:NxJointDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return true if the current settings are valid

</member>
        <member name="M:NxJointDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="F:NxJointDesc.jointFlags">
	\brief This is a combination of the bits defined by ::NxJointFlag .

	<b>Default:</b> NX_JF_VISUALIZATION

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxJointDesc.name">
	\brief Possible debug name. The string is not copied by the SDK, only the pointer is stored.

	<b>Default</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxJointDesc.userData">
	\brief Will be copied to NxJoint::userData.

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxJointDesc.actor">
	\brief The two actors connected by the joint.
	
	The actors must be in the same scene as this joint.
	
	At least one of the two pointers must be a dynamic actor.
	
	One of the two may be NULL to indicate the world frame. Neither may be a static actor!

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxActor

</member>
        <member name="F:NxJointDesc.type">
\brief The type of joint. This is set by the c'tor of the derived class.

</member>
        <member name="T:NxCookingInterface">
\brief Retrieves the Physics SDK Cooking Library for a specific version of the SDK.

\note Not supported on platforms where dynamic linking is not used (Xbox 360 and PS3).

\param sdk_version_number the version of the PhysX SDK, in hexadecimal format (e.g. 0x02060000 for
2.6.0). You may also use the NX_PHYSICS_SDK_VERSION constant.

</member>
        <member name="M:NxGetUtilLib">
\brief Retrieves the Physics SDK Utility Library

Before using this function the user must call #NxCreatePhysicsSDK(). If #NxCreatePhysicsSDK()
has not been called then NULL will be returned.

</member>
        <member name="M:NxGetPhysicsSDK">
\brief Retrieves the Physics SDK after it has been created.

Before using this function the user must call #NxCreatePhysicsSDK(). If #NxCreatePhysicsSDK()
has not been called then NULL will be returned.

</member>
        <member name="M:NxGetFoundationSDK">
\brief Retrieves the Foundation SDK after it has been created.

Before using this function the user must call #NxCreatePhysicsSDK(). If #NxCreatePhysicsSDK()
has not been called then NULL will be returned..

</member>
        <member name="M:NxGetPhysicsSDKAllocator">
\brief Retrieves the Physics SDK allocator.

Used by NxAllocateable's inlines and other macros below.

Before using this function the user must call #NxCreatePhysicsSDK(). If #NxCreatePhysicsSDK()
has not been called then NULL will be returned.

</member>
        <member name="M:NxReleasePhysicsSDK(NxPhysicsSDK*)">
\brief Release an instance of the PhysX SDK.

Note that this must be called once for each prior call to NxCreatePhysicsSDK or NxCreatePhysicsSDKWithID, as
there is a reference counter. Also note that you mustn't destroy the allocator or the outputStream (if available) until after the
reference count reaches 0 and the SDK is actually removed.

Releasing an SDK will also release any scenes, triangle meshes, convex meshes, heightfields, CCD skeletons, and cloth
meshes created through it, provided the user hasn't already done so.

You should release all scenes created with the SDK prior to calling this method, or resources may not be released.

</member>
        <member name="M:NxCreatePhysicsSDKWithID(System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,NxUserAllocator*,NxUserOutputStream*,NxPhysicsSDKDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxSDKCreateError*)">
\brief Creates an instance of the physics SDK with an ID string for application identification.

Creates an instance of this class. May not be a class member to avoid name mangling.
Pass the constant NX_PHYSICS_SDK_VERSION as the argument.
Because the class is a singleton class, multiple calls return the same object. However, each call must be
matched by a corresponding call to NxReleasePhysicsSDK, as the SDK uses a reference counter to the singleton.

NOTE: Calls after the first will not change the allocator used in the SDK, but they will affect the output stream.

\param sdkVersion Version number we are expecting(should be NX_PHYSICS_SDK_VERSION)
\param companyNameStr Character string for the game or application developer company name
\param appNameStr Character string for the game or application name
\param appVersionStr Character string for the game or application version
\param appUserDefinedStr Character string for additional, user defined data
\param allocator User supplied interface for allocating memory(see #NxUserAllocator)
\param outputStream User supplied interface for reporting errors and displaying messages(see #NxUserOutputStream)
\param desc Optional descriptor used to define hardware allocation parameters
\param errorCode Optional error code output parameter

</member>
        <member name="M:NxCreatePhysicsSDK(System.UInt32,NxUserAllocator*,NxUserOutputStream*,NxPhysicsSDKDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxSDKCreateError*)">
\addtogroup PhysXLoader
  @{

\brief Creates an instance of the physics SDK.

Creates an instance of this class. May not be a class member to avoid name mangling.
Pass the constant NX_PHYSICS_SDK_VERSION as the argument.
Because the class is a singleton class, multiple calls return the same object. However, each call must be
matched by a corresponding call to NxReleasePhysicsSDK, as the SDK uses a reference counter to the singleton.

NOTE: Calls after the first will not change the allocator used in the SDK, but they will affect the output stream.

\param sdkVersion Version number we are expecting(should be NX_PHYSICS_SDK_VERSION)
\param allocator User supplied interface for allocating memory(see #NxUserAllocator)
\param outputStream User supplied interface for reporting errors and displaying messages(see #NxUserOutputStream)
\param desc Optional descriptor used to define hardware allocation parameters
\param errorCode Optional error code output parameter

</member>
        <member name="M:NxUtilLib.NxSegmentOBBSqrDist(NxSegment!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*,NxVec3*)">
	\brief Segment-vs-OBB distance computation.

	Returns distance between a segment and an OBB.

	\param[in] segment The segment
	\param[in] c0 OBB center
	\param[in] e0 OBB extents
	\param[in] r0 OBB rotation
	\param[out] t Parameter in [0,1] describing the closest point on the segment.
	\param[out] params Closest point on the box, in box space

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxPointOBBSqrDist(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*)">
	\brief Point-vs-OBB distance computation.

	Returns distance between a point and an OBB.

	\param[in] point The point
	\param[in] center OBB center
	\param[in] extents OBB extents
	\param[in] rot OBB rotation
	\param[out] params Closest point on the box, in box space

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxSweepCapsuleTriangles(System.UInt32,System.UInt32,NxTriangle!System.Runtime.CompilerServices.IsConst*,System.UInt32!System.Runtime.CompilerServices.IsConst*,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,">
	\brief Capsule-vs-triangles sweep test.

	Sweeps a capsule against a set of triangles, returns true if capsule hit any triangle. Also returns contact information.

	\param[in] nb_tris Number of triangles
	\param[in] triangles Array of triangles
	\param[in] edge_flags Array of edge flags (NxTriangleCollisionFlag)
	\param[in] center Center of capsule
	\param[in] radius Capsule radius
	\param[in] height Capsule height
	\param[in] dir Unit-length sweep direction
	\param[in] length Length of sweep (i.e. total motion vectoir is dir*length)
	\param[out] hit Impact point
	\param[out] normal Normal at impact point
	\param[out] d Impact distance
	\param[out] index Triangle index (closest hit triangle)
	\param[in/out] cachedIndex Cached triangle index for subsequent calls. Cached triangle is tested first.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxSweepBoxTriangles(System.UInt32,NxTriangle!System.Runtime.CompilerServices.IsConst*,NxTriangle!System.Runtime.CompilerServices.IsConst*,System.UInt32!System.Runtime.CompilerServices.IsConst*,NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*)">
	\brief Box-vs-triangles sweep test.

	Sweeps a box against a set of triangles, returns true if box hit any triangle. Also returns contact information.

	\param[in] nb_tris Number of triangles
	\param[in] triangles Array of triangles
	\param[in] edge_triangles Array of edge-triangles, whose "vertices" are the edge normals
	\param[in] edge_flags Array of edge flags (NxTriangleCollisionFlag)
	\param[in] box Box (source of the sweep)
	\param[in] dir Unit-length sweep direction
	\param[in] length Length of sweep (i.e. total motion vectoir is dir*length)
	\param[out] hit Impact point
	\param[out] normal Normal at impact point
	\param[out] d Impact distance
	\param[out] index Triangle index (closest hit triangle)
	\param[in/out] cachedIndex Cached triangle index for subsequent calls. Cached triangle is tested first.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxSweepBoxBox(NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Box-vs-box sweep test.

	Sweeps a box against a box, returns true if box hit the other box. Also returns contact information.

	\param[in] box0 Box (source of the sweep)
	\param[in] box1 Box
	\param[in] dir Unit-length sweep direction
	\param[in] length Length of sweep (i.e. total motion vectoir is dir*length)
	\param[out] ip Impact point
	\param[out] normal Normal at impact point
	\param[out] min_dist Impact distance
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxSweepSphereCapsule(NxSphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxCapsule!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sphere-vs-capsule sweep test.

	Sweeps a sphere against a capsule, returns true if sphere hit the capsule. Also returns contact information.

	\param[in] sphere Sphere (source of the sweep)
	\param[in] lss Capsule
	\param[in] dir Unit-length sweep direction
	\param[in] length Length of sweep (i.e. total motion vectoir is dir*length)
	\param[out] min_dist Impact distance
	\param[out] ip Impact point
	\param[out] normal Normal at impact point
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxSweepCapsuleCapsule(NxCapsule!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxCapsule!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Capsule-vs-capsule sweep test.

	Sweeps a capsule against a capsule, returns true if capsule hit the other capsule. Also returns contact information.

	\param[in] lss0 Capsule (source of the sweep)
	\param[in] lss1 Capsule
	\param[in] dir Unit-length sweep direction
	\param[in] length Length of sweep (i.e. total motion vectoir is dir*length)
	\param[out] min_dist Impact distance
	\param[out] ip Impact point
	\param[out] normal Normal at impact point
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxSweepBoxSphere(NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxSphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Box-vs-sphere sweep test.

	Sweeps a box against a sphere, returns true if box hit the sphere. Also returns contact information.

	\param[in] box Box (source of the sweep)
	\param[in] sphere Sphere
	\param[in] dir Unit-length sweep direction
	\param[in] length Length of sweep (i.e. total motion vectoir is dir*length)
	\param[out] min_dist Impact distance
	\param[out] normal Normal at impact point
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxSweepBoxCapsule(NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxCapsule!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Box-vs-capsule sweep test.

	Sweeps a box against a capsule, returns true if box hit the capsule. Also returns contact information.

	\param[in] box Box (source of the sweep)
	\param[in] lss Capsule
	\param[in] dir Unit-length sweep direction
	\param[in] length Length of sweep (i.e. total motion vectoir is dir*length)
	\param[out] min_dist Impact distance
	\param[out] normal Normal at impact point
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxBuildSmoothNormals(System.UInt32,System.UInt32,NxVec3!System.Runtime.CompilerServices.IsConst*,System.UInt32!System.Runtime.CompilerServices.IsConst*,System.UInt16!System.Runtime.CompilerServices.IsConst*,NxVec3*,System.Boolean)">
	\brief Builds smooth vertex normals over a mesh.

	- "smooth" because smoothing groups are not supported here
	- takes angles into account for correct cube normals computation

	To use 32bit indices pass a pointer in dFaces and set wFaces to zero. Alternatively pass a pointer to 
	wFaces and set dFaces to zero.

	\param[in] nbTris Number of triangles
	\param[in] nbVerts Number of vertices
	\param[in] verts Array of vertices
	\param[in] dFaces Array of dword triangle indices, or null
	\param[in] wFaces Array of word triangle indices, or null
	\param[out] normals Array of computed normals (assumes nbVerts vectors)
	\param[in] flip Flips the normals or not

	\return True on success.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxRayTriIntersect(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System">
	\brief Ray-triangle intersection test.
	
	Returns impact distance (t) as well as barycentric coordinates (u,v) of impact point.
	Use NxComputeBarycentricPoint() in Foundation to compute the impact point from the barycentric coordinates.
	The test performs back face culling or not according to 'cull'.

	\param[in] orig Origin of the ray. <b>Range:</b> position vector
	\param[in] dir Direction of the ray. <b>Range:</b> direction vector
	\param[in] vert0 First vertex of triangle. <b>Range:</b> position vector
	\param[in] vert1 Second vertex of triangle. <b>Range:</b> position vector
	\param[in] vert2 Third vertex of triangle. <b>Range:</b> position vector
	\param[out] t Distance along the ray from the origin to the impact point.
	\param[out] u Barycentric coordinate.
	\param[out] v Barycentric coordinate.
	\param[in] cull Cull backfaces.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxSweptSpheresIntersect(NxSphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxSphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sphere-sphere sweep test.
	
	Returns true if spheres intersect during their linear motion along provided velocity vectors.

	\param[in] sphere0 First sphere to test. <b>Range:</b> See #NxSphere
	\param[in] velocity0 Velocity of the first sphere(i.e. the vector to sweep the sphere along). <b>Range:</b> velocity/direction vector
	\param[in] sphere1 Second sphere to test <b>Range:</b> See #NxSphere
	\param[in] velocity1 Velocity of the second sphere(i.e. the vector to sweep the sphere along). <b>Range:</b> velocity/direction vector

	\return True if spheres intersect.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSphere

</member>
        <member name="M:NxUtilLib.NxRayCapsuleIntersect(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxCapsule!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*)">
	\brief Ray-capsule intersection test.
	
	Returns number of intersection points (0,1 or 2) and corresponding parameters along the ray.

	\param[in] origin Origin of ray. <b>Range:</b> position vector
	\param[in] dir Direction of ray. <b>Range:</b> direction vector
	\param[in] capsule Capsule to test. <b>Range:</b> see #NxCapsule
	\param[out] t Parameter of intersection on the ray.

	The actual impact point is given by: 
	impact[i] = origin + t[i] * dir;

	\return Number of intersection points.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxRay NxCapsule

</member>
        <member name="M:NxUtilLib.NxRayOBBIntersect(NxRay!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Boolean ray-OBB intersection test.
	
	Based on separating axis theorem.

	\param[in] ray Ray to test against OBB. <b>Range:</b> See #NxRay
	\param[in] center Center point of OBB. <b>Range:</b> position vector
	\param[in] extents Extent/Radii of the OBB. <b>Range:</b> direction vector
	\param[in] rot Rotation of the OBB(applied before translation). <b>Range:</b> rotation matrix

	\return True on intersection.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxSegmentAABBIntersect(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Boolean segment-AABB intersection test.
	
	Based on separating axis theorem.

	\param[in] p0 First point of line segment. <b>Range:</b> position vector
	\param[in] p1 Second point of line segment. <b>Range:</b> position vector
	\param[in] min Minimum extent of AABB. <b>Range:</b> position vector
	\param[in] max Maximum extent of AABB. <b>Range:</b> position vector

	\return True if the segment and AABB intersect.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxSegmentOBBIntersect(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Boolean segment-OBB intersection test.
	
	Based on separating axis theorem.

	\param[in] p0 First point of line segment. <b>Range:</b> position vector
	\param[in] p1 Second point of line segment. <b>Range:</b> position vector
	\param[in] center Center point of OBB. <b>Range:</b> position vector
	\param[in] extents Extent/Radii of the OBB. <b>Range:</b> direction vector
	\param[in] rot Rotation of the OBB(applied before translation). <b>Range:</b> rotation matrix

	\return true if the segment and OBB intersect.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxRayAABBIntersect2(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Extended Ray-AABB intersection test.
	
	Also computes intersection point, and parameter and returns contacted box axis index+1. Rays starting from inside the box are ignored.
	

	\param[in] min Minimum extent of AABB. <b>Range:</b> position vector
	\param[in] max Maximum extent of AABB. <b>Range:</b> position vector
	\param[in] origin Origin of ray. <b>Range:</b> position vector
	\param[in] dir Direction of ray. <b>Range:</b> direction vector
	\param[out] coord Intersection point.
	\param[out] t Ray parameter corresponding to contact point.

	\return Box axis index.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxRayAABBIntersect(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Ray-AABB intersection test.
	
	Also computes intersection point.

	\param[in] min Minimum extent of AABB. <b>Range:</b> position vector
	\param[in] max Maximum extent of AABB. <b>Range:</b> position vector
	\param[in] origin Origin of ray. <b>Range:</b> position vector
	\param[in] dir Direction of ray. <b>Range:</b> direction vector
	\param[out] coord Intersection point.

	\return True if the ray and AABB intersect.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxSegmentBoxIntersect(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Segment-AABB intersection test.
	
	Also computes intersection point.

	\param[in] p1 First point of line segment. <b>Range:</b> position vector
	\param[in] p2 Second point of line segment. <b>Range:</b> position vector
	\param[in] bbox_min Minimum extent of AABB. <b>Range:</b> position vector
	\param[in] bbox_max Max extent of AABB. <b>Range:</b> position vector
	\param[out] intercept Intersection point between segment and box.

	\return True if the segment and AABB intersect.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxRaySphereIntersect(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Ray-sphere intersection test.
	
	Returns true if the ray intersects the sphere, and the impact point if needed.

	\param[in] origin Origin of the ray. <b>Range:</b> position vector
	\param[in] dir Direction of the ray. <b>Range:</b> direction vector
	\param[in] length Length of the ray. <b>Range:</b> (0,inf)
	\param[in] center Center of the sphere. <b>Range:</b> position vector
	\param[in] radius Sphere radius. <b>Range:</b> (0,inf)
	\param[out] hit_time Distance of intersection between ray and sphere.
	\param[out] hit_pos Point of intersection between ray and sphere.

	\return True on intersection.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxRayPlaneIntersect(NxRay!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxPlane!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Ray-plane intersection test.
	
	Returns distance between ray origin and impact point, as well as impact point on plane.

	\param[in] ray Ray to test against plane. <b>Range:</b> See #NxRay
	\param[in] plane Plane to test. <b>Range:</b> See #NxPlane
	\param[out] dist Distance along ray to impact point (so pointOnPlane=Normalize(v2-v1)*dist).
	\param[out] pointOnPlane Impact point on the plane.

	\return True on intersection.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxSegmentPlaneIntersect(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxPlane!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Segment-plane intersection test.
	
	Returns distance between v1 and impact point, as well as impact point on plane.

	\param[in] v1 First vertex of segment. <b>Range:</b> position vector
	\param[in] v2 Second vertex of segment. <b>Range:</b> position vector
	\param[in] plane Plane to test against. <b>Range:</b> See #NxPlane
	\param[out] dist Distance from v1 to impact point (so pointOnPlane=Normalize(v2-v1)*dist).
	\param[out] pointOnPlane Imapact point on plane.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxSeparatingAxis(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
	\brief Computes the separating axis between two OBBs.

	\param[in] extents0 Extents/radii of first box before transformation. <b>Range:</b> direction vector
	\param[in] center0 Center of box first box. <b>Range:</b> position vector
	\param[in] rotation0 Rotation to apply to first box (before translation). <b>Range:</b> rotation matrix
	\param[in] extents1 Extents/radii of second box before transformation. <b>Range:</b> direction vector
	\param[in] center1 Center of second box. <b>Range:</b> position vector
	\param[in] rotation1 Rotation to apply to second box (before translation). <b>Range:</b> rotation matrix
	\param[in] fullTest If false test only the first 6 axis.

	\return The separating axis or NX_SEP_AXIS_OVERLAP for an overlap.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSepAxis

</member>
        <member name="M:NxUtilLib.NxBoxBoxIntersect(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
	\brief Boolean intersection test between two OBBs.
	
	Uses the separating axis theorem. Disabling 'full_test' only performs 6 axis tests out of 15.

	\param[in] extents0 Extents/radii of first box before transformation. <b>Range:</b> direction vector
	\param[in] center0 Center of first box. <b>Range:</b> position vector
	\param[in] rotation0 Rotation to apply to first box (before translation). <b>Range:</b> rotation matrix
	\param[in] extents1 Extents/radii of second box before transformation <b>Range:</b> direction vector
	\param[in] center1 Center of second box. <b>Range:</b> position vector
	\param[in] rotation1 Rotation to apply to second box(before translation). <b>Range:</b> rotation matrix
	\param[in] fullTest If false test only the first 6 axis.

	\return true on intersection

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxJointDesc_SetGlobalAxis(NxJointDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Set the local axis stored in a #NxJointDesc from a global axis.

	\param dis Joint desc to update.
	\param wsAxis Axis in the global frame. <b>Range:</b> direction vector

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxJointDesc.setGlobalAxis()

</member>
        <member name="M:NxUtilLib.NxJointDesc_SetGlobalAnchor(NxJointDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Set the local anchor stored in a #NxJointDesc from a global anchor point.

	\param dis Joint desc to update.
	\param wsAnchor Anchor point in the global frame. <b>Range:</b> position vector

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxJointDesc.setGlobalAnchor()

</member>
        <member name="M:NxUtilLib.NxComputeSphereInertiaTensor(NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,System.Boolean)">
	\brief Computes diagonalized inertia tensor for a sphere.

	\param[out] diagInertia The diagonalized inertia tensor.
	\param[in] mass The mass. <b>Range:</b> (0,inf)
	\param[in] radius The radius. <b>Range:</b> (-inf,inf)
	\param[in] hollow True to treat the sphere as a hollow shell. 

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxComputeBoxInertiaTensor(NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,System.Single,System.Single)">
	\brief Computes diagonalized inertia tensor for a box.

	\param[out] diagInertia The diagonalized inertia tensor.
	\param[in] mass The mass of the box. <b>Range:</b> (0,inf)
	\param[in] xlength The width of the box. <b>Range:</b> (-inf,inf)
	\param[in] ylength The height. <b>Range:</b> (-inf,inf)
	\param[in] zlength The depth. <b>Range:</b> (-inf,inf)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxComputeConeDensity(System.Single,System.Single,System.Single)">
	\brief Computes density of a homogeneous cone according to cone mass.

	\param[in] radius The radius of the cone. <b>Range:</b> (0,inf)
	\param[in] length The length. <b>Range:</b> (0,inf)
	\param[in] mass The mass. <b>Range:</b> (0,inf)

	\return The density.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxComputeConeMass(System.Single,System.Single,System.Single)">
	\brief Computes mass of a homogeneous cone according to cone density.

	\param[in] radius The radius of the cone. <b>Range:</b> (0,inf)
	\param[in] length The length. <b>Range:</b> (0,inf)
	\param[in] density The density. <b>Range:</b> (0,inf)

	\return The mass.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxComputeCylinderDensity(System.Single,System.Single,System.Single)">
	\brief Computes density of a homogeneous cylinder according to cylinder mass.

	\param[in] radius The radius of the cylinder. <b>Range:</b> (0,inf)
	\param[in] length The length. <b>Range:</b> (0,inf)
	\param[in] mass The mass. <b>Range:</b> (0,inf)

	\return The density.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxComputeCylinderMass(System.Single,System.Single,System.Single)">
	\brief Computes mass of a homogeneous cylinder according to cylinder density.

	\param[in] radius The radius of the cylinder. <b>Range:</b> (0,inf)
	\param[in] length The length. <b>Range:</b> (0,inf)
	\param[in] density The density. <b>Range:</b> (0,inf)

	\return The mass.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxComputeEllipsoidDensity(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
	\brief Computes density of a homogeneous ellipsoid according to ellipsoid mass.

	\param[in] extents The extents/radii of the ellipsoid. <b>Range:</b> direction vector
	\param[in] mass The mass of the ellipsoid. <b>Range:</b> (0,inf)

	\return The density of the ellipsoid.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxComputeEllipsoidMass(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
	\brief Computes mass of a homogeneous ellipsoid according to ellipsoid density.

	\param[in] extents The extents/radii of the ellipsoid. <b>Range:</b> direction vector
	\param[in] density The density of the ellipsoid. <b>Range:</b> (0,inf)

	\return The mass of the ellipsoid.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxComputeBoxDensity(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
	\brief Computes density of a homogeneous box according to box mass.

	\param[in] extents The extents/radii, that is the full side length along each axis, of the box. <b>Range:</b> direction vector
	\param[in] mass The mass of the box. <b>Range:</b> (0,inf)

	\return  The density of the box.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxComputeBoxMass(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
	\brief Computes mass of a homogeneous box according to box density.

	\param[in] extents The extents/radii, that is the full side length along each axis, of the box. <b>Range:</b> direction vector
	\param[in] density The density of the box. <b>Range:</b> (0,inf)

	\return The mass of the box.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxComputeSphereDensity(System.Single,System.Single)">
	\brief Computes density of a homogeneous sphere according to sphere mass.

	\param[in] radius Radius of the sphere. <b>Range:</b> (0,inf)
	\param[in] mass Mass of the sphere. <b>Range:</b> (0,inf)

	\return The density of the sphere.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxComputeSphereMass(System.Single,System.Single)">
	\brief Computes mass of a homogeneous sphere according to sphere density.

	\param[in] radius Radius of the sphere. <b>Range:</b> (0,inf)
	\param[in] density Density of the sphere. <b>Range:</b> (0,inf)

	\return The mass of the sphere.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxCrc32(System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
	\brief Computes CRC of input buffer

	\param buffer Input buffer.
	\param nbBytes Number of bytes in in the input buffer.
	\return The computed CRC.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxComputeBounds(NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,NxVec3!System.Runtime.CompilerServices.IsConst*)">
	\brief Computes bounds of an array of vertices

	\param min Computed minimum of the bounds.
	\param max Maximum
	\param nbVerts Number of input vertices.
	\param verts Array of vertices.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBounds3

</member>
        <member name="M:NxUtilLib.NxFindRotationMatrix(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat33*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief  Computes a rotation matrix.

	computes rotation matrix M so that:

	M * x = b

	x and b are unit vectors.

	\param x Vector.
	\param b Vector.
	\param M Computed rotation matrix.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxDiagonalizeInertiaTensor(NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat33*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Rotates a 3x3 symmetric inertia tensor I into a space R where it can be represented with the diagonal matrix D.

	I = R * D * R'

	Returns false on failure. 

	\param denseInertia The dense inertia tensor.
	\param diagonalInertia The diagonalized inertia tensor.
	\param rotation Rotation for the frame of the diagonalized inertia tensor.

	\return True if the inertia tensor can be diagonalized.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxNormalToTangents(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Get the tangent vectors associated with a normal.

	\param n Normal vector
	\param t1 First tangent
	\param t2 Second tangent
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxMergeSpheres(NxSphere*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxSphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxSphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Compute an overall bounding sphere for a pair of spheres.

	\param merged The computed sphere.
	\param sphere0 First sphere.
	\param sphere1 Second sphere.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSphere NxComputeSphere

</member>
        <member name="M:NxUtilLib.NxFastComputeSphere(NxSphere*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,NxVec3!System.Runtime.CompilerServices.IsConst*)">
	\brief Compute a bounding sphere for a point cloud.

	The sphere may not be as tight as #NxComputeSphere

	\param sphere The computed sphere.
	\param nb_verts Number of points.
	\param verts Array of points.

	\return True on success.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSphere NxComputeSphere

</member>
        <member name="M:NxUtilLib.NxComputeSphere(NxSphere*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,NxVec3!System.Runtime.CompilerServices.IsConst*)">
	\brief Compute a bounding sphere for a point cloud.

	\param sphere The computed sphere.
	\param nb_verts Number of points.
	\param verts Array of points.

	\return The method used to compute the sphere, see #NxBSphereMethod.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSphere NxFastComputeSphere

</member>
        <member name="M:NxUtilLib.NxComputeSquareDistance(NxSegment!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*)">
	\brief Compute the distance squared from a point to a line segment.

	\param seg The line segment.
	\param point The point.
	\param t Used to retrieve the closest parameter value on the line segment.

	\return The squared distance.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSegment

</member>
        <member name="M:NxUtilLib.NxComputeDistanceSquared(NxRay!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*)">
	\brief Compute the distance squared from a point to a ray.

	\param ray The ray.
	\param point The point.
	\param t Used to retrieve the closest parameter value on the ray.

	\return The squared distance.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxRay

</member>
        <member name="M:NxUtilLib.NxIntCeil(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Convert a floating point number to an integer.

	\param f Floating point number.

	\return The result.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxIntFloor(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Convert a floating point number to an integer.

	\param f Floating point number.

	\return The result.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxIntChop(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Convert a floating point number to an integer.

	\param f Floating point number.

	\return The result.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxSetFPUExceptions(System.Boolean)">
	\brief Enable/Disable FPU exception.

	\param b True to enable exception.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxSetFPURoundingNear">
	\brief Set FPU rounding mode.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxSetFPURoundingDown">
	\brief Set FPU rounding mode.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxSetFPURoundingUp">
	\brief Set FPU rounding mode.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxSetFPURoundingChop">
	\brief Set FPU precision.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxSetFPUPrecision64">
	\brief Set FPU precision

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxSetFPUPrecision53">
	\brief Set FPU precision.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxSetFPUPrecision24">
\brief Set FPU precision.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxComputeBoxAroundCapsule(NxCapsule!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxBox*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Compute a box which encloses a capsule.

	\param capsule Capsule to generate an enclosing box for.
	\param box Generated box.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxComputeCapsuleAroundBox

</member>
        <member name="M:NxUtilLib.NxBoxVertexToQuad(System.UInt32)">
	\brief Returns a list of quad indices sharing the vertex index.

	\param vertexIndex Vertex Index.
	\return List of quad indices sharing the vertex index.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxComputeBoxPoints() NxGetBoxQuads()

</member>
        <member name="M:NxUtilLib.NxGetBoxQuads">
	\brief Get a list of indices representing the box as quads.

	\return List of quad indices.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxComputeBoxPoints()

</member>
        <member name="M:NxUtilLib.NxIsBoxAInsideBoxB(NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Test if box A is inside another box B.

	\param a Box A
	\param b Box B

	\return True if box A is inside box B.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBox

</member>
        <member name="M:NxUtilLib.NxComputeCapsuleAroundBox(NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxCapsule*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">

	\brief Compute a capsule which encloses a box.

	\param box Box to generate capsule for.
	\param capsule Stores the capsule which is generated.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBox NxCapsule NxComputeBoxAroundCapsule

</member>
        <member name="M:NxUtilLib.NxComputeBoxWorldEdgeNormal(NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Compute and edge normals for an oriented box.

	This is an averaged normal, from the two faces sharing the edge.

	The edge index should be from 0 to 11 (i.e. a box has 12 edges).

	Edge ordering:

	\image html boxEdgeDiagram.png

	\param[in] box The oriented box.
	\param[in] edge_index The index of the edge to compute a normal for.
	\param[out] world_normal The computed normal.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxGetBoxLocalEdgeNormals">
	\brief Returns a list of local space edge normals.

	\return List of edge normals.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxUtilLib.NxGetBoxTriangles">
	\brief Return a set of triangle indices suitable for use with #NxComputeBoxPoints.

	\return List of box triangles.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxComputeBoxPoints

</member>
        <member name="M:NxUtilLib.NxGetBoxEdgesAxes">
	\brief Return a list of box edge axes.

	\return List of box edge axes.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxComputeBoxPoints

</member>
        <member name="M:NxUtilLib.NxGetBoxEdges">
	\brief Return a list of edge indices.

	\return List of edge indices.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxComputeBoxPoints

</member>
        <member name="M:NxUtilLib.NxComputeBoxVertexNormals(NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*)">

	\brief Compute the vertex normals of an oriented box. These are smooth normals, i.e. averaged from the faces of the box.

	\param[in] box The oriented box.
	\param[out] pts The normals for each vertex(should be large enough to hold 8 normals).

	\return True on success.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBox

</member>
        <member name="M:NxUtilLib.NxComputeBoxPoints(NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*)">

	\brief Compute the corner points of an oriented box.

	\param[in] box The oriented box.
	\param[out] pts Array to receive the box point (should be large enough to hold 8 points)

	\return True on success.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBox

</member>
        <member name="M:NxUtilLib.NxComputeBoxPlanes(NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxPlane*)">

	\brief Computes plane equation for each face of an oriented box.

	\param[in] box The oriented box.
	\param[out] planes Array to receive the computed planes (should be large enough to hold 6 planes)

	\return True on success.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBox NxPlane

</member>
        <member name="M:NxUtilLib.NxCreateBox(NxBox*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat34!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">

	\brief Create an oriented box from an axis aligned box and a transformation.

	\param[out] box Used to store the oriented box.
	\param[in] aabb Axis aligned box.
	\param[in] mat Transformation to apply to the axis aligned box.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBox NxBounds3

</member>
        <member name="M:NxUtilLib.NxBoxContainsPoint(NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Test if an oriented box contains a point.

	\param[in] box Oriented Box to test point against.
	\param[in] p Point to test. 

	\return True if the box contains p.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBox

</member>
        <member name="T:NxUtilLib">
\brief Abstract interface used to expose utility functions

The functions contained within NxUtil were previously exposed as static exports from NxPhysics.dll.
However to allow a switchable PhysXCore, they are now exposed through this interface.

</member>
        <member name="T:NxJointDesc">
@} 
\addtogroup physics
  @{

\addtogroup physics
  @{


@} 
\brief Descriptor class for the #NxJoint class.

Joint descriptors for all the different joint types are derived from this class.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

@see NxJoint NxScene.createJoint()
@see NxCylindricalJointDesc NxD6JointDesc NxDistanceJointDesc NxFixedJointDesc NxPointInPlaneJointDesc
NxPointOnLineJointDesc NxPrismaticJointDesc NxPulleyJointDesc NxRevoluteJointDesc NxSphericalJointDesc

</member>
        <member name="M:NxPointInPlaneJoint.saveToDesc(NxPointInPlaneJointDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Writes all of the object's attributes to the desc struct.

	\param[out] desc The descriptor used to retrieve the state of the object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see loadFromDesc NxPointInPlaneJointDesc

</member>
        <member name="M:NxPointInPlaneJoint.loadFromDesc(NxPointInPlaneJointDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Use this for changing a significant number of joint parameters at once.

	Use the set() methods for changing only a single property at once.

	Please note that you can not change the actor pointers using this function, if you do so the joint will be marked as broken and will stop working.
	
	Calling the loadFromDesc() method on a broken joint will result in an error message.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] desc The descriptor used to set the state of the object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see saveToDesc NxPointInPlaneJointDesc

</member>
        <member name="T:NxPointInPlaneJoint">
 \brief A point in plane joint constrains a point on one body to only move inside
 a plane attached to another body.

 The starting point of the point is defined as the anchor point. The plane
 through this point is specified by its normal which is the joint axis vector.

 \image html pointInPlaneJoint.png

 <h3>Creation</h3>

 \include NxPointInPlaneJoint_Create.cpp

 <h3>Visualizations:</h3>
\li #NX_VISUALIZE_JOINT_LOCAL_AXES
\li #NX_VISUALIZE_JOINT_WORLD_AXES
\li #NX_VISUALIZE_JOINT_LIMITS

 @see NxPointInPlaneJointDesc NxJoint NxScene.createJoint

</member>
        <member name="T:NxPointInPlaneJointDesc">
@} 
\addtogroup physics
  @{


@} 
\brief Desc class for point-in-plane joint. See #NxPointInPlaneJoint.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

@see NxPointInPlaneJoint NxJointDesc NxScene.createJoint

</member>
        <member name="F:NxJointDriveDesc.forceLimit">
		\brief The maximum force (or torque) the drive can exert.

		<b>Default:</b> NX_MAX_REAL
		<b>Range:</b> [0,inf)

</member>
        <member name="F:NxJointDriveDesc.damping">
		\brief damper coefficient

		<b>Default:</b> 0
		<b>Range:</b> [0,inf)

</member>
        <member name="F:NxJointDriveDesc.spring">
		\brief spring coefficient

		<b>Default:</b> 0
		<b>Range:</b> (-inf,inf)

</member>
        <member name="F:NxJointDriveDesc.driveType">
		Type of drive to apply. See #NxD6JointDriveType.

		<b>Default:</b> 0

</member>
        <member name="T:NxJointDriveDesc">
	\brief Class used to describe drive properties for a #NxD6Joint

	<h3>Default Values</h3>

	\li #driveType - 0
	\li #spring - 0
	\li #damping - 0
	\li #forceLimit - FLT_MAX

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Only D6 joint orientation)
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxMotorDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return true if the current settings are valid

</member>
        <member name="M:NxMotorDesc.setToDefault">
\brief Sets members to default values.

</member>
        <member name="M:NxMotorDesc.#ctor(System.Single,System.Single,System.Int32)">
	\brief Constructor, sets members to specified values.

	\param[in] velTarget target velocity of motor. <b>Range:</b> [0,inf]
	\param[in] maxForce maximum motor force/torque. <b>Range:</b> [0,inf)
	\param[in] freeSpin If true, motor will not brake when it spins faster than velTarget.

</member>
        <member name="M:NxMotorDesc.#ctor">
\brief Constructor, sets members to default values.

</member>
        <member name="F:NxMotorDesc.freeSpin">
\brief If true, motor will not brake when it spins faster than velTarget

<b>Default:</b> false

</member>
        <member name="T:NxMotorDesc">
@} 
\addtogroup physics
  @{

\brief Describes a joint motor.

Some joints can be motorized, this allows them to apply a force to cause attached actors to move.

Joints which can be motorized:

<ul><li> #NxPulleyJoint </li><li> #NxRevoluteJoint </li></ul>

#NxJointDriveDesc is used for a similar purpose with #NxD6Joint.

 Example (for a revolute joint):

 \include NxRevoluteJoint_Motor.cpp

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

@see NxPulleyJoint NxRevoluteJoint

</member>
        <member name="M:NxJointLimitPairDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return true if the current settings are valid

</member>
        <member name="M:NxJointLimitPairDesc.setToDefault">
\brief Sets members to default values.

</member>
        <member name="M:NxJointLimitPairDesc.#ctor">
\brief Constructor, sets members to default values.

</member>
        <member name="T:NxJointLimitPairDesc">
@} 
\addtogroup physics
  @{

\brief Describes a pair of joint limits

<h3>Example</h3>

\include NxSpringDesc_NxJointLimitDesc_Example.cpp

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

@see NxRevoluteJoint NxSphericalJoint NxJointLimitDesc

</member>
        <member name="M:NxJointLimitDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return true if the current settings are valid

</member>
        <member name="M:NxJointLimitDesc.setToDefault">
\brief Sets members to default values.

</member>
        <member name="M:NxJointLimitDesc.#ctor">
\brief Constructor, sets members to default values.

</member>
        <member name="T:NxJointLimitDesc">
@} 
\addtogroup physics
  @{

\brief Describes a joint limit.
 
 <h3>Example</h3>

\include NxSpringDesc_NxJointLimitDesc_Example.cpp

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

@see NxRevoluteJoint NxSphericalJoint NxJointLimitPairDesc

</member>
        <member name="M:NxJoint.getScene">
	\brief Retrieves owner scene.

	\return The scene which owns this joint.

	<b>Platform:</b>
	
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxScene

</member>
        <member name="M:NxJoint.getName">
	\brief Retrieves the name string set with setName().

	\return The name string for this object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setName()

</member>
        <member name="M:NxJoint.setName(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
	\brief Sets a name string for the object that can be retrieved with getName().
	
	This is for debugging and is not used by the SDK. The string is not copied by the SDK, only the pointer is stored.
	
	\param[in] name String to set the objects name to.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getName()

</member>
        <member name="M:NxJoint.isPulleyJoint">
	\brief Attempts to perform a cast to a #NxPulleyJoint

	Returns NULL if this object is not of the appropriate type.

	\return NULL if this object is not a #NxPulleyJoint. Otherwise a pointer to this.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see is NxPulleyJoint

</member>
        <member name="M:NxJoint.isDistanceJoint">
	\brief Attempts to perform a cast to a #NxDistanceJoint

	Returns NULL if this object is not of the appropriate type.

	\return NULL if this object is not a #NxDistanceJoint. Otherwise a pointer to this.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see is NxDistanceJoint

</member>
        <member name="M:NxJoint.isFixedJoint">
	\brief Attempts to perform a cast to a #NxFixedJoint

	Returns NULL if this object is not of the appropriate type.

	\return NULL if this object is not a #NxFixedJoint. Otherwise a pointer to this.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see is NxFixedJoint

</member>
        <member name="M:NxJoint.isSphericalJoint">
	\brief Attempts to perform a cast to a #NxSphericalJoint

	Returns NULL if this object is not of the appropriate type.

	\return NULL if this object is not a #NxSphericalJoint. Otherwise a pointer to this.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see is NxSphericalJoint

</member>
        <member name="M:NxJoint.isCylindricalJoint">
	\brief Attempts to perform a cast to a #NxCylindricalJoint

	Returns NULL if this object is not of the appropriate type.

	\return NULL if this object is not a #NxCylindricalJoint. Otherwise a pointer to this.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see is NxCylindricalJoint

</member>
        <member name="M:NxJoint.isPrismaticJoint">
	\brief Attempts to perform a cast to a #NxPrismaticJoint

	Returns NULL if this object is not of the appropriate type.

	\return NULL if this object is not a #NxPrismaticJoint. Otherwise a pointer to this.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see is NxPrismaticJoint

</member>
        <member name="M:NxJoint.isD6Joint">
	\brief Attempts to perform a cast to a #NxD6Joint

	Returns NULL if this object is not of the appropriate type.

	\return NULL if this object is not a #NxD6Joint. Otherwise a pointer to this.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see is NxD6Joint

</member>
        <member name="M:NxJoint.isPointOnLineJoint">
	\brief Attempts to perform a cast to a #NxPointOnLineJoint.

	Returns NULL if this object is not of the appropriate type.

	\return NULL if this object is not a #NxPointOnLineJoint. Otherwise a pointer to this.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see is NxPointOnLineJoint

</member>
        <member name="M:NxJoint.isPointInPlaneJoint">
	\brief Attempts to perform a cast to a #NxPointInPlaneJoint.

	Returns NULL if this object is not of the appropriate type.

	\return NULL if this object is not a #NxPointInPlaneJoint. Otherwise a pointer to this.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see is NxPointInPlaneJoint

</member>
        <member name="M:NxJoint.isRevoluteJoint">
	\brief Attempts to perform a cast to a #NxRevoluteJoint.

	Returns NULL if this object is not of the appropriate type.

	\return NULL if this object is not a #NxRevoluteJoint. Otherwise a pointer to this.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see is NxRevoluteJoint

</member>
        <member name="M:NxJoint.is(NxJointType)">
@name Is... Joint Type

	\brief Type casting operator. The result may be cast to the desired subclass type.

	\param[in] type Used to query for a specific joint type.
	\return NULL if the object if not of type(see #NxJointType). Otherwise a pointer to this object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxJointType

</member>
        <member name="M:NxJoint.getType">
	\brief Retrieve the type of this joint.
	\return The type of joint.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Only D6 joints are supported in hardware)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxJointType

</member>
        <member name="M:NxJoint.getNextLimitPlane(NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*)">
	\brief Returns the next element pointed to by the limit plane iterator, and increments the iterator.

	Places the global frame plane equation (consisting of normal and d, the 4th
	element) coefficients in the argument references. The plane equation is of the form:

	dot(n,p) + d == 0 (n = normal, p = a point on the plane)

	\note This convention for the plane equation differs from the convention used by #NxPlaneShape

	\param[out] planeNormal Used to store the plane normal.
	\param[out] planeD Used to store the plane 'D'.
	\param[out] restitution Optional, used to store restitution of the limit plane.
	\return Returns true if the limit plane is satisfied.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see resetLimitPlaneIterator() hasMoreLimitPlanes()

</member>
        <member name="M:NxJoint.hasMoreLimitPlanes">
	\brief Returns true until the iterator reaches the end of the set of limit planes.
	
	Adding or removing elements does not reset the iterator.

	\return True if the iterator has not reached the end of the sequence of limit planes.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see resetLimitPlaneIterator() getNextLimitPlane()

</member>
        <member name="M:NxJoint.resetLimitPlaneIterator">
	\brief Restarts the limit plane iteration.
	
	Call before starting to iterate. This method may be used together with
	the below two methods to enumerate the limit planes.
	This iterator becomes invalid when planes
	are added or removed, or the plane iterator mechanism is
	invoked on another joint.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see hasMoreLimitPlanes() getNextLimitPlane()

</member>
        <member name="M:NxJoint.purgeLimitPlanes">
	\brief deletes all limit planes added to the joint.
	
	Invalidates limit plane iterator.

	<b>Sleeping:</b> Does <b>NOT</b> wake the associated actor up automatically.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see addLimitPlane() getNextLimitPlane()

</member>
        <member name="M:NxJoint.addLimitPlane(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
	\brief Adds a limit plane.
	
	Both of the parameters are given in global coordinates. see setLimitPoint() for the meaning of limit planes.
	
	The plane is affixed to the	actor that does not have the limit point.

	The normal of the plane points toward the positive side of the plane, and thus toward the
	limit point. If the normal points away from the limit point at the time of this call, the
	method returns false and the limit plane is ignored.

	\note This function always returns true and adds the limit plane unlike earlier versions. This behavior
	was changed to allow the joint to be serialized easily.

	<b>Sleeping:</b> This call wakes the actor(s) if they are sleeping.

	\param[in] normal Normal for the limit plane in global coordinates. <b>Range:</b> direction vector
	\param[in] pointInPlane Point in the limit plane in global coordinates. <b>Range:</b> position vector
	\param[in] restitution Restitution of the limit plane.
	<b>Range:</b> [0.0, 1.0]
	<b>Default:</b> 0.0
	\return Always true.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setLimitPoint() purgeLimitPlanes() getNextLimitPlane()

</member>
        <member name="M:NxJoint.getLimitPoint(NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Retrieves the global space limit point.
	
	Returns true if the point is fixed on actor2.

	\param[out] worldLimitPoint Used to store the global frame limit point. 
	\return True if the point is fixed to actor 2 otherwise the point is fixed to actor 1.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setLimitPoint() addLimitPlane()

</member>
        <member name="M:NxJoint.setLimitPoint(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
@name Limits

	\brief Sets the limit point.
	
	The point is specified in the global coordinate frame.

	All types of joints may be limited with the same system:
	You may elect a point attached to one of the two actors to act as the limit point.
	You may also specify several planes attached to the other actor.

	The points and planes move together with the actor they are attached to.

	The simulation then makes certain that the pair of actors only move relative to each other 
	so that the limit point stays on the positive side of all limit planes.

	the default limit point is (0,0,0) in the local frame of actor2.
	Calling this deletes all existing limit planes.

	<b>Sleeping:</b> This call wakes the actor(s) if they are sleeping.

	\param[in] point The limit reference point defined in the global frame. <b>Range:</b> position vector
	\param[in] pointIsOnActor2 if true the point is attached to the second actor. Otherwise it is attached to the first.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getLimitPoint() addLimitPlane()

</member>
        <member name="M:NxJoint.getUseAccelerationSpring">
	\brief Checks whether acceleration spring is used.

	\return True if acceleration spring is used else false.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : No
	\li PS3  : Yes
	\li XB360: Yes

	@see NxJointDesc.useAccelerationSpring

</member>
        <member name="M:NxJoint.setUseAccelerationSpring(System.Boolean)">
	\brief Switch between acceleration and force based spring.

	\param[in] b {true: use acceleration spring, false: use force spring}.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : No
	\li PS3  : Yes
	\li XB360: Yes

	@see NxJointDesc.useAccelerationSpring

</member>
        <member name="M:NxJoint.getSolverExtrapolationFactor">
	\brief Retrieves the solver extrapolation factor.

	\return The solver extrapolation factor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : No
	\li PS3  : Yes
	\li XB360: Yes

	@see NxJointDesc.solverExtrapolationFactor

</member>
        <member name="M:NxJoint.setSolverExtrapolationFactor(System.Single)">
	\brief Sets the solver extrapolation factor.

	\param[in] solverExtrapolationFactor The solver extrapolation factor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : No
	\li PS3  : Yes
	\li XB360: Yes

	@see NxJointDesc.solverExtrapolationFactor

</member>
        <member name="M:NxJoint.getBreakable(System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Retrieves the max forces of a breakable joint. See #setBreakable().

	\param[out] maxForce Retrieves the maximum force the joint can withstand without breaking.
	\param[out] maxTorque Retrieves the maximum torque the joint can withstand without breaking.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setBreakable NxJointDesc.maxForce NxJointDesc.maxTorque getState()

</member>
        <member name="M:NxJoint.setBreakable(System.Single,System.Single)">
	\brief Sets the maximum force magnitude that the joint is able to withstand without breaking.
	
	If the joint force rises above this threshold, the joint breaks, and becomes disabled. Additionally,
	the jointBreakNotify() method of the scene's user notify callback will be called.
	(You can set this with NxScene::setUserNotify()).

	There are two values, one for linear forces, and one for angular forces. Both values are used directly
	as a value for the maximum impulse tolerated by the joint constraints. 

	Both force values are NX_MAX_REAL by default. This setting makes the joint unbreakable. 
	The values should always be nonnegative.

	The distinction between maxForce and maxTorque is dependent on how the joint is implemented internally, 
	which may not be obvious. For example what appears to be an angular degree of freedom may be constrained 
	indirectly by a linear constraint.

    So in most practical applications the user should set both maxTorque and maxForce to low values.

	<b>Sleeping:</b> This call wakes the actor(s) if they are sleeping.

	\param[in] maxForce Maximum force the joint can withstand without breaking. <b>Range:</b> (0,inf]
	\param[in] maxTorque Maximum torque the joint can withstand without breaking. <b>Range:</b> (0,inf]

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxJointDesc.maxForce NxJointDesc.maxTorque getState() getBreakable()

</member>
        <member name="M:NxJoint.getState">
	\brief Returns the state of the joint.

	Joints are created in the NX_JS_UNBOUND state. Making certain changes to the simulation or the joint 
	can also make joints become unbound.
	Unbound joints are automatically bound the next time Scene::run() is called, and this changes their
	state to NX_JS_SIMULATING. NX_JS_BROKEN means that a breakable joint has broken due to a large force
	or one of its actors has been deleted. In either case the joint was removed from the simulation, 
	so it should be released by the user to free up its memory.

	\return The state of the joint. See #NxJointState.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxJointState setBreakable()

</member>
        <member name="M:NxJoint.getGlobalAxis">
	\brief Retrieves the joint axis.

	\return The joints axis in the global frame.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setGlobalAxis() getGlobalAnchor()

</member>
        <member name="M:NxJoint.getGlobalAnchor">
	\brief Retrieves the joint anchor.

	\return The joints anchor point in the global frame.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setGlobalAnchor() getGlobalAxis()

</member>
        <member name="M:NxJoint.setGlobalAxis(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the direction of the joint's primary axis, specified in global coordinates.

	The direction vector should be normalized to unit length.

	<b>Sleeping:</b> This call wakes the actor(s) if they are sleeping.

	\param[in] vec Direction of primary axis in the global frame. <b>Range:</b> direction vector

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxJointDesc.setGlobalAxis() getGlobalAxis()

</member>
        <member name="M:NxJoint.setGlobalAnchor(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the point where the two actors are attached, specified in global coordinates.

	Set this after setting the actors of the joint.

	<b>Sleeping:</b> This call wakes the actor(s) if they are sleeping.

	\param[in] vec Point the actors are attached at, specified in the global frame. <b>Range:</b> position vector

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxJointDesc.setGlobalAnchor() getGlobalAnchor()

</member>
        <member name="M:NxJoint.getActors(NxActor**,NxActor**)">
	\brief Retrieves the Actors involved.

	\param[out] actor1 First actor associated with joint.
	\param[out] actor2 Second actor associated with joint.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxJointDesc.actors NxActor

</member>
        <member name="T:NxJoint">
 \brief Abstract base class for the different types of joints.

 All joints are used to connect two dynamic actors, or an actor and the environment.

 A NULL actor represents the environment. Whenever the below comments mention two actors,
 one of them may always be the environment (NULL).

<h3>Visualizations:</h3>
\li #NX_VISUALIZE_JOINT_LOCAL_AXES
\li #NX_VISUALIZE_JOINT_WORLD_AXES
\li #NX_VISUALIZE_JOINT_LIMITS

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes (Up to 64k per scene)
\li PS3  : Yes
\li XB360: Yes

 @see NxJointDesc NxScene.createJoint()
 @see NxCylindricalJoint NxD6Joint NxDistanceJoint NxFixedJoint NxPointInPlaneJoint
NxPointOnLineJoint NxPrismaticJoint NxPulleyJoint NxRevoluteJointDesc NxSphericalJoint

</member>
        <member name="M:NxTriangle.inflate(System.Single,System.Boolean)">
		\brief Makes a fat triangle

		\param[in] fatCoeff Amount to inflate triangle by.
		\param[in] constantBorder True - Add same width independent of triangle size. False - Add bigger borders to biggers triangles.

</member>
        <member name="M:NxTriangle.normal(NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
		\brief Compute the normal of the NxTriangle.

		\param[out] _normal Triangle normal.

</member>
        <member name="M:NxTriangle.center(NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
		\brief Compute the center of the NxTriangle.

		\param[out] center Retrieve center (average) point of triangle.

</member>
        <member name="F:NxTriangle.verts">
\brief Array of Vertices.

</member>
        <member name="M:NxTriangle.Dispose">
\brief Destructor

</member>
        <member name="M:NxTriangle.#ctor(NxTriangle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
		\brief Copy constructor

		\param[in] triangle Tri to copy

</member>
        <member name="M:NxTriangle.#ctor(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
		\brief Constructor

		\param[in] p0 Point 0
		\param[in] p1 Point 1
		\param[in] p2 Point 2

</member>
        <member name="M:NxTriangle.#ctor">
\brief Constructor

</member>
        <member name="T:NxTriangle">
\addtogroup physics
  @{

\brief Triangle class.

@see NxTriangleMesh NxTriangleMeshDesc


@} 
\addtogroup physics
  @{


@} 
\addtogroup physics
  @{

</member>
        <member name="M:NxCCDSkeleton.saveToDesc(NxSimpleTriangleMesh*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief writes the CCD skeleton back out as an NxSimpleTriangleMesh.

  \return The number of triangles in the skeleton or zero if failed.

</member>
        <member name="M:NxCCDSkeleton.getReferenceCount">
	\brief Returns the reference count for shared meshes.

	\return the current reference count, not used in any shapes if the count is 0.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxCCDSkeleton.getDataSize">
\brief returns number of bytes a call to ::save() will require.

</member>
        <member name="M:NxCCDSkeleton.save(System.Void*,System.UInt32)">
	\brief saves out CCDSkeleton data.

	can be loaded again with NxPhysicsSDK::createCCDSkeleton(const void * , NxU32);

	returns number of bytes written.

</member>
        <member name="T:NxCCDSkeleton">
\addtogroup physics
  @{

\brief A mesh that is only used for continuous collision detection.

</member>
        <member name="M:NxUserScheduler.waitTasksComplete">
	\brief The SDK thread calls this function to suspend.
	
	When the SDK calls this method the user should block until all the tasks which have previously been submitted
	with addTask() are complete.

	A typical implementation of this method begins executing tasks in the work queue. Then when the queue is complete,
	it blocks until all other threads have finished executing their tasks.

	Note: Tasks submitted by addBackgroundTask() need not be completed before this method returns.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: Yes

	@see NxTask

</member>
        <member name="M:NxUserScheduler.addBackgroundTask(NxTask*)">
	\brief The SDK calls this method to add a background task to the applications work queue

	The timing of background tasks is not as critical as other tasks. The application
	is also not required to execute background tasks when waitTasksComplete() is called.

	\note At present background tasks are not dispatched on any platform(this may change in the future).

	\param[in] task for the application to execute

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: Yes

	@see NxTask

</member>
        <member name="M:NxUserScheduler.addTask(NxTask*)">
	\brief The SDK calls this method to add a task to the applications work queue

	When a task has been added to the work queue the application should execute the task as soon as possible,
	from an arbitary thread context.

	\param[in] task for the application to execute

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: Yes

	@see NxTask

</member>
        <member name="T:NxUserScheduler">
\brief A user defined callback class to allow arbitary scheduling of work between threads.

The user can supply a pointer to a derived class when creating a scene. Subsequently the SDK will
call methods of this class with tasks(#NxTask) which the application should execute on an appropriate thread.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : No
\li XB360: Yes

@see NxSceneDesc.customScheduler NX_SF_ENABLE_MULTITHREAD NxTask

</member>
        <member name="M:NxTask.execute">
    \brief Execute the task supplied by the SDK

	This method can be called from an arbitary thread. Note however that each additional thread
	calling this function will incur a memory overhead for thread specific data.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: Yes

	@see NxScheduler

</member>
        <member name="T:NxTask">
@} 
\brief Interface to an SDK task.

The SDK submits NxTasks to users custom scheduler for execution on an appropriate thread.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : No
\li XB360: Yes

@see NxScheduler NxTask.execute()

</member>
        <member name="M:NxConvexForceFieldShapeDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return True if the current settings are valid

</member>
        <member name="M:NxConvexForceFieldShapeDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxConvexForceFieldShapeDesc.#ctor">
\brief constructor sets to default.

</member>
        <member name="F:NxConvexForceFieldShapeDesc.meshData">
	\brief References the triangle mesh that we want to instance.

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxConvexMesh NxConvexMeshDesc NxPhysicsSDK.createConvexMesh()

</member>
        <member name="M:NxConvexForceFieldShape.saveToDesc(NxConvexForceFieldShapeDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Saves the state of the shape object to a descriptor.

	\param[out] desc Descriptor to save to.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxConvexForceFieldShapeDesc

</member>
        <member name="T:NxConvexForceFieldShape">
 \brief Convex shaped region used to define force field.
 

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

 @see NxForceFieldShape

</member>
        <member name="T:NxConvexForceFieldShapeDesc">
@} 
\addtogroup physics
  @{


@} 
\addtogroup physics
  @{

 \brief A descriptor for NxConvexForceFieldShape
 

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

 @see NxConvexForceFieldShape NxForceFieldShapeDesc

</member>
        <member name="M:NxCapsuleForceFieldShapeDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return True if the current settings are valid

</member>
        <member name="M:NxCapsuleForceFieldShapeDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxCapsuleForceFieldShapeDesc.#ctor">
\brief constructor sets to default.

</member>
        <member name="M:NxCapsuleForceFieldShape.saveToDesc(NxCapsuleForceFieldShapeDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Saves the state of the shape object to a descriptor.

	\param[out] desc Descriptor to save to.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCapsuleForceFieldShapeDesc

</member>
        <member name="M:NxCapsuleForceFieldShape.getHeight">
	\brief Retrieves the height of the capsule.

	\return The height of the capsule measured from end to end.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes
	
	@see setHeight() setRadius() NxCapsuleForceFieldShapeDesc.height

</member>
        <member name="M:NxCapsuleForceFieldShape.setHeight(System.Single)">
	\brief Alters the height of the capsule. 

	\param[in] height The new height of the capsule. <b>Range:</b> (0,inf)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes
	
	@see getHeight() NxCapsuleForceFieldShapeDesc.height getRadius() setDimensions()

</member>
        <member name="M:NxCapsuleForceFieldShape.getRadius">
	\brief Retrieves the radius of the capsule.

	\return The radius of the capsule.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes
	
	@see setRadius() setDimensions() NxCapsuleForceFieldShapeDesc.radius

</member>
        <member name="M:NxCapsuleForceFieldShape.setRadius(System.Single)">
	\brief Alters the radius of the capsule.

	\param[in] radius The new radius of the capsule. <b>Range:</b> (0,inf)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setDimensions() NxCapsuleForceFieldShapeDesc.radius getRadius()

</member>
        <member name="M:NxCapsuleForceFieldShape.setDimensions(System.Single,System.Single)">
	\brief Call this to initialize or alter the capsule. 

	\param[in] radius The new radius of the capsule. <b>Range:</b> (0,inf)
	\param[in] height The new height of the capsule. <b>Range:</b> (0,inf)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setRadius() setHeight()

</member>
        <member name="T:NxCapsuleForceFieldShape">
 \brief A capsule shaped region used to define a force field
 

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

 @see NxForceFieldShape

</member>
        <member name="T:NxCapsuleForceFieldShapeDesc">
@} 
\addtogroup physics
  @{


@} 
\addtogroup physics
  @{

 \brief A descriptor for NxCapsuleForceFieldShape
 

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

 @see NxForceFieldShapeDesc NxCapsuleForceFieldShape NxForceField

</member>
        <member name="M:NxSphereForceFieldShapeDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return True if the current settings are valid

</member>
        <member name="M:NxSphereForceFieldShapeDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxSphereForceFieldShapeDesc.#ctor">
\brief constructor sets to default.

</member>
        <member name="M:NxSphereForceFieldShape.saveToDesc(NxSphereForceFieldShapeDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Saves the state of the shape object to a descriptor.

	\param[out] desc Descriptor to save to.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSphereForceFieldShapeDesc

</member>
        <member name="M:NxSphereForceFieldShape.getRadius">
	\brief Retrieves the radius of the sphere.

	\return The radius of the sphere.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxSphereForceFieldShape.setRadius(System.Single)">
	\brief Sets the sphere radius.

	Call this to initialize or alter the sphere. 

	\param[in] radius The new radius for the sphere. <b>Range:</b> (0,inf)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="T:NxSphereForceFieldShapeDesc">
@} 
\addtogroup physics
  @{


@} 
\addtogroup physics
  @{

 \brief A descriptor for NxSphereForceFieldShape
 

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

 @see NxForceFieldShapeDesc, NxForceFieldShape, NxForceField

</member>
        <member name="M:NxBoxForceFieldShapeDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return True if the current settings are valid

</member>
        <member name="M:NxBoxForceFieldShapeDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxBoxForceFieldShapeDesc.#ctor">
\brief constructor sets to default.

</member>
        <member name="F:NxBoxForceFieldShapeDesc.dimensions">
	\brief Dimensions of the box.
	
	The dimensions are the 'radii' of the box, meaning 1/2 extents in x dimension, 
	1/2 extents in y dimension, 1/2 extents in z dimension. All three must be positive.

	<b>Range:</b> .x (0,inf)
	<b>Range:</b> .y (0,inf)
	<b>Range:</b> .z (0,inf)
	<b>Default:</b> Zero

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBoxForceFieldShape.setDimensions() NxBoxForceFieldShape.getDimensions()

</member>
        <member name="M:NxBoxForceFieldShape.saveToDesc(NxBoxForceFieldShapeDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Saves the state of the shape object to a descriptor.

	\param[out] desc Descriptor to save to.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBoxForceFieldShapeDesc

</member>
        <member name="M:NxBoxForceFieldShape.getDimensions">
	\brief Retrieves the dimensions of the box.

	The dimensions are the 'radii' of the box, meaning 1/2 extents in x dimension, 
	1/2 extents in y dimension, 1/2 extents in z dimension.

	\return The 'radii' of the box.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBoxForceFieldShapeDesc.dimensions setDimensions()

</member>
        <member name="M:NxBoxForceFieldShape.setDimensions(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the box dimensions.

	The dimensions are the 'radii' of the box, meaning 1/2 extents in x dimension, 
	1/2 extents in y dimension, 1/2 extents in z dimension. 

	\param[in] vec The new 'radii' of the box. <b>Range:</b> direction vector

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBoxForceFieldShapeDesc.dimensions getDimensions()

</member>
        <member name="T:NxBoxForceFieldShape">
 \brief Box shaped region used to define force field.
 

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

 @see NxForceFieldShape

</member>
        <member name="T:NxBoxForceFieldShapeDesc">
@} 
\addtogroup physics
  @{


@} 
\addtogroup physics
  @{

 \brief A descriptor for NxBoxForceFieldShape
 

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

 @see NxBoxForceFieldShape NxForceFieldShapeDesc NxBoxForceField

</member>
        <member name="M:NxForceFieldShape.isConvex">
	\brief Attempts to perform a downcast to the type returned.
	
	Returns 0 if this object is not of the appropriate type.

	\return If this is a NxConvexForceFieldShape a pointer otherwise NULL.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see NxConvexForceFieldShape


	\brief Attempts to perform a downcast to the type returned.
	
	Returns 0 if this object is not of the appropriate type.

	\return If this is a NxConvexForceFieldShape a pointer otherwise NULL.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see NxConvexForceFieldShape

</member>
        <member name="M:NxForceFieldShape.isCapsule">
	\brief Attempts to perform a downcast to the type returned.
	
	Returns 0 if this object is not of the appropriate type.

	\return If this is a NxCapsuleForceFieldShape a pointer otherwise NULL.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCapsuleForceFieldShape


	\brief Attempts to perform a downcast to the type returned.
	
	Returns 0 if this object is not of the appropriate type.

	\return If this is a NxCapsuleForceFieldShape a pointer otherwise NULL.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCapsuleForceFieldShape

</member>
        <member name="M:NxForceFieldShape.isBox">
	\brief Attempts to perform a downcast to the type returned.
	
	Returns 0 if this object is not of the appropriate type.

	\return If this is a NxBoxForceFieldShape a pointer otherwise NULL.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBoxForceFieldShape()


	\brief Attempts to perform a downcast to the type returned.
	
	Returns 0 if this object is not of the appropriate type.

	\return If this is a NxBoxForceFieldShape a pointer otherwise NULL.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBoxForceFieldShape

</member>
        <member name="M:NxForceFieldShape.isSphere">
	\brief Attempts to perform a downcast to the type returned.
	
	Returns 0 if this object is not of the appropriate type.

	\return If this is a NxSphereForceFieldShape a pointer otherwise NULL.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSphereForceFieldShape


	\brief Attempts to perform a downcast to the type returned.
	
	Returns 0 if this object is not of the appropriate type.

	\return If this is a NxSphereForceFieldShape a pointer otherwise NULL.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSphereForceFieldShape()

</member>
        <member name="M:NxForceFieldShape.is(NxShapeType)">
	\brief Type casting operator. The result may be cast to the desired subclass type.

	\param[in] type Used to query for a specific effector type.
	\return NULL if the object if not of type(see #NxShapeType). Otherwise a pointer to this object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShapeType


	\brief Type casting operator. The result may be cast to the desired subclass type.

	\param[in] type Used to query for a specific effector type.
	\return NULL if the object if not of type(see #NxShapeType). Otherwise a pointer to this object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShapeType

</member>
        <member name="M:NxForceFieldShape.getType">
	\brief Retrieve the type of this force field shape.
	\return The type of force field shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback] 
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShapeType

</member>
        <member name="M:NxForceFieldShape.getName">
	\brief Retrieves the name string set with setName().

	\return The name string for this object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see setName()

</member>
        <member name="M:NxForceFieldShape.setName(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
	\brief Sets a name string for the object that can be retrieved with getName().
	
	This is for debugging and is not used by the SDK. The string is not copied by the SDK, only the pointer is stored.
	
	\param[in] name String to set the objects name to.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see getName()

</member>
        <member name="M:NxForceFieldShape.getShapeGroup">
	\brief Returns the owning force field shape group.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback] 
	\li PS3  : Yes
	\li XB360: Yes

	@see NxForceField

</member>
        <member name="M:NxForceFieldShape.getForceField">
	\brief Returns the owning force field if this is a shape of an include group, else NULL will be returned

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback] 
	\li PS3  : Yes
	\li XB360: Yes

	@see NxForceField

</member>
        <member name="M:NxForceFieldShape.setPose(NxMat34!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the force field shape's transform.  
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see getPose() getFlags() NxForceFieldShapeDesc::pose

</member>
        <member name="M:NxForceFieldShape.getPose">
	\brief Retrieves the force field shape's transform.  
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see setPose() getFlags() NxForceFieldShapeDesc::pose

</member>
        <member name="T:NxForceFieldShape">
 \brief A shape that represents a volume in which the force field acts on objects.
 

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes [SW fallback]
\li PS3  : Yes
\li XB360: Yes

 @see NxForceFieldShapeDesc, NxForceField

</member>
        <member name="T:NxSphereForceFieldShape">
@} 
\addtogroup physics
  @{


 \brief A spherical force field shape
 

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

 @see NxForceFieldShape

</member>
        <member name="M:NxForceFieldLinearKernel.getName">
	\brief Retrieves the name string set with setName().

	\return The name string for this object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see setName()

</member>
        <member name="M:NxForceFieldLinearKernel.setName(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
	\brief Sets a name string for the object that can be retrieved with getName().
	
	This is for debugging and is not used by the SDK. The string is not copied by the SDK, only the pointer is stored.
	
	\param[in] name String to set the objects name to.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see getName()

</member>
        <member name="M:NxForceFieldLinearKernel.saveToDesc(NxForceFieldLinearKernelDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Writes all of the kernel's attributes to the description, as well
	as setting the actor connection point.

	\param[out] desc The descriptor used to retrieve the state of the kernel.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxForceFieldLinearKernel.getScene">
	\brief Retrieves the scene which this kernel belongs to.

	\return Owner Scene.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see NxScene

</member>
        <member name="M:NxForceFieldLinearKernel.setTorusRadius(System.Single)">
	\brief ets the toroidal radius.
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes


</member>
        <member name="M:NxForceFieldLinearKernel.getTorusRadius">
	\brief ets the toroidal radius.
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes


</member>
        <member name="M:NxForceFieldLinearKernel.setNoise(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the force field noise.
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes


</member>
        <member name="M:NxForceFieldLinearKernel.getNoise">
	\brief Gets the force field noise.
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes


</member>
        <member name="M:NxForceFieldLinearKernel.setFalloffQuadratic(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the quadratic falloff term.
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes


</member>
        <member name="M:NxForceFieldLinearKernel.getFalloffQuadratic">
	\brief Sets the quadratic falloff term.
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes


</member>
        <member name="M:NxForceFieldLinearKernel.setFalloffLinear(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the linear falloff term.
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes


</member>
        <member name="M:NxForceFieldLinearKernel.getFalloffLinear">
	\brief Sets the linear falloff term.
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes


</member>
        <member name="M:NxForceFieldLinearKernel.setVelocityTarget(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the force field velocity target.
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes


</member>
        <member name="M:NxForceFieldLinearKernel.getVelocityTarget">
	\brief Gets the force field velocity target.
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes


</member>
        <member name="M:NxForceFieldLinearKernel.setPositionTarget(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief  Sets the force field position target.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes


</member>
        <member name="M:NxForceFieldLinearKernel.getPositionTarget">
	\brief Gets the force field position target.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes


</member>
        <member name="M:NxForceFieldLinearKernel.setVelocityMultiplier(NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the coefficient of force field function velocity term.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes


</member>
        <member name="M:NxForceFieldLinearKernel.getVelocityMultiplier">
	\brief Gets the coefficient of force field function velocity term.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes


</member>
        <member name="M:NxForceFieldLinearKernel.setPositionMultiplier(NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the coefficient of force field function position term.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes


</member>
        <member name="M:NxForceFieldLinearKernel.getPositionMultiplier">
	\brief Gets the coefficient of force field function position term.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes


</member>
        <member name="M:NxForceFieldLinearKernel.setConstant(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the constant part of force field function.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes


</member>
        <member name="M:NxForceFieldLinearKernel.getConstant">
	\brief Gets the constant part of force field function.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes


</member>
        <member name="T:NxForceFieldLinearKernel">
@} 
</member>
        <member name="M:NxForceFieldLinearKernelDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return true if the current settings are valid

</member>
        <member name="M:NxForceFieldLinearKernelDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxForceFieldLinearKernelDesc.#ctor">
\brief Constructor sets to default.

</member>
        <member name="F:NxForceFieldLinearKernelDesc.userData">
	\brief Will be copied to NxForceField::userData

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see NxForceField.userData

</member>
        <member name="F:NxForceFieldLinearKernelDesc.name">
	\brief Possible debug name. The string is not copied by the SDK, only the pointer is stored.

	<b>Default</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxForceFieldLinearKernelDesc.noise">
	\brief Noise scaling

	<b>Default</b> zero

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxForceFieldLinearKernelDesc.falloffQuadratic">
	\brief Quadratic term in magnitude falloff factor. Range (each component): [0, inf)

	<b>Default</b> zero

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxForceFieldLinearKernelDesc.falloffLinear">
	\brief Linear term in magnitude falloff factor. Range (each component): [0, inf)

	<b>Default</b> zero

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxForceFieldLinearKernelDesc.torusRadius">
	\brief Radius for NX_FFC_TOROIDAL type coordinates.

	<b>Default</b> zero

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxForceFieldLinearKernelDesc.velocityTarget">
	\brief  Force field velocity target

	<b>Default</b> zero

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxForceFieldLinearKernelDesc.velocityMultiplier">
	\brief Coefficient of force field function velocity term

	<b>Default</b> zero

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxForceFieldLinearKernelDesc.positionTarget">
	\brief Force field position target.

	<b>Default</b> zero

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxForceFieldLinearKernelDesc.positionMultiplier">
	\brief Coefficient of force field function position term

	<b>Default</b> zero

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxForceFieldLinearKernelDesc.constant">
	\brief Constant part of force field function

	<b>Default</b> zero

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="T:NxForceFieldLinearKernelDesc">
@} 
\addtogroup physics
  @{

\addtogroup physics
  @{

 \brief Descriptor class for  NxForceFieldLinearKernel class.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes [SW fallback]
\li PS3  : Yes
\li XB360: Yes

 @see  NxForceFieldLinearKernel

</member>
        <member name="T:NxForcFieldKernelType">
@} 
\addtogroup physics
  @{

</member>
        <member name="M:NxForceFieldShapeGroupDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return true if the current settings are valid

</member>
        <member name="M:NxForceFieldShapeGroupDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxForceFieldShapeGroupDesc.#ctor">
\brief Constructor sets to default.

</member>
        <member name="F:NxForceFieldShapeGroupDesc.userData">
	\brief Will be copied to NxForceFieldShapeGroupDesc::userData

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxForceFieldShapeGroupDesc.userData

</member>
        <member name="F:NxForceFieldShapeGroupDesc.name">
	\brief Possible debug name. The string is not copied by the SDK, only the pointer is stored.

	<b>Default</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxForceFieldShapeGroupDesc.shapes">
	\brief A list of force field shape descriptors which will be added to the group.

	<b>Default</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxForceFieldShapeGroupDesc.flags">
	\brief Flags of the force field shape group.

	<b>Default</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes
	
	@see NxForceFieldShapeGroupFlags

</member>
        <member name="T:NxForceFieldShapeGroupDesc">
 \brief Descriptor class for NxForceFieldShapeGroup class.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes [SW fallback]
\li PS3  : Yes
\li XB360: Yes

 @see NxForceFieldShapeGroup

</member>
        <member name="T:NxForceFieldShapeGroupFlags">
@} 
\addtogroup physics
  @{

</member>
        <member name="M:NxForceFieldShapeGroup.getName">
	\brief Retrieves the name string set with setName().

	\return The name string for this object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see setName()

</member>
        <member name="M:NxForceFieldShapeGroup.setName(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
	\brief Sets a name string for the object that can be retrieved with getName().
	
	This is for debugging and is not used by the SDK. The string is not copied by the SDK, only the pointer is stored.
	
	\param[in] name String to set the objects name to.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see getName()

</member>
        <member name="M:NxForceFieldShapeGroup.getScene">
	\brief Retrieves the scene which this force field group belongs to.

	\return Owner Scene.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see NxScene

</member>
        <member name="M:NxForceFieldShapeGroup.saveToDesc(NxForceFieldShapeGroupDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Writes all of the shape groups's attributes to the description

	\param[out] desc The descriptor used to retrieve the state of the shape group.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxForceFieldShapeGroup.getFlags">
	\brief Returns the force field shape group flags. @see NxForceFieldShapeGroupFlags

	\return NxForceFieldShapeGroupFlags See #NxForceFieldShapeGroupFlags

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes


</member>
        <member name="M:NxForceFieldShapeGroup.getForceField">
	\brief If this is an include group, getForceField() will return the force field of this group, else NULL will be returned.

	\return NxForceField See #NxForceField

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes


</member>
        <member name="M:NxForceFieldShapeGroup.getNextShape">
	\brief Retrieves the next shape when iterating.

	\return NxForceFieldShape See #NxForceFieldShape

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes


</member>
        <member name="M:NxForceFieldShapeGroup.resetShapesIterator">
	\brief Restarts the shape iterator so that the next call to getNextShape() returns the first shape in the force field group.  

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes


</member>
        <member name="M:NxForceFieldShapeGroup.getNbShapes">
	\brief Returns the number of shapes in the force field group.

	\return The number of shapes in this group.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see createShape() NxForceFieldShapeDesc

</member>
        <member name="M:NxForceFieldShapeGroup.releaseShape(NxForceFieldShape!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Releases the passed force field shape. 

	The passed force field shape must previously have been created with this force field's createShape() call.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see createShape() NxForceFieldShapeDesc

</member>
        <member name="M:NxForceFieldShapeGroup.createShape(NxForceFieldShapeDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Creates a NxForceFieldShape and adds it to the group. 
	
	The volume of activity of the force field is defined by the union of all of the force field's shapes' volumes created
	here without the NX_FFS_EXCLUDE flag set, minus the union of all of the force field's shapes with the NX_FFS_EXCLUDE flag set.

	The shapes are owned by the force field and released if the force field is released.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see releaseShape() NxForceFieldShapeDesc

</member>
        <member name="M:NxForceField.setForceFieldVariety(System.UInt16)">
	\brief Sets the force field variety index, default index is 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxForceField.getForceFieldVariety">
	\brief Retrieves the force field variety index, default index is 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxForceField.getScene">
	\brief Retrieves the scene which this force field belongs to.

	\return Owner Scene.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see NxScene

</member>
        <member name="M:NxForceField.setFlags(System.UInt32)">
	\brief Sets the force field flags @see NxForceFieldFlags

	\param[in] f NxForceFieldFlags The force field flags

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxForceField.getFlags">
	\brief Gets the force field flags @see NxForceFieldFlags

	\return NxForceFieldFlags The force field flags

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxForceField.setRigidBodyType(NxForceFieldType)">
	\brief Sets the force field scaling type for rigid bodies

	\param[in] t NxForceFieldType The force field scaling type for fluids. See #NxForceFieldType

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxForceField.getRigidBodyType">
	\brief Gets the force field scaling type for rigid bodies

	\return NxForceFieldType The force field scaling type for fluids. See #NxForceFieldType

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxForceField.setSoftBodyType(NxForceFieldType)">
	\brief Sets the force field scaling type for soft bodies

	\param[in] t NxForceFieldType The force field scaling type for fluids. See #NxForceFieldType

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxForceField.getSoftBodyType">
	\brief Gets the force field scaling type for soft bodies

	\return NxForceFieldType The force field scaling type for fluids. See #NxForceFieldType

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxForceField.setClothType(NxForceFieldType)">
	\brief Sets the force field scaling type for cloths

	\param[in] t NxForceFieldType The force field scaling type for fluids. See #NxForceFieldType

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxForceField.getClothType">
	\brief Gets the force field scaling type for cloths

	\return NxForceFieldType The force field scaling type for fluids. See #NxForceFieldType

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxForceField.setFluidType(NxForceFieldType)">
	\brief Sets the force field scaling type for fluids

	\param[in] t NxForceFieldType The force field scaling type for fluids. See #NxForceFieldType

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxForceField.getFluidType">
	\brief Gets the force field scaling type for fluids

	\return NxForceFieldType The force field scaling type for fluids. See #NxForceFieldType

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxForceField.getName">
	\brief Retrieves the name string set with setName().

	\return The name string for this object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see setName()

</member>
        <member name="M:NxForceField.setName(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
	\brief Sets a name string for the object that can be retrieved with getName().
	
	This is for debugging and is not used by the SDK. The string is not copied by the SDK, only the pointer is stored.
	
	\param[in] name String to set the objects name to.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see getName()

</member>
        <member name="M:NxForceField.setCoordinates(NxForceFieldCoordinates)">
	\brief Sets the Coordinate space of the field. Transforms position and velocity of objects into this space prior to kernel evaluation.

	\param[in] coordinates The coordinate system. See #NxForceFieldCoordinates

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxForceField.getCoordinates">
	\brief Gets the Coordinate space of the field.

	\return NxForceFieldCoordinates See #NxForceFieldCoordinates

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxForceField.setGroupsMask(NxGroupsMask)">
	\brief Sets 128-bit mask used for collision filtering. See comments for ::NxGroupsMask

	\param[in] mask The group mask to set for the shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see getGroupsMask()

</member>
        <member name="M:NxForceField.getGroupsMask">
	\brief Gets 128-bit mask used for collision filtering. See comments for ::NxGroupsMask

	\return The group mask for the shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see setGroupsMask()

</member>
        <member name="M:NxForceField.setGroup(System.UInt16)">
	\brief Sets which collision group this shape is part of.
	
	Default group is 0. Maximum possible group is 31.
	Collision groups are sets of shapes which may or may not be set
	to collision detect with each other; this can be set using NxScene::setGroupCollisionFlag()

	\param[in] collisionGroup The collision group for this shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see getGroup() NxCollisionGroup

</member>
        <member name="M:NxForceField.getGroup">
	\brief Retrieves the value set with #setGroup().

	NxCollisionGroup is an integer between 0 and 31.

	\return The collision group this shape belongs to.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see setGroup() NxCollisionGroup

</member>
        <member name="M:NxForceField.getNextShapeGroup">
	\brief Retrieves the next FF shape group when iterating.

	\return NxForceFieldShapeGroup See #NxForceFieldShapeGroup

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxForceField.resetShapeGroupsIterator">
	\brief Restarts the force field shape groups iterator so that the next call to getNextShape() returns the first shape in the force field.  

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxForceField.getNbShapeGroups">
	\brief Returns the number of force field shape groups of this force field. (not counting the include group)

	\return The Number of force field shape groups. See #NxForceFieldShapeGroup

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxForceField.removeShapeGroup(NxForceFieldShapeGroup*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Removes a force field shape group from this force field.

	\param[in] group A force field shape group. See #NxForceFieldShapeGroup

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxForceField.addShapeGroup(NxForceFieldShapeGroup*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Adds a force field shape group to this force field to define its volume of activity.

	\param[in] group A force field shape group. See #NxForceFieldShapeGroup

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxForceField.getIncludeShapeGroup">
	\brief Retrieves the include shape group of this forcefield. Shapes in this group will move with the force field.

	\return NxForceFieldShapeGroup The includeGroup of this force field.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxForceField.getForceFieldKernel">
	\brief Retrieves the kernel function which this field is using  

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxForceField.setForceFieldKernel(NxForceFieldKernel*)">
	\brief Sets the kernel function which this field will be using  

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxForceField.setActor(NxActor*)">
	\brief Sets the actor pointer that this force field is attached to.  
	
	Pass NULL for unattached force fields.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see getActor() NxForceFieldDesc::actor

</member>
        <member name="M:NxForceField.getActor">
	\brief Retrieves the actor pointer that this force field is attached to.  
	
	Unattached force fields return NULL.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see setActor() NxForceFieldDesc::actor

</member>
        <member name="M:NxForceField.setPose(NxMat34!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the force field's transform.  
	
	This transform is either from world space or from actor space, depending on whether the actor pointer is set.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see getPose() getActor() NxForceFieldDesc::pose

</member>
        <member name="M:NxForceField.getPose">
	\brief Retrieves the force field's transform.  
	
	This transform is either from world space or from actor space, depending on whether the actor pointer is set.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see setPose() getActor() NxForceFieldDesc::pose

</member>
        <member name="M:NxForceField.saveToDesc(NxForceFieldDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Writes all of the effector's attributes to the description, as well
	as setting the actor connection point.

	\param[out] desc The descriptor used to retrieve the state of the effector.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="T:NxForceField">
 \brief A force field effector.

 Instances of this object automate the application of forces onto rigid bodies, fluid, soft bodies and cloth.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes [SW fallback]
\li PS3  : Yes
\li XB360: Yes

 @see NxForceFieldDesc, NxScene::createForceField()

</member>
        <member name="M:NxForceFieldDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return true if the current settings are valid

</member>
        <member name="M:NxForceFieldDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxForceFieldDesc.#ctor">
\brief Constructor sets to default.

</member>
        <member name="F:NxForceFieldDesc.userData">
	\brief Will be copied to NxForceField::userData

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see NxForceField.userData

</member>
        <member name="F:NxForceFieldDesc.name">
	\brief Possible debug name. The string is not copied by the SDK, only the pointer is stored.

	<b>Default</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxForceFieldDesc.flags">
	\brief Force field flags; @see NxForceFieldFlags

	<b>Default:</b> NX_FFF_VOLUMETRIC_SCALING_FLUID | NX_FFF_VOLUMETRIC_SCALING_CLOTH | NX_FFF_VOLUMETRIC_SCALING_SOFTBODY | NX_FFF_VOLUMETRIC_SCALING_RIGIDBODY

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxForceFieldDesc.rigidBodyType">
	\brief Force field type for rigid bodies

	<b>Default:</b> NX_FF_TYPE_OTHER

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxForceFieldDesc.softBodyType">
	\brief Force field type for soft bodies

	<b>Default:</b> NX_FF_TYPE_OTHER

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxForceFieldDesc.clothType">
	\brief Force field type for cloth

	<b>Default:</b> NX_FF_TYPE_OTHER

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxForceFieldDesc.fluidType">
	\brief Force field type for fluids

	<b>Default:</b> NX_FF_TYPE_OTHER

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxForceFieldDesc.forceFieldVariety">
	\brief Force Field Variety Index, index != 0 has to be created.

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxForceFieldDesc.kernel">
	\brief kernel function of the force field.

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxForceFieldDesc.groupsMask">
	\brief Groups mask used for collision filtering.

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxForceFieldDesc.group">
	\brief Collision group used for collision filtering.

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxForceFieldDesc.shapeGroups">
	\brief a collection of NxForceFieldShapeGroup objects. @see NxForceFieldShapeGroup

	<b>Default:</b> empty

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxForceFieldDesc.includeGroupShapes">
	\brief Array of force field shapes descriptors which will be created inside the include group of this force field. This group moves with the force field and cannot be shared.

	<b>Default:</b> empty

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxForceFieldDesc.coordinates">
	\brief Coordinate space of the field.

	<b>Default:</b> NX_FFC_CARTESIAN

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxForceFieldDesc.actor">
	\brief The field's pose is relative to the actor's pose and relative to the world frame if field is null.

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxForceFieldDesc.pose">
	\brief Global or (if actor is set) actor relative transformation of the force field. 
	Detaching from the actor will cause the force field's pose to be relative to the world frame.

	<b>Default:</b> Identity

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="T:NxForceFieldDesc">
 \brief Descriptor class for NxForceField class.


<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes [SW fallback]
\li PS3  : Yes
\li XB360: Yes

 @see NxForceField

</member>
        <member name="T:NxForceFieldCoordinates">
\brief Type of force field coordinate space

</member>
        <member name="M:NxForceFieldShapeDesc.#ctor(NxShapeType)">
	\brief Constructor sets to default.

	\param type shape type

</member>
        <member name="M:NxForceFieldShapeDesc.getType">
	\brief Retrieves the shape type.

	\return The type of shape this descriptor describes. 

	@see NxShapeType

</member>
        <member name="M:NxForceFieldShapeDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return true if the current settings are valid

</member>
        <member name="M:NxForceFieldShapeDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxForceFieldShapeDesc.Dispose">
\brief Constructor sets to default.

</member>
        <member name="F:NxForceFieldShapeDesc.name">
	\brief Possible debug name. The string is not copied by the SDK, only the pointer is stored.

	<b>Default</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxForceFieldShapeDesc.userData">
	\brief Will be copied to NxForceFieldShape::userData.

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxForceFieldShapeDesc.pose">
	\brief shape's pose

	<b>Default:</b> Identity

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxForceFieldShapeDesc.type">
\brief The type of shape. This is set by the c'tor of the derived class.

</member>
        <member name="T:NxForceFieldShapeDesc">
@} 
\addtogroup physics
  @{

\addtogroup physics
  @{

\addtogroup physics
  @{

 \brief Descriptor class for NxForceFieldShape
 

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes [SW fallback]
\li PS3  : Yes
\li XB360: Yes

 @see NxForceFieldShape, NxForceField

</member>
        <member name="F:NxSpringAndDamperEffectorDesc.body2">
	\brief Second attached body.

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSpringAndDamperEffector.setBodies()

</member>
        <member name="F:NxSpringAndDamperEffectorDesc.body1">
	\brief First attached body.

	<b>Default:</b>	NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSpringAndDamperEffector.setBodies()

</member>
        <member name="M:NxSpringAndDamperEffectorDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return true if the current settings are valid

</member>
        <member name="M:NxSpringAndDamperEffectorDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxSpringAndDamperEffectorDesc.#ctor">
\brief Constructor sets to default.

</member>
        <member name="T:NxSpringAndDamperEffectorDesc">
\brief Desc class for NxSpringAndDamperEffector. 

<h3>Example</h3>

\include NxSpringAndDamperEffector_Create.cpp

@see NxSpringAndDamperEffector

</member>
        <member name="M:NxSpringAndDamperEffector.getLinearDamper(System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Retrieves the damper properties.

	Retrieves the damper properties. See #setLinearDamper.

	\param[out] velCompressSaturate is the negative (compression direction) velocity where the damping force magnitude no longer increases, but stays constant. 
	\param[out] velStretchSaturate  is the positive (stretch direction) velocity where the the damping force magnitude no longer increases, but stays constant. 

	\param[out] maxCompressForce is the force applied when velCompressSaturate is reached. The force ramps up linearly until this value, starting at zero at vrel == 0. 
	\param[out] maxStretchForce  is the force applied when velStretchSaturate  is reached. The force ramps up linearly until this value, starting at zero at vrel == 0.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxSpringAndDamperEffector.getLinearSpring(System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Retrieves the spring properties. See #setLinearSpring.

	\param[out] distCompressSaturate is the distance at which the repulsive spring force magnitude no longer increases, but stays constant.
	\param[out] distRelaxed is the distance at which the spring is relaxed, and there is no spring force applied.
	\param[out] distStretchSaturate is the distance at which the attractive spring force magnitude no longer increases, but stays constant.
	
	\param[out] maxCompressForce is the force applied when distCompressSaturate is reached. The force ramps up linearly until this value, starting at zero at distRelaxed.
	\param[out] maxStretchForce  is the force applied when distStretchSaturate  is reached. The force ramps up linearly until this value, starting at zero at distRelaxed.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxSpringAndDamperEffector.setBodies(NxActor*,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxActor*,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the two bodies which are connected by the element.

	You may set one of the bodies to NULL to signify that the effect is between a body and the static 
	environment.

	Setting both of the bodies to NULL is invalid.

	Each body parameter is followed by a point defined in the global coordinate frame, which will
	move with the respective body. This is the point where the respective end of the spring and damper
	element is attached to the body.

	<b>Sleeping:</b> Does <b>NOT</b> wake the associated actor up automatically.

	\param[in] body1 First Body.
	\param[in] global1 Attachment point for spring in the global frame. <b>Range:</b> position vector
	\param[in] body2 Second Body
	\param[in] global2 Attachment point for spring in the global frame. <b>Range:</b> position vector

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxSpringAndDamperEffector.saveToDesc(NxSpringAndDamperEffectorDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Writes all of the effector's spring attributes to the description, as well
	as setting the 2 actor connection points.

	\param[out] desc The descriptor used to retrieve the state of the effector.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="T:NxSpringAndDamperEffector">
\brief  Represents a spring and damper element, which exerts a force between two bodies,
 proportional to the relative positions and the relative velocities of the bodies.

\note The spring and damper element is deprecated and the distance joint should be used in its place, for the following reasons:

\li Spring and Damper elements are not as numerically stable as genuine joints.
\li Joints have proper sleep behavior, bodies fall asleep and wake up at appropriate times with regard to forces being transfered across the joints spring. 


 <h3>Creation</h3>

 Example:

 \include NxSpringAndDamperEffector_Create.cpp

 @see NxScene.createSpringAndDamperEffector() NxScene.releaseEffector()

</member>
        <member name="M:NxEffector.getScene">
	\brief Retrieves the owner scene

	\return The scene which this effector belongs to.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxScene

</member>
        <member name="M:NxEffector.getName">
	\brief Retrieves the name string set with setName().

	\return The name string for this object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setName()

</member>
        <member name="M:NxEffector.setName(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
	\brief Sets a name string for the object that can be retrieved with getName().
	
	This is for debugging and is not used by the SDK. The string is not copied by the SDK, only the pointer is stored.
	
	\param[in] name String to set the objects name to.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getName()

</member>
        <member name="M:NxEffector.isSpringAndDamperEffector">
	\brief Attempts to perform a downcast to the type returned.
	
	Returns 0 if this object is not of the appropriate type.

	\return If this is a spring and damper effector a pointer otherwise NULL.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSpringAndDamperEffector


	\brief Attempts to perform a downcast to the type returned.
	
	Returns 0 if this object is not of the appropriate type.

	\return If this is a spring and damper effector a pointer otherwise NULL.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSpringAndDamperEffector

</member>
        <member name="M:NxEffector.is(NxEffectorType)">
	\brief Type casting operator. The result may be cast to the desired subclass type.

	\param[in] type Used to query for a specific effector type.
	\return NULL if the object if not of type(see #NxEffectorType). Otherwise a pointer to this object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxEffectorType


	\brief Type casting operator. The result may be cast to the desired subclass type.

	\param[in] type Used to query for a specific effector type.
	\return NULL if the object if not of type(see #NxEffectorType). Otherwise a pointer to this object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxEffectorType

</member>
        <member name="M:NxEffector.getType">
	\brief Retrieve the type of this effector.
	\return The type of effector.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes 
	\li PS3  : Yes
	\li XB360: Yes

	@see NxEffectorType

</member>
        <member name="T:NxEffector">
 \brief An effector is a class that gets called before each tick of the
 scene.
 
 At this point it may apply any permissible effect
 to the objects. For example: #NxSpringAndDamperEffector

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

 @see NxSpringAndDamperEffector NxScene.createSpringAndDamperEffector


@} 
</member>
        <member name="M:NxEffectorDesc.#ctor(NxEffectorType)">
	\brief Constructor sets to default.

	\param type effector type

</member>
        <member name="M:NxEffectorDesc.getType">
	\brief Retrieves the effector type.

	\return The type of effector this descriptor describes. 

	@see NxEffectorType

</member>
        <member name="M:NxEffectorDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return true if the current settings are valid

</member>
        <member name="M:NxEffectorDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxEffectorDesc.Dispose">
\brief Constructor sets to default.

</member>
        <member name="F:NxEffectorDesc.name">
	\brief Possible debug name. The string is not copied by the SDK, only the pointer is stored.

	<b>Default</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxEffectorDesc.userData">
	\brief Will be copied to NxEffector::userData.

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxEffectorDesc.type">
\brief The type of effector. This is set by the c'tor of the derived class.

</member>
        <member name="T:NxEffectorDesc">
 \brief Descriptor class for NxEffector class.
 
 Effector descriptors for all types are derived from this class.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

 @see NxSpringAndDamperEffectorDesc

</member>
        <member name="T:NxEffectorType">
@} 
\addtogroup physics
  @{

\addtogroup physics
  @{

</member>
        <member name="T:NxSoftBodyUserNotify">
\brief An interface class that the user can implement in order to receive simulation events.

<b>Threading:</b> It is not necessary to make this class thread safe as it will only be called in the context of the
user thread.

See the NxSoftBodyNotify documentation for an example of how to use notifications.

@see NxScene.setSoftBodyUserNotify() NxScene.getSoftBodyUserNotify() NxUserNotify

</member>
        <member name="T:NxSoftBody">
@} 
\addtogroup physics
@{

</member>
        <member name="T:NxClothUserNotify">
\brief An interface class that the user can implement in order to receive simulation events.

<b>Threading:</b> It is not necessary to make this class thread safe as it will only be called in the context of the
user thread.

See the NxUserNotify documentation for an example of how to use notifications.

@see NxScene.setClothUserNotify() NxScene.getClothUserNotify() NxUserNotify

</member>
        <member name="T:NxCloth">
@} 
\addtogroup physics
@{

</member>
        <member name="M:NxFluidUserNotify.onEvent(NxFluid*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxFluidEventType)">
	\brief This is called during NxScene::fetchResults with fluids that have events. 

	\param[in] fluid - The fluid which had the event.
	\param[in] eventType  - The event type.
	\return True to have the system release the fluid now. False to keep the fluid.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: No

	@see NxScene.setUserNotify() NxSceneDesc.userNotify
	@see NxFluidEventType

</member>
        <member name="M:NxFluidUserNotify.onEmitterEvent(NxFluidEmitter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxFluidEmitterEventType)">
	\brief This is called during NxScene::fetchResults with fluid emitters that have events. 

	\param[in] emitter - The emitter which had the event.
	\param[in] eventType  - The event type.
	\return True to have the system release the emitter now. False to keep the emitter.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: No

	@see NxScene.setUserNotify() NxSceneDesc.userNotify
	@see NxFluidEmitterEventType

</member>
        <member name="T:NxFluidUserNotify">
\brief An interface class that the user can implement in order to receive simulation events.

<b>Threading:</b> It is not necessary to make this class thread safe as it will only be called in the context of the
user thread.

See the NxUserNotify documentation for an example of how to use notifications.

@see NxScene.setFluidUserNotify() NxScene.getFluidUserNotify() NxUserNotify

</member>
        <member name="T:NxFluidEmitter">
@} 
\addtogroup physics
@{

</member>
        <member name="M:NxUserNotify.onSleep(NxActor**,System.UInt32)">
	\brief This is called during NxScene::fetchResults with the actors which have just been put to sleep.

	\param[in] actors - The actors which have just been put to sleep.
	\param[in] count  - The number of actors

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxScene.setUserNotify() NxSceneDesc.userNotify

</member>
        <member name="M:NxUserNotify.onWake(NxActor**,System.UInt32)">
	\brief This is called during NxScene::fetchResults with the actors which have just been woken up.

	\param[in] actors - The actors which just woke up.
	\param[in] count  - The number of actors

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxScene.setUserNotify() NxSceneDesc.userNotify

</member>
        <member name="M:NxUserNotify.onJointBreak(System.Single,NxJoint*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief This is called when a breakable joint breaks.
	
	The user should not release the joint inside this call! 
	Instead, if the user would like to have the joint
	released and no longer holds any referenced to it, he should return true.
	In this case the joint will be released by the system. Otherwise the user should return false, and 
	release the joint manually to free the resources associated with it (otherwise it will be released 
	with the scene).

	\note SDK state should not be modified from within onJointBreak(). In particular objects should not
	be created or destroyed. If state modification is needed then the changes should be stored to a buffer
	and performed after the simulation step.

	\note The behavior of this callback changed in version 2.5. The breakingForce parameter now supplies the 
	impulse applied, clamped to the maximum break impulse.

	\param[in] breakingImpulse The impulse which caused the joint to break.
	\param[in] brokenJoint The joint which has been broken.
	\return True to have the system release the joint now. False to keep the joint.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxJoint.setBreakable() NxJointDesc.maxForce NxJointDesc.maxTorque

</member>
        <member name="T:NxUserNotify">
 \brief An interface class that the user can implement in order to receive simulation events.

  <b>Threading:</b> It is not necessary to make this class thread safe as it will only be called in the context of the
  user thread.

 <h3>Example</h3>

 \include NxUserNotify_Example.cpp

 @see NxScene.setUserNotify() NxScene.getUserNotify()

</member>
        <member name="M:NxUserActorPairFiltering.onActorPairs(NxActorPairFilter*,System.UInt32)">
	\brief Callback to allow the user to decide whether to filter a certain actor pair.

	Use the actor member of the NxActorPairFilter objects to decide whether to filter out the contact
	between the pair. Set the filtered member to true to apply filtering.

	\param filterArray An array of actor pairs for which filtering is to be decided.
	\param arraySize The number of elements in filterArray.

	@see NxActorPairFilter NxActor::resetUserActorPairFiltering NxScene::setUserActorPairFiltering

</member>
        <member name="T:NxUserActorPairFiltering">
\brief An interface class that the user can implement in order to apply custom contact filtering.

</member>
        <member name="T:NxActorPairFilter">
\brief An actor pair used by filtering.

</member>
        <member name="M:NxUserWheelContactModify.onWheelContact(NxWheelShape*,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShape*,System.UInt16*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
	\brief This callback is called once for each wheel and sub step before the wheel constraints are setup
	and fed to the SDK. The values passed in the parameters can be adjusted to affect the vehicle simulation.
	The most interesting values are contactPosition, contactPoint, and contactNormal. The contactPosition value
	specifies how far on the travel distance the contactPoint was found. If you want to simulate a bumpy road,
	then this is the main parameter to change. It is also good to adjust the contactPoint variable, so that the
	wheel forces are applied in the correct position. 

	\param wheelShape The WheelShape that is being processed.
	\param contactPoint The contact point (in world coordinates) that is being used for the wheel.
	\param contactNormal The normal of the geometry at the contact point.
	\param contactPosition The distance on the spring travel distance where the wheel would end up if it was resting on the contact point.
	\param normalForce The normal force on the wheel from the last simulation step.
	\param otherShape The shape with which the wheel is in contact.
	\param otherShapeMaterialIndex The material on the other shape in the position where the wheel is in contact. Currently has no effect on the simulation.
	\param otherShapeFeatureIndex The feature on the other shape in the position where the wheel is in contact.

	\return Return true to keep the contact (with the possibly edited values) or false to drop the contact.

</member>
        <member name="T:NxUserWheelContactModify">
\brief An interface class that the user can implement in order to modify the contact point on which the 
WheelShape base its simulation constraints.

<b>Threading:</b> It is <b>necessary</b> to make this class thread safe as it will be called in the context of the
simulation thread. It might also be necessary to make it reentrant, since some calls can be made by multi-threaded
parts of the physics engine.

You enable the use of this callback by specifying a callback function in NxWheelShapeDesc.wheelContactModify 
or by setting a callback function through NxWheelShape.setUserWheelContactModify().

Please note: 
+ There will only be callbacks if the WheelShape finds a contact point. Increasing the suspensionTravel value
gives a longer raycast and increases the chance of finding a contact point (but also gives a potentially slower 
simulation).

@see NxWheelShapeDesc.wheelContactModify NxWheelShape.setUserWheelContactModify() NxWheelShape.getUserWheelContactModify()


@} 
</member>
        <member name="M:NxUserContactModify.onContactConstraint(System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShape!System.Runtime.CompilerServices.IsConst*,NxShape!System.Runtime.CompilerServices.IsConst*,System.UInt32!System.Runtime.CompilerServices.IsConst,System.UInt32!System.Runtime.CompilerServices.IsConst,NxUserContactModify.NxContactCallbackData*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief This is called when a contact constraint is generated. Modify the parameters in order to affect the generated contact constraint.
	This callback needs to be both thread safe and reentrant.

	\param changeFlags when making changes to the contact point, you must mark in this flag what changes have been made, see NxContactConstraintChange.
	\param shape0 one of the two shapes in contact
	\param shape1 the other shape
	\param featureIndex0 feature on the first shape, which is in contact with the other shape
	\param featureIndex1 feature on the second shape, which is in contact with the other shape
	\param data contact constraint properties, for the user to change. Changes in this also requires changes in the changeFlags parameter.

	\return true if the contact point should be kept, false if it should be discarded.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxUserContactModify.NxContactCallbackData.dynamicFriction1">
		\brief Dynamic friction parameter 1.

		\note 1 does not have anything to do with shape 0/1, but is related to anisotropic friction, 
		0 is the primary friction axis.

</member>
        <member name="F:NxUserContactModify.NxContactCallbackData.dynamicFriction0">
		\brief Dynamic friction parameter 0.

		\note 0 does not have anything to do with shape 0/1, but is related to anisotropic friction, 
		0 is the primary friction axis.

</member>
        <member name="F:NxUserContactModify.NxContactCallbackData.staticFriction1">
		\brief Static friction parameter 1.

		\note 1 does not have anything to do with shape 0/1, but is related to anisotropic friction, 
		0 is the primary friction axis.

</member>
        <member name="F:NxUserContactModify.NxContactCallbackData.staticFriction0">
		\brief Static friction parameter 0.

		\note 0 does not have anything to do with shape 0/1, but is related to anisotropic friction, 
		0 is the primary friction axis.

</member>
        <member name="F:NxUserContactModify.NxContactCallbackData.localorientation1">
\brief Constraint orientation quaternion for shape 1 relative to shape 1s body frame for dynamic 
actors and relative to the world frame for static actors. 

The constraint axis (normal) is along the x-axis of the quaternion. 
The Y axis is the primary friction axis and the Z axis the secondary friction axis. 

</member>
        <member name="F:NxUserContactModify.NxContactCallbackData.localorientation0">
\brief Constraint orientation quaternion for shape 0 relative to shape 0s body frame for dynamic 
actors and relative to the world frame for static actors. 

The constraint axis (normal) is along the x-axis of the quaternion. 
The Y axis is the primary friction axis and the Z axis the secondary friction axis. 

</member>
        <member name="F:NxUserContactModify.NxContactCallbackData.localpos1">
\brief Constraint attachment point for shape 1. 

If the shape belongs to a dynamic actor, then localpos1 is relative to the body frame of the actor. 
Alternatively it is relative to the world frame for a static actor. 

</member>
        <member name="F:NxUserContactModify.NxContactCallbackData.localpos0">
\brief Constraint attachment point for shape 0. 

If the shape belongs to a dynamic actor, then localpos0 is relative to the body frame of the actor. 
Alternatively it is relative to the world frame for a static actor. 

</member>
        <member name="T:NxUserContactModify.NxContactConstraintChange">
\brief This enum is used for marking changes made to contact constraints in the NxUserContactModify callback. OR the values together when making multiple changes on the same contact.

</member>
        <member name="T:NxUserContactModify">
\brief An interface class that the user can implement in order to modify contact constraints.

<b>Threading:</b> It is <b>necessary</b> to make this class thread safe as it will be called in the context of the
simulation thread. It might also be necessary to make it reentrant, since some calls can be made by multi-threaded
parts of the physics engine.

You can enable the use of this contact modification callback in two ways:
1. Raise the flag NX_AF_CONTACT_MODIFICATION on a per-actor basis.
or
2. Set the flag NX_NOTIFY_CONTACT_MODIFICATION on a per-actor-pair basis.

Please note: 
+ It is possible to raise the contact modification flags at any time. But the calls will not wake the actors up.
+ It is not possible to turn off the performance degradation by simply removing the callback from the scene, all flags need to be removed as well.
+ The contacts will only be reported as long as the actors are awake. There will be no callbacks while the actors are sleeping.

@see NxScene.setUserContactModify() NxScene.getUserContactModify()

</member>
        <member name="M:NxUserTriggerReport.onTrigger(NxShape*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShape*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShapeFlag)">
	\brief Called when a trigger shape reports a trigger event.

	\note SDK state should not be modified from within onTrigger(). In particular objects should not
	be created or destroyed. If state modification is needed then the changes should be stored to a buffer
	and performed after the simulation step.

	\param[in] triggerShape is the shape that has been marked as a trigger.
	\param[in] otherShape is the shape causing the trigger event.
	\param[in] status is the type of trigger event.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxTriggerFlag

</member>
        <member name="T:NxUserTriggerReport">
\brief The user needs to implement this interface class in order to be notified when trigger events
occur. 

Once you pass an instance of this class to #NxScene::setUserTriggerReport(), shapes
which have been marked as triggers using NxShape::setFlag(NX_TRIGGER_ENABLE,true) will call the
#onTrigger() method when their trigger status changes.

<b>Threading:</b> It is not necessary to make this class thread safe as it will only be called in the context of the
user thread.

Example:

\include NxUserTriggerReport_Usage.cpp

<h3>Visualizations</h3>
\li NX_VISUALIZE_COLLISION_SHAPES

@see NxScene.setUserTriggerReport() NxScene.getUserTriggerReport() NxShapeFlag NxShape.setFlag()

</member>
        <member name="M:NxUserContactReport.onContactNotify(NxContactPair*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
	Called for a pair in contact. The events parameter is a combination of:

	<ul><li>NX_NOTIFY_ON_START_TOUCH,</li><li>NX_NOTIFY_ON_END_TOUCH,</li><li>NX_NOTIFY_ON_TOUCH,</li><li>NX_NOTIFY_ON_START_TOUCH_FORCE_THRESHOLD,</li><li>NX_NOTIFY_ON_END_TOUCH_FORCE_THRESHOLD,</li><li>NX_NOTIFY_ON_TOUCH_FORCE_THRESHOLD,</li><li>NX_NOTIFY_ON_IMPACT,	//unimplemented!</li><li>NX_NOTIFY_ON_ROLL,		//unimplemented!</li><li>NX_NOTIFY_ON_SLIDE,		//unimplemented!</li></ul>

	See the documentation of #NxContactPairFlag for an explanation of each. You request which events 
	are reported using #NxScene::setActorPairFlags(), #NxScene::setActorGroupPairFlags(),
	#NxScene::setShapePairFlags() or #NxActor::setContactReportFlags(). Do not keep a reference to 
	the passed object, as it will be invalid after this function returns.

	\note SDK state should not be modified from within onContactNotify(). In particular objects should not
	be created or destroyed. If state modification is needed then the changes should be stored to a buffer
	and performed after the simulation step.

	\param[in] pair The contact pair we are being notified of. See #NxContactPair.
	\param[in] events Flags raised due to the contact. See #NxContactPairFlag.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxContactPair NxContactPairFlag

</member>
        <member name="T:NxUserContactReport">
\brief The user needs to implement this interface class in order to be notified when
certain contact events occur.

Once you pass an instance of this class to #NxScene::setUserContactReport(), 
its  #onContactNotify() method will be called for each pair of actors which comes into contact, 
for which this behavior was enabled.

You request which events are reported using NxScene::setActorPairFlags(), 
#NxScene::setShapePairFlags(), #NxScene::setActorGroupPairFlags() or #NxActor::setContactReportFlags()

Please note: Kinematic actors will not generate contact reports when in contact with other kinematic actors.

 <b>Threading:</b> It is not necessary to make this class thread safe as it will only be called in the context of the
 user thread.

<h3>Example</h3>

\include NxUserContactReport_Example.cpp

<h3>Visualizations:</h3>
\li #NX_VISUALIZE_CONTACT_POINT
\li #NX_VISUALIZE_CONTACT_NORMAL
\li #NX_VISUALIZE_CONTACT_ERROR
\li #NX_VISUALIZE_CONTACT_FORCE

@see NxScene.setUserContactReport() NxScene.getUserNotify()

</member>
        <member name="F:NxContactPair.isDeletedActor">
	\brief Specifies for each actor of the pair if the actor has been deleted.

	Before dereferencing the actor pointers of the contact pair you might want to use this member
	to check if the pointers reference deleted actors. This will be the case if an actor for which
	NX_NOTIFY_ON_END_TOUCH or NX_NOTIFY_ON_END_TOUCH_FORCE_THRESHOLD events were requested gets deleted.

	@see actors

</member>
        <member name="F:NxContactPair.sumFrictionForce">
\brief The total tangential force that was applied for this pair. You should set NX_NOTIFY_FORCES in order to receive this value.

</member>
        <member name="F:NxContactPair.sumNormalForce">
\brief The total contact normal force that was applied for this pair, to maintain nonpenetration constraints. You should set NX_NOTIFY_FORCES in order to receive this value.

</member>
        <member name="F:NxContactPair.stream">
	\brief Use this to create stream iter. See #NxContactStreamIterator.

	@see NxConstContactStream

</member>
        <member name="F:NxContactPair.actors">
	\brief The two actors that make up the pair.

	\note The actor pointers might reference deleted actors. Check the #isDeletedActor member to see
	      whether that is the case. Do not dereference a pointer to a deleted actor. The pointer to a
		  deleted actor is only provided such that user data structures which might depend on the pointer
		  value can be updated.

	@see NxActor

</member>
        <member name="T:NxContactPair">
\brief An instance of this class is passed to NxUserContactReport::onContactNotify().
It contains a contact stream which may be parsed using the class NxContactStreamIterator.

@see NxUserContactReport.onContactNotify()

</member>
        <member name="T:NxContactPairFlag">
\brief Contact pair flags.

@see NxUserContactReport.onContactNotify() NxActor::setContactReportThreshold

</member>
        <member name="F:NxContactStreamIterator.stream">
\brief The associated stream

</member>
        <member name="M:NxContactStreamIterator.getSeparation">
	\brief Return the separation for the contact point.

	May be called after goNextPoint() returned true
	
	\return the seperation distance for the current point.

	@see goNextPoint() getPoint()

</member>
        <member name="M:NxContactStreamIterator.getPoint">
	\brief Returns the contact point position.
	
	May be called after goNextPoint() returned true
	
	\return the current contact point

	@see getShapeFlags() goNextPoint() getNumPoints() getSeparation() getFeatureIndex0()

</member>
        <member name="M:NxContactStreamIterator.getNumPointsRemaining">
	\brief Retrieves the number of points remaining in the current patch.
	
	May be called after goNextPatch() returned true

	\return The number of points remaining in the current patch.

	@see goNextPoint() getNumPoints()

</member>
        <member name="M:NxContactStreamIterator.getNumPoints">
	\brief Retrieves the number of points in the current patch.
	
	May be called after goNextPatch() returned true

	\return The number of points in the current patch.

	@see goNextPoint() getNumPointsRemaining()

</member>
        <member name="M:NxContactStreamIterator.getPatchNormal">
	\brief Retrieves the patch normal.
	
	May be called after goNextPatch() returned true

	\return The patch normal.

	@see goNextPatch()

</member>
        <member name="M:NxContactStreamIterator.getNumPatchesRemaining">
	\brief Retrieves the number of remaining patches.
	
	May be called after goNextPair() returned true

	\return The number of patches remaining in this pair.

	@see goNextPatch() getNumPatches()

</member>
        <member name="M:NxContactStreamIterator.getNumPatches">
	\brief Retrieves the number of patches for the current pair.
	
	May be called after goNextPair() returned true

	\return The number of patches in this pair.

	@see goNextPatch()

</member>
        <member name="M:NxContactStreamIterator.getShapeFlags">
	\brief Retrieves the shape flags for the current pair.
	
	May be called after goNextPair() returned true

	\return The shape flags for the current pair. See #NxShapeFlag.

	@see NxShapeFlag NxShape goNextPair()

</member>
        <member name="M:NxContactStreamIterator.getShape(System.UInt32)">
	\brief Retrieves the shapes for the current pair.
	
	May be called after goNextPair() returned true. ShapeIndex is 0 or 1.

	\param[in] shapeIndex Used to choose which of the pair of shapes to retrieve(set to 0 or 1).
	\return The shape specified by shapeIndex.

	@see goNextPair() NxShape

</member>
        <member name="M:NxContactStreamIterator.getNumPairs">
	\brief Returns the number of pairs in the structure. 
	
	May be called at any time.
	
	\return The number of pairs in the struct (including invalid pairs).

	@see goNextPair()

</member>
        <member name="M:NxContactStreamIterator.goNextPoint">
	\brief Goes on to the next contact point.
	
	Returns false if there are no more. Once goNextPoint() returns false, the user should
	not call it again unil they move to the next patch.

	\return True if there are more contact points.

	@see getPoint()

</member>
        <member name="M:NxContactStreamIterator.goNextPatch">
	\brief Goes on to the next patch (contacts with the same normal).
	
	Returns false if there are no more. Once goNextPatch() returns false, the user should
	not call it again until they move to the next pair.

	\return True if there are more patches.

	@see getPatchNormal()

</member>
        <member name="M:NxContactStreamIterator.goNextPair">
	\brief Goes on to the next pair, silently skipping invalid pairs.
	
	Returns false if there are no more pairs. Note that getNumPairs() also includes invalid pairs in the count.
	
	Once goNextPoint() returns false, the user should not call it again.

	\return True if there are more pairs.

	@see getNumPairs() getShape()

</member>
        <member name="M:NxContactStreamIterator.#ctor(System.UInt32!System.Runtime.CompilerServices.IsConst*)">
	\brief Starts the iteration, and returns the number of pairs.

	\param[in] stream

	@see NxConstContactStream

</member>
        <member name="T:NxShapePairStreamFlags">
\brief Flags which describe a contact

@see NxContactStreamIterator

</member>
        <member name="M:NxMaterial.getRestitutionCombineMode">
	\brief Retrieves the restitution combine mode.
	
	See #setRestitutionCombineMode.

	\return The coefficient of restitution combine mode for this material.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCombineMode setRestitutionCombineMode getRestitution()

</member>
        <member name="M:NxMaterial.setRestitutionCombineMode(NxCombineMode)">
	\brief Sets the restitution combine mode.
	
	See the enum ::NxCombineMode .

	<b>Sleeping:</b> Does <b>NOT</b> wake any actors which may be affected.

	\param[in] combMode Restitution combine mode for this material. See #NxCombineMode.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCombineMode getRestitutionCombineMode() setRestitution()

</member>
        <member name="M:NxMaterial.getFrictionCombineMode">
	\brief Retrieves the friction combine mode.
	
	See #setFrictionCombineMode.

	\return The friction combine mode for this material.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCombineMode setFrictionCombineMode() 

</member>
        <member name="M:NxMaterial.setFrictionCombineMode(NxCombineMode)">
	\brief Sets the friction combine mode.
	
	See the enum ::NxCombineMode .

	<b>Sleeping:</b> Does <b>NOT</b> wake any actors which may be affected.

	\param[in] combMode Friction combine mode to set for this material. See #NxCombineMode.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCombineMode getFrictionCombineMode setStaticFriction() setDynamicFriction()

</member>
        <member name="M:NxMaterial.getFlags">
	\brief Retrieves the flags. See #NxMaterialFlag.

	\return The material flags.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxMaterialFlag setFlags()

</member>
        <member name="M:NxMaterial.setFlags(System.UInt32)">
	\brief Sets the flags, a combination of the bits defined by the enum ::NxMaterialFlag . 

	<b>Sleeping:</b> Does <b>NOT</b> wake any actors which may be affected.

	\param[in] flags #NxMaterialFlag combination.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getFlags() NxMaterialFlag

</member>
        <member name="M:NxMaterial.getDirOfAnisotropy">
	\brief Retrieves the direction of anisotropy value.

	\return The direction of anisotropy.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setDirOfAnisotropy() NxMaterialDesc.dirOfAnisotropy setFlags()

</member>
        <member name="M:NxMaterial.setDirOfAnisotropy(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the shape space direction (unit vector) of anisotropy.

	This is used when anisotropic friction is being applied. I.e. the NX_MF_ANISOTROPIC flag is set.

	<b>Sleeping:</b> Does <b>NOT</b> wake any actors which may be affected.

	\param[in] vec Shape space direction of anisotropy. <b>Range:</b> direction vector

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getDirOfAnisotropy() NxMaterialDesc.dirOfAnisotropy setFlags()

</member>
        <member name="M:NxMaterial.getStaticFrictionV">
	\brief Retrieves the static friction coefficient for the V direction.

	\return The coefficient of static friction in the V direction.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setStaticFrictionV() NxMaterialDesc.staticFrictionV

</member>
        <member name="M:NxMaterial.setStaticFrictionV(System.Single)">
	\brief Sets the static friction coefficient along the secondary (V) axis. 

	This is used when anisotropic friction is being applied. I.e. the NX_MF_ANISOTROPIC flag is set.

	<b>Sleeping:</b> Does <b>NOT</b> wake any actors which may be affected.

	\param[in] coef Coefficient of static friction in the V axis. <b>Range:</b> [0,inf]

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getStaticFrictionV() NxMaterialDesc.staticFrictionV setFlags()

</member>
        <member name="M:NxMaterial.getDynamicFrictionV">
	\brief Retrieves the dynamic friction coefficient for the V direction.
	
	See #setDynamicFrictionV.

	\return The coefficient if dynamic friction in the V direction.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setDynamicFrictionV() NxMaterialDesc.dynamicFrictionV

</member>
        <member name="M:NxMaterial.setDynamicFrictionV(System.Single)">
	\brief Sets the dynamic friction coefficient along the secondary (V) axis. 

	This is used when anisotropic friction is being applied. I.e. the NX_MF_ANISOTROPIC flag is set.

	<b>Sleeping:</b> Does <b>NOT</b> wake any actors which may be affected.

	\param[in] coef Coefficient of dynamic friction in the V axis. <b>Range:</b> [0, +inf]

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getDynamicFrictionV() NxMaterialDesc.dynamicFrictionV setFlags()

</member>
        <member name="M:NxMaterial.getRestitution">
	\brief Retrieves the coefficient of restitution. 

	See #setRestitution.

	\return The coefficient of restitution.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setRestitution() NxMaterialDesc.restitution

</member>
        <member name="M:NxMaterial.setRestitution(System.Single)">
	\brief Sets the coefficient of restitution 
	
	A coefficient of 0 makes the object bounce as little as possible, higher values up to 1.0 result in more bounce.

	<b>Sleeping:</b> Does <b>NOT</b> wake any actors which may be affected.

	\param[in] rest Coefficient of restitution. <b>Range:</b> [0,1]

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getRestitution() NxMaterialDesc.restitution

</member>
        <member name="M:NxMaterial.getStaticFriction">
	\brief Retrieves the coefficient of static friction.
	\return The coefficient of static friction.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setStaticFriction NxMaterialDesc.staticFriction

</member>
        <member name="M:NxMaterial.getDynamicFriction">
	\brief Retrieves the DynamicFriction value.

	\return The coefficient of dynamic friction.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setDynamicFriction NxMaterialDesc.dynamicFriction

</member>
        <member name="M:NxMaterial.setDynamicFriction(System.Single)">
	\brief Sets the coefficient of dynamic friction.
	
	The coefficient of dynamic friction should be in [0, +inf]. If set to greater than staticFriction, the effective value of staticFriction will be increased to match.
	If the flag NX_MF_ANISOTROPIC is set, then this value is used for the primary direction of anisotropy (U axis)

	<b>Sleeping:</b> Does <b>NOT</b> wake any actors which may be affected.

	\param[in] coef Coefficient of dynamic friction. <b>Range:</b> [0, +inf]

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxMaterialDesc.dynamicFriction getDynamicFriction()

</member>
        <member name="M:NxMaterial.getScene">
	\brief retrieves owner scene

	\return The scene which this material belongs to.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxScene

</member>
        <member name="M:NxMaterial.saveToDesc(NxMaterialDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Saves the state of the material into a descriptor.

	\param[out] desc The descriptor used to retrieve this objects state.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see loadFromDesc NxMaterialDesc

</member>
        <member name="M:NxMaterial.loadFromDesc(NxMaterialDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Loads the entire state of the material from a descriptor with a single call.

	<b>Sleeping:</b> Does <b>NOT</b> wake any actors which may be affected.

	\param[in] desc The descriptor used to set this objects state.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see saveToDesc NxMaterialDesc

</member>
        <member name="M:NxMaterial.getMaterialIndex">
	\brief The ID of the material can be retrieved using this function.	  
	
	Materials are associated with mesh faces and shapes using 16 bit identifiers of type NxMaterialIndex rather
	than pointers.

	If you release a material while its material ID is still in use by shapes or meshes, the material usage
	of these objects becomes undefined as the material index gets recycled.

	\return The material index for this material.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxMaterialIndex NxTriangleMeshDesc.materialIndices NxShapeDesc.materialIndex NxShape.setMaterial()

</member>
        <member name="T:NxMaterial">
\brief Class for describing a shape's surface properties.

<h3>Creation</h3>

Example material creation:
\include NxMaterial_Create.cpp

You can create a material which has different friction coefficients depending on the direction that
a body in contact is trying to move in. This is called anisotropic friction.

<h3>Anisotropic Friction</h3>

Anisotropic friction is useful for modeling things like sledges, skis etc

When you create an anisotropic material you specify the default friction parameters and also friction parameters for the V axis.
The friction parameters for the V axis are applied to motion along the direction of anisotropy (dirOfAnisotropy).

Anisotropic Material Example:
\include NxMaterial_Aniso.cpp

<h3>Default Material</h3>

You can change the properties of the default material by querying for material index 0.

Default Material Example:
\include NxMaterial_ChangeDefault.cpp

<h3>Visualizations:</h3>
\li #NX_VISUALIZE_CONTACT_POINT
\li #NX_VISUALIZE_CONTACT_NORMAL
\li #NX_VISUALIZE_CONTACT_ERROR
\li #NX_VISUALIZE_CONTACT_FORCE

@see NxMaterialDesc NxScene.createMaterial

</member>
        <member name="M:NxMaterialDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return true if the current settings are valid

</member>
        <member name="M:NxMaterialDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxMaterialDesc.#ctor">
\brief constructor sets to default.

</member>
        <member name="F:NxMaterialDesc.spring">
Not used.

</member>
        <member name="F:NxMaterialDesc.restitutionCombineMode">
	Restitution combine mode. See the enum ::NxCombineMode .

	<b>Default:</b> NX_CM_AVERAGE

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCombineMode restitution

</member>
        <member name="F:NxMaterialDesc.frictionCombineMode">
	Friction combine mode. See the enum ::NxCombineMode .

	<b>Default:</b> NX_CM_AVERAGE

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCombineMode staticFriction dynamicFriction

</member>
        <member name="F:NxMaterialDesc.flags">
	Flags, a combination of the bits defined by the enum ::NxMaterialFlag . 

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxMaterialFlag

</member>
        <member name="T:NxMaterialDesc">
\brief Descriptor of #NxMaterial.

@see NxMaterial NxScene.createMaterial()

</member>
        <member name="T:NxCombineMode">
Flag that determines the combine mode. When two actors come in contact with each other, they each have
materials with various coefficients, but we only need a single set of coefficients for the pair.

Physics doesn't have any inherent combinations because the coefficients are determined empirically on a case by case
basis. However, simulating this with a pairwise lookup table is often impractical.

For this reason the following combine behaviors are available:

NX_CM_AVERAGE
NX_CM_MIN
NX_CM_MULTIPLY
NX_CM_MAX

The effective combine mode for the pair is max(material0.combineMode, material1.combineMode).

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

@see NxMaterial NxMaterialDesc NxMaterialDesc.frictionCombineMode NxMaterialDesc.restitutionCombineMode

</member>
        <member name="T:NxMaterialFlag">
@} 
\brief Flags which control the behavior of a material.

@see NxMaterial NxMaterialDesc

</member>
        <member name="F:NX_MF_DISABLE_STRONG_FRICTION">
	The difference between "normal" and "strong" friction is that the strong friction feature
	remembers the "friction error" between simulation steps. The friction is a force trying to
	hold objects in place (or slow them down) and this is handled in the solver. But since the
	solver is only an approximation, the result of the friction calculation can include a small
	"error" - e.g. a box resting on a slope should not move at all if the static friction is in
	action, but could slowly glide down the slope because of a small friction error in each 
	simulation step. The strong friction counter-acts this by remembering the small error and
	taking it to account during the next simulation step.

	However, in some cases the strong friction could cause problems, and this is why it is
	possible to disable the strong friction feature by setting this flag. One example is
	raycast vehicles, that are sliding fast across the surface, but still need a precise
	steering behavior. It may be a good idea to reenable the strong friction when objects
	are coming to a rest, to prevent them from slowly creeping down inclines.

	Note: This flag only has an effect if the NX_MF_DISABLE_FRICTION bit is 0.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxWheelShape

</member>
        <member name="F:NX_MF_DISABLE_FRICTION">
	If this flag is set, friction computations are always skipped between shapes with this material and any other shape.
	It may be a good idea to use this when all friction is to be performed using the tire friction model (see ::NxWheelShape).

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxWheelShape

</member>
        <member name="F:NX_MF_ANISOTROPIC">
	\brief Flag to enable anisotropic friction computation. 

	For a pair of actors, anisotropic friction is used only if at least one of the two actors' materials are anisotropic.
	The anisotropic friction parameters for the pair are taken from the material which is more anisotropic (i.e. the difference
	between its two dynamic friction coefficients is greater).

	The anisotropy direction of the chosen material is transformed to world space:

	dirOfAnisotropyWS = shape2world * dirOfAnisotropy

	Next, the directions of anisotropy in one or more contact planes (i.e. orthogonal to the contact normal) have to be determined. 
	The two directions are:

	uAxis = (dirOfAnisotropyWS ^ contactNormal).normalize()
	vAxis = contactNormal ^ uAxis

	This way [uAxis, contactNormal, vAxis] forms a basis.

	It may happen, however, that (dirOfAnisotropyWS | contactNormal).magnitude() == 1 
	and then (dirOfAnisotropyWS ^ contactNormal) has zero length. This happens when 
	the contactNormal is coincident to the direction of anisotropy. In this case we perform isotropic friction. 

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (SW fall-back)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxMaterialDesc.dirOfAnisotropy

</member>
        <member name="M:NxSpringDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return True if the current settings are valid.

</member>
        <member name="M:NxSpringDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxSpringDesc.#ctor(System.Single,System.Single,System.Single)">
	\brief Initializes a NxSpringDesc with the given parameters.

	\param[in] spring Spring Coefficient. <b>Range:</b> (-inf,inf)
	\param[in] damper Damper Coefficient. <b>Range:</b>  [0,inf)
	\param[in] targetValue Target value (angle/position) of spring where the spring force is zero. 
	<b>Range:</b> Angular: (-PI,PI] Positional: (-inf,inf)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxSpringDesc.#ctor">
\brief Initializes the NxSpringDesc with default parameters.

</member>
        <member name="T:NxSpringDesc">
@} 
\addtogroup physics
  @{

\addtogroup physics
  @{

\addtogroup physics
  @{

\brief Describes a joint spring.

The spring is implicitly integrated, so even high spring and damper coefficients should be robust.

<h3>Example</h3>

\include NxSpringDesc_NxJointLimitDesc_Example.cpp

@see NxDistanceJoint NxRevoluteJoint NxSphericalJoint NxWheelShape NxMaterial NxMaterialDesc

</member>
        <member name="M:NxActor.setForceFieldMaterial(System.UInt16)">
	\brief Sets the actor's force field material index, default index is 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes


</member>
        <member name="M:NxActor.getForceFieldMaterial">
	\brief Retrieves the actor's force field material index, default index is 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes


</member>
        <member name="M:NxActor.getCompartment">
	\brief Retrieves the actor's simulation compartment, if any.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCompartment

</member>
        <member name="M:NxActor.linearSweep(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.Void*,System.UInt32,NxSweepQueryHit*,NxUserEntityReport&lt;NxSweepQueryHit&gt;*,NxSweepCache!System.Runtime.CompilerServices.IsConst*)">
	\brief Performs a linear sweep through space with the actor.

	\param[in] motion Length and direction of the sweep
	\param[in] flags Flags controlling the mode of the sweep
	\param[in] userData User data to impart to the returned data struct
	\param[in] nbShapes Maximum number of shapes to report <b>Range:</b> [1,NX_MAX_U32]
	\param[out] shapes Pointer to buffer for reported shapes
	\param[in] callback Callback function invoked on the closest hit (if any)
	\param[in] sweepCache Sweep cache to use with the query

	The function sweeps the entire actor, with all its shapes, through space and reports any shapes in the scene
	with which they intersect. Apart from the number of shapes intersected in this way, and the shapes
	intersected, information on the closest intersection is put in an #NxSweepQueryHit structure which 
	can be processed in the callback function if provided.
	Which shapes in the scene are regarded is specified through the flags parameter.
	For persistent sweeps, a sweep cache may be used to improve performance. A sweep cache may be created 
	through NxScene::createSweepCache().
	Note that trigger shapes possibly contained in the actor are automatically filtered out.

	\return The number of hits reported.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSweepQueryHit NxSweepFlags NxUserEntityReport NxScene

</member>
        <member name="M:NxActor.setContactReportFlags(System.UInt32)">
	\brief Sets the actor's contact report flags.

	These flags are used to determine the kind of report that is generated for interactions with other
	actors.

	The following flags are permitted:

	NX_NOTIFY_ON_START_TOUCH
	NX_NOTIFY_ON_END_TOUCH
	NX_NOTIFY_ON_TOUCH	
	NX_NOTIFY_ON_IMPACT
	NX_NOTIFY_ON_ROLL
	NX_NOTIFY_ON_SLIDE
	NX_NOTIFY_FORCE
	NX_NOTIFY_ON_START_TOUCH_FORCE_THRESHOLD
	NX_NOTIFY_ON_END_TOUCH_FORCE_THRESHOLD
	NX_NOTIFY_ON_TOUCH_FORCE_THRESHOLD

	Please note: If the actor is part of an interacting pair for which the contact report generation
	is controlled already through any other mechanism (for example by use of NxScene::setActorPairFlags)
	then the union of all the specified contact report flags will be used to generate the report.

	See #getContactReportFlags().

	\param[in] flags Flags to control contact reporting. See #NxContactPairFlag.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getContactReportFlags NxContactPairFlag NxActorDesc::contactReportFlags

</member>
        <member name="M:NxActor.getContactReportFlags">
	\brief Retrieves the actor's contact report flags.

	See #setContactReportFlags().

	\return The contact reporting flags associated with this actor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setContactReportFlags NxContactPairFlag NxActorDesc::contactReportFlags

</member>
        <member name="M:NxActor.setContactReportThreshold(System.Single)">
	\brief Sets the force threshold for contact reports.

	See #getContactReportThreshold().

	The actor must be dynamic.

	\param[in] threshold Force threshold for contact reports. <b>Range:</b> (0,inf)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getContactReportThreshold getContactReportFlags NxContactPairFlag NxBodyDesc::contactReportThreshold

</member>
        <member name="M:NxActor.getContactReportThreshold">
	\brief Retrieves the force threshold for contact reports.

	The contact report threshold is a force threshold. If the force between 
	two actors exceeds this threshold for either of the two actors, a contact report 
	will be generated according to the union of both actors' contact report threshold flags.
	See #getContactReportFlags().

	The actor must be dynamic. The threshold used for a collision between a dynamic actor
	and the static environment is the threshold of the dynamic actor, and all contacts with
	static actors are summed to find the total normal force.

	\return Force threshold for contact reports.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setContactReportThreshold getContactReportFlags NxContactPairFlag NxBodyDesc::contactReportThreshold

</member>
        <member name="M:NxActor.getSolverIterationCount">
	\brief Retrieves the solver iteration count.

	See #setSolverIterationCount().

	The actor must be dynamic.

	\return The solver iteration count for this body.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setSolverIterationCount() NxBodyDesc.solverIterationCount

</member>
        <member name="M:NxActor.setSolverIterationCount(System.UInt32)">
	\brief Sets the solver iteration count for the body. 
	
	The solver iteration count determines how accurately joints and contacts are resolved. 
	If you are having trouble with jointed bodies oscillating and behaving erratically, then
	setting a higher solver iteration count may improve their stability.

	The actor must be dynamic.

	\param[in] iterCount Number of iterations the solver should perform for this body. <b>Range:</b> [1,255]

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getSolverIterationCount() NxBodyDesc.solverIterationCount

</member>
        <member name="M:NxActor.saveBodyToDesc(NxBodyDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Saves the body information of a dynamic actor to the passed body descriptor.

	This method only save the dynamic(body) state for the actor. The user should use #saveToDesc()
	to save the state common between static and dynamic actors. Plus manually saving the shapes
	belonging to the actor.

	The actor must be dynamic.

	\param[out] bodyDesc Descriptor to save the state of the body to.
	\return True for a dynamic body. Otherwise False.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBodyDesc saveToDesc() getShape()

</member>
        <member name="M:NxActor.readBodyFlag(NxBodyFlag)">
	\brief Reads a particular body flag.
	
	See #NxBodyFlag for a list of flags.

	The actor must be dynamic.

	\param[in] bodyFlag Body flag to retrieve. See #NxBodyFlag.
	\return The value of the body flag specified by bodyFlag.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Partial (supports NX_BF_KINEMATIC, NX_BF_DISABLE_GRAVITY)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBodyFlag raiseBodyFlag() clearBodyFlag() NxBodyDesc.flags

</member>
        <member name="M:NxActor.clearBodyFlag(NxBodyFlag)">
	\brief Clears a particular body flag.
	
	See #NxBodyFlag for a list of flags.

	The actor must be dynamic.

	\param[in] bodyFlag Body flag to clear. See #NxBodyFlag.

	Sleeping: Does NOT wake the actor up automatically.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Partial (supports NX_BF_KINEMATIC, NX_BF_DISABLE_GRAVITY)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBodyFlag raiseBodyFlag() readBodyFlag() NxBodyDesc.flags

</member>
        <member name="M:NxActor.raiseBodyFlag(NxBodyFlag)">
	\brief Raises a particular body flag.
	
	See the actors body flags. See #NxBodyFlag for a list of flags.

	The actor must be dynamic.

	\param[in] bodyFlag Body flag to raise(set). See #NxBodyFlag.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Partial (supports NX_BF_KINEMATIC, NX_BF_DISABLE_GRAVITY)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBodyFlag clearBodyFlag() readBodyFlag() NxBodyDesc.flags

</member>
        <member name="M:NxActor.putToSleep">
	\brief Forces the actor to sleep. 
	
	The actor will stay asleep until the next call to simulate, and will not wake up until then even when otherwise 
	it would (for example a force is applied to it). It can however wake up during
	the next simulate call.

	The actor must be dynamic.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see isGroupSleeping() isSleeping() getSleepLinearVelocity() getSleepAngularVelocity() wakeUp()

</member>
        <member name="M:NxActor.wakeUp(System.Single)">
	\brief Wakes up the actor if it is sleeping.  

	The wakeCounterValue determines how long until the body is put to sleep, a value of zero means 
	that the body is sleeping. wakeUp(0) is equivalent to NxActor::putToSleep().

	The actor must be dynamic.

	\param[in] wakeCounterValue New sleep counter value. <b>Range:</b> [0,inf]
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see isGroupSleeping() isSleeping() getSleepLinearVelocity() getSleepAngularVelocity() putToSleep()

</member>
        <member name="M:NxActor.setSleepEnergyThreshold(System.Single)">
	\brief Sets the energy threshold below which an actor may go to sleep.

	Actors whose kinematic energy is above this threshold will not be put to sleep.

	If the threshold value is negative,	the velocity threshold is set using the NxPhysicsSDK's 
	NX_DEFAULT_SLEEP_ENERGY parameter.

	Setting the sleep energy threshold only makes sense when the NX_BF_ENERGY_SLEEP_TEST is set. There
	are also other types of sleeping that uses the linear and angular velocities directly instead of the 
	energy.
    
    The actor must be dynamic.

	\param[in] threshold Energy below which an actor may go to sleep. <b>Range:</b> (0,inf]

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see isGroupSleeping() isSleeping() getSleepEnergyThreshold() getSleepLinearVelocity() getSleepAngularVelocity() wakeUp() putToSleep() setSleepLinearVelocity() setSleepAngularVelocity() NxBodyDesc.sleepEnergyThreshold

</member>
        <member name="M:NxActor.getSleepEnergyThreshold">
	\brief Returns the energy below which an actor may go to sleep.

	Actors whose energy is above this threshold will not be put to sleep. 

	The actor must be dynamic.

	\return The energy threshold for sleeping.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see isGroupSleeping() isSleeping() getSleepLinearVelocity() getSleepAngularVelocity() wakeUp() putToSleep() setSleepAngularVelocity() NxBodyDesc.sleepEnergyThreshold

</member>
        <member name="M:NxActor.setSleepAngularVelocity(System.Single)">
	\brief Sets the angular velocity below which an actor may go to sleep.
	
	Actors whose angular velocity is above this threshold will not be put to sleep.

	If the threshold value is negative,	the velocity threshold is set using the NxPhysicsSDK's 
	NX_DEFAULT_SLEEP_LIN_VEL_SQUARED parameter.

	Setting the sleep angular/linear velocity only makes sense when the NX_BF_ENERGY_SLEEP_TEST is not set. In
	version 2.5 and later a new method is used by default which uses the kinetic energy of the body to control
	sleeping.
    
    The actor must be dynamic.

	\param[in] threshold Angular velocity below which an actor may go to sleep. <b>Range:</b> (0,inf]

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

    @see isGroupSleeping() isSleeping() getSleepLinearVelocity() getSleepAngularVelocity() wakeUp() putToSleep() setSleepLinearVelocity() setSleepEnergyThreshold() getSleepEnergyThreshold()

</member>
        <member name="M:NxActor.getSleepAngularVelocity">
	\brief Returns the angular velocity below which an actor may go to sleep.
	
	Actors whose angular velocity is above this threshold will not be put to sleep. 
    
    The actor must be dynamic.

    \return The threshold angular velocity for sleeping.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see isGroupSleeping() isSleeping() getSleepLinearVelocity() getSleepAngularVelocity() wakeUp() putToSleep() setSleepAngularVelocity() setSleepEnergyThreshold() getSleepEnergyThreshold()

</member>
        <member name="M:NxActor.setSleepLinearVelocity(System.Single)">
	\brief Sets the linear velocity below which an actor may go to sleep.
	
	Actors whose linear velocity is above this threshold will not be put to sleep.
	
	If the threshold value is negative,	the velocity threshold is set using the NxPhysicsSDK's 
	NX_DEFAULT_SLEEP_LIN_VEL_SQUARED parameter.
    
	Setting the sleep angular/linear velocity only makes sense when the NX_BF_ENERGY_SLEEP_TEST is not set. In
	version 2.5 and later a new method is used by default which uses the kinetic energy of the body to control
	sleeping.


    The actor must be dynamic.

	\param[in] threshold Linear velocity below which an actor may sleep. <b>Range:</b> (0,inf]

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see isGroupSleeping() isSleeping() getSleepLinearVelocity() getSleepAngularVelocity() wakeUp() putToSleep() setSleepEnergyThreshold() getSleepEnergyThreshold()

</member>
        <member name="M:NxActor.getSleepLinearVelocity">
	\brief Returns the linear velocity below which an actor may go to sleep.
	
	Actors whose linear velocity is above this threshold will not be put to sleep.
    
    The actor must be dynamic.

    @see isSleeping

	\return The threshold linear velocity for sleeping.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see isGroupSleeping() isSleeping() getSleepLinearVelocity() getSleepAngularVelocity() wakeUp() putToSleep() setSleepLinearVelocity() setSleepEnergyThreshold() getSleepEnergyThreshold()

</member>
        <member name="M:NxActor.isSleeping">
	\brief Returns true if this body is sleeping.

	When an actor does not move for a period of time, it is no longer simulated in order to save time. This state
	is called sleeping. However, because the object automatically wakes up when it is either touched by an awake object,
	or one of its properties is changed by the user, the entire sleep mechanism should be transparent to the user.
	
	If an actor is asleep after the call to NxScene::fetchResults() returns, it is guaranteed that the pose of the actor 
	was not changed. You can use this information to avoid updating the transforms of associated of dependent objects.
	
	The actor must be dynamic.

	\return True if the actor is sleeping.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see isGroupSleeping() isSleeping() getSleepLinearVelocity() getSleepAngularVelocity() wakeUp() putToSleep()  getSleepEnergyThreshold()

</member>
        <member name="M:NxActor.isGroupSleeping">
@name Sleeping

	\brief Returns true if this body and all the actors it is touching or is linked to with joints are sleeping.

	When an actor does not move for a period of time, it is no longer simulated in order to save time. This state
	is called sleeping. However, because the object automatically wakes up when it is either touched by an awake object,
	or one of its properties is changed by the user, the entire sleep mechanism should be transparent to the user.
	
	(Note: From version 2.5 this method is identical to isSleeping())
	
	The actor must be dynamic.

	\return True if the actor's group is sleeping.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : No
	\li PS3  : Yes
	\li XB360: Yes

	@see isGroupSleeping() isSleeping() getSleepLinearVelocity() getSleepAngularVelocity() wakeUp() putToSleep() getSleepEnergyThreshold()

</member>
        <member name="M:NxActor.getLocalPointVelocity(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Computes the velocity of a point given in body local coordinates as if it were attached to the 
	actor and moving with it.

	The actor must be dynamic.

	\param[in] point Point we wish to determine the velocity of, defined in the body local frame. <b>Range:</b> position vector
	\return The velocity, in the global frame, of the point.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getPointVelocity() NxBodyDesc.linearVelocity NxBodyDesc.angularVelocity

</member>
        <member name="M:NxActor.getPointVelocity(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Point Velocity

	\brief Computes the velocity of a point given in world coordinates if it were attached to the 
	actor and moving with it.

	The actor must be dynamic.

	\param[in] point Point we wish to determine the velocity for, defined in the global frame. <b>Range:</b> position vector
	\return The velocity of point in the global frame.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getLocalPointVelocity() NxBodyDesc.linearVelocity NxBodyDesc.angularVelocity

</member>
        <member name="M:NxActor.computeKineticEnergy">
	\brief Computes the total kinetic (rotational and translational) energy of the object.

	The actor must be dynamic.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	\return The kinetic energy of the actor.

</member>
        <member name="M:NxActor.addLocalTorque(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxForceMode,System.Boolean)">
	\brief Applies an impulsive torque defined in the actor local coordinate frame to the actor.

	::NxForceMode determines if the torque is to be conventional or impulsive.

	The actor must be dynamic.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping and the wakeup parameter is true (default).

	\param[in] torque Torque to apply defined in the local frame. <b>Range:</b> torque vector
	\param[in] mode The mode to use when applying the force/impulse(see #NxForceMode).
	\param[in] wakeup Specify if the call should wake up the actor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxForceMode addTorque() addForce()

</member>
        <member name="M:NxActor.addTorque(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxForceMode,System.Boolean)">
	\brief Applies an impulsive torque defined in the global coordinate frame to the actor.

	::NxForceMode determines if the torque is to be conventional or impulsive.

	The actor must be dynamic.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping and the wakeup parameter is true (default).

	\param[in] torque Torque to apply defined in the global frame. <b>Range:</b> torque vector
	\param[in] mode The mode to use when applying the force/impulse(see #NxForceMode).
	\param[in] wakeup Specify if the call should wake up the actor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxForceMode addLocalTorque() addForce()

</member>
        <member name="M:NxActor.addLocalForce(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxForceMode,System.Boolean)">
	\brief Applies a force (or impulse) defined in the actor local coordinate frame to the actor.

	<b>This will not induce a torque</b>.

	::NxForceMode determines if the force is to be conventional or impulsive.

	The actor must be dynamic.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping and the wakeup parameter is true (default).

	\param[in] force Force/Impulse to apply defined in the local frame. <b>Range:</b> force vector
	\param[in] mode The mode to use when applying the force/impulse(see #NxForceMode)
	\param[in] wakeup Specify if the call should wake up the actor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxForceMode 
	@see addForceAtPos() addForceAtLocalPos() addLocalForceAtPos() addLocalForceAtLocalPos() addForce()

</member>
        <member name="M:NxActor.addForce(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxForceMode,System.Boolean)">
	\brief Applies a force (or impulse) defined in the global coordinate frame to the actor.

	<b>This will not induce a torque</b>.

	::NxForceMode determines if the force is to be conventional or impulsive.

	The actor must be dynamic.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping and the wakeup parameter is true (default).

	\param[in] force Force/Impulse to apply defined in the global frame. <b>Range:</b> force vector
	\param[in] mode The mode to use when applying the force/impulse(see #NxForceMode)
	\param[in] wakeup Specify if the call should wake up the actor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxForceMode 
	@see addForceAtPos() addForceAtLocalPos() addLocalForceAtPos() addLocalForceAtLocalPos() addLocalForce()

</member>
        <member name="M:NxActor.addLocalForceAtLocalPos(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxForceMode,System.Boolean)">
	\brief Applies a force (or impulse) defined in the actor local coordinate frame, acting at a 
	particular point in local coordinates, to the actor. 

	Note that if the force does not act along the center of mass of the actor, this
	will also add the corresponding torque. Because forces are reset at the end of every timestep, you can maintain a
	total external force on an object by calling this once every frame.

	::NxForceMode determines if the force is to be conventional or impulsive.

	The actor must be dynamic.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping and the wakeup parameter is true (default).

	\param[in] force Force/impulse to add, defined in the local frame. <b>Range:</b> force vector
	\param[in] pos Position in the local frame to add the force at. <b>Range:</b> position vector
	\param[in] mode The mode to use when applying the force/impulse(see #NxForceMode)
	\param[in] wakeup Specify if the call should wake up the actor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxForceMode 
	@see addForceAtPos() addForceAtLocalPos() addLocalForceAtPos() addForce() addLocalForce()

</member>
        <member name="M:NxActor.addLocalForceAtPos(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxForceMode,System.Boolean)">
	\brief Applies a force (or impulse) defined in the actor local coordinate frame, acting at a 
	particular point in global coordinates, to the actor. 

	Note that if the force does not act along the center of mass of the actor, this
	will also add the corresponding torque. Because forces are reset at the end of every timestep, you can maintain a
	total external force on an object by calling this once every frame.

	::NxForceMode determines if the force is to be conventional or impulsive.

	The actor must be dynamic.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping and the wakeup parameter is true (default).

	\param[in] force Force/impulse to add, defined in the local frame. <b>Range:</b> force vector
	\param[in] pos Position in the global frame to add the force at. <b>Range:</b> position vector
	\param[in] mode The mode to use when applying the force/impulse(see #NxForceMode)
	\param[in] wakeup Specify if the call should wake up the actor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxForceMode 
	@see addForceAtPos() addForceAtLocalPos() addLocalForceAtLocalPos() addForce() addLocalForce()

</member>
        <member name="M:NxActor.addForceAtLocalPos(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxForceMode,System.Boolean)">
	\brief Applies a force (or impulse) defined in the global coordinate frame, acting at a particular 
	point in local coordinates, to the actor. 

	Note that if the force does not act along the center of mass of the actor, this
	will also add the corresponding torque. Because forces are reset at the end of every timestep, you can maintain a
	total external force on an object by calling this once every frame.

	::NxForceMode determines if the force is to be conventional or impulsive.

	The actor must be dynamic.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping and the wakeup parameter is true (default).

	\param[in] force Force/impulse to add, defined in the global frame. <b>Range:</b> force vector
	\param[in] pos Position in the local frame to add the force at. <b>Range:</b> position vector
	\param[in] mode The mode to use when applying the force/impulse(see #NxForceMode)
	\param[in] wakeup Specify if the call should wake up the actor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxForceMode 
	@see addForceAtPos() addLocalForceAtPos() addLocalForceAtLocalPos() addForce() addLocalForce()

</member>
        <member name="M:NxActor.addForceAtPos(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxForceMode,System.Boolean)">
@name Forces

	\brief Applies a force (or impulse) defined in the global coordinate frame, acting at a particular 
	point in global coordinates, to the actor. 

	Note that if the force does not act along the center of mass of the actor, this
	will also add the corresponding torque. Because forces are reset at the end of every timestep, 
	you can maintain a total external force on an object by calling this once every frame.

    ::NxForceMode determines if the force is to be conventional or impulsive.

	The actor must be dynamic.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping and the wakeup parameter is true (default).

	\param[in] force Force/impulse to add, defined in the global frame. <b>Range:</b> force vector
	\param[in] pos Position in the global frame to add the force at. <b>Range:</b> position vector
	\param[in] mode The mode to use when applying the force/impulse(see #NxForceMode)
	\param[in] wakeup Specify if the call should wake up the actor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxForceMode 
	@see addForceAtLocalPos() addLocalForceAtPos() addLocalForceAtLocalPos() addForce() addLocalForce()

</member>
        <member name="M:NxActor.getAngularMomentum">
	\brief Retrieves the angular momentum of an actor.
	
	The angular momentum is equal to the angular velocity times the global space inertia tensor.

	The actor must be dynamic.

	\return The angular momentum for the actor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setAngularMomentum() getLinearMomentum() 

</member>
        <member name="M:NxActor.getLinearMomentum">
	\brief Retrieves the linear momentum of an actor.
	
	The momentum is equal to the velocity times the mass.

	The actor must be dynamic.

	\return The linear momentum for the actor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setLinearMomentum() getAngularMomentum()

</member>
        <member name="M:NxActor.setAngularMomentum(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the angular momentum of the actor.
	
	Note that if you continuously set the angular velocity of an actor yourself, 
	forces such as friction will not be able to rotate the actor, because forces directly
	influence only the velocity of actor.

	The actor must be dynamic.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] angMoment New angular momentum. <b>Range:</b> angular momentum vector

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getAngularMomentum() setLinearMomentum() 

</member>
        <member name="M:NxActor.setLinearMomentum(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Momentum

	\brief Sets the linear momentum of the actor. 
	
	Note that if you continuously set the linear momentum of an actor yourself, 
	forces such as gravity or friction will not be able to manifest themselves, because forces directly
	influence only the velocity/momentum of a actor.

	The actor must be dynamic.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] linMoment New linear momentum. <b>Range:</b> momentum vector

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getLinearMomentum() setAngularMomentum()

</member>
        <member name="M:NxActor.getCCDMotionThreshold">
	\brief Retrieves the CCD Motion threshold for this actor.

	The actor must be dynamic.

	\return The CCD threshold for the actor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setCCDMotionThreshold NxParameter

</member>
        <member name="M:NxActor.setCCDMotionThreshold(System.Single)">
@name CCD

	\brief Sets the CCD Motion Threshold.
	
	If CCD is globally enabled (parameter NX_CONTINUOUS_CD), it is still skipped for bodies
	which have no point on any of their shapes moving more than CCDMotionThreshold distance in 
	one time step.  
	
	Hence, CCD is always performed if the threshold is 0.

	The actor must be dynamic and the CCD motion threshold must be non-negative.

	<h3>Visualizations:</h3>
	\li #NX_VISUALIZE_COLLISION_CCD
	\li #NX_VISUALIZE_COLLISION_SKELETONS

	\param[in] thresh CCD Motion threshold. <b>Range:</b> [0,inf)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getCCDMotionThreshold NxParameter

</member>
        <member name="M:NxActor.getMaxAngularVelocity">
	\brief Retrieves the maximum angular velocity permitted for this actor.

	The actor must be dynamic.

	\return The maximum allowed angular velocity for this actor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setMaxAngularVelocity NxBodyDesc.maxAngularVelocity

</member>
        <member name="M:NxActor.setMaxAngularVelocity(System.Single)">
	\brief Lets you set the maximum angular velocity permitted for this actor.
	
	Because for various internal computations, very quickly rotating actors introduce error 
	into the simulation, which leads to undesired results.

	With NxPhysicsSDK::setParameter(NX_MAX_ANGULAR_VELOCITY) you can set the default maximum velocity for actors created
	after the call. Bodies' high angular velocities are clamped to this value. 

	However, because some actors, such as car wheels, should be able to rotate quickly, you can override the default setting
	on a per-actor basis with the below call. Note that objects such as wheels which are approximated with spherical or 
	other smooth collision primitives can be simulated with stability at a much higher angular velocity than, say, a box that
	has corners.

	Note: The angular velocity is clamped to the set value <i>before</i> the solver, which means that
	the limit may still be momentarily exceeded.

	The actor must be dynamic.

	\param[in] maxAngVel Max allowable angular velocity for actor. <b>Range:</b> (0,inf)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getMaxAngularVelocity() NxBodyDesc.maxAngularVelocity

</member>
        <member name="M:NxActor.getAngularVelocity">
	\brief Retrieves the angular velocity of the actor.

	The actor must be dynamic.

	\return The angular velocity of the actor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setAngularVelocity() getLinearVelocity() NxBodyDesc.angularVelocity

</member>
        <member name="M:NxActor.getLinearVelocity">
	\brief Retrieves the linear velocity of an actor.

	The actor must be dynamic.

	\return The linear velocity of the actor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setLinearVelocity() getAngularVelocity() NxBodyDesc.linearVelocity

</member>
        <member name="M:NxActor.setAngularVelocity(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the angular velocity of the actor.
	
	Note that if you continuously set the angular velocity of an actor yourself, 
	forces such as friction will not be able to rotate the actor, because forces directly influence only the velocity/momentum.

	The actor must be dynamic.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] angVel New angular velocity of actor. <b>Range:</b> angular velocity vector

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getAngularVelocity() setLinearVelocity() NxBodyDesc.angularVelocity

</member>
        <member name="M:NxActor.setLinearVelocity(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Velocity

	\brief Sets the linear velocity of the actor.
	
	Note that if you continuously set the velocity of an actor yourself, 
	forces such as gravity or friction will not be able to manifest themselves, because forces directly
	influence only the velocity/momentum of an actor.

	The actor must be dynamic.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] linVel New linear velocity of actor. <b>Range:</b> velocity vector

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getLinearVelocity() setAngularVelocity() NxBodyDesc.linearVelocity

</member>
        <member name="M:NxActor.getAngularDamping">
	\brief Retrieves the angular damping coefficient.

	The actor must be dynamic.

	\return The angular damping coefficient associated with this actor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setAngularDamping() NxBodyDesc.angularDamping getLinearDamping()

</member>
        <member name="M:NxActor.setAngularDamping(System.Single)">
	\brief Sets the angular damping coefficient.
	
	Zero represents no damping.
	
	The angular damping coefficient must be nonnegative.
	
	The actor must be dynamic.

	<b>Default:</b> 0.05

	\param[in] angDamp Angular damping coefficient. <b>Range:</b> [0,inf)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getAngularDamping() NxBodyDesc.angularDamping setLinearDamping()

</member>
        <member name="M:NxActor.getLinearDamping">
	\brief Retrieves the linear damping coefficient.

	The actor must be dynamic.

	\return The linear damping coefficient associated with this actor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setLinearDamping() getAngularDamping() NxBodyDesc.linearDamping

</member>
        <member name="M:NxActor.setLinearDamping(System.Single)">
@name Damping

	\brief Sets the linear damping coefficient.
	
	Zero represents no damping. The damping coefficient must be nonnegative.
	
	The actor must be dynamic.

	<b>Default:</b> 0.
	
	\param[in] linDamp Linear damping coefficient. <b>Range:</b> [0,inf)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getLinearDamping() setAngularDamping() NxBodyDesc.linearDamping

</member>
        <member name="M:NxActor.updateMassFromShapes(System.Single,System.Single)">
	\brief Recomputes a dynamic actor's mass properties from its shapes

	Given a constant density or total mass, the actors mass properties can be recomputed
	using the shapes attached to the actor. If the actor has no shapes, then only the totalMass
	parameter can be used. If all shapes in the actor are trigger shapes (non-physical), the call
	will fail.

	The mass of each shape is either the shape's local density (as specified in the #NxShapeDesc; default 1.0) 
	multiplied by the shape's volume or a directly specified shape mass. 

	The inertia tensor, mass frame and center of mass will always be recomputed. If there are no
	shapes in the actor, the mass will be totalMass, and the mass frame will be set to the center
	of the actor.

	If you supply a non-zero total mass, the actor's mass and inertia will first be computed as
	above and then scaled to fit this total mass.

	If you supply a non-zero density, the actor's mass and inertia will first be computed as above
	and then scaled by this factor.

	Either totalMass or density must be non-zero.

	The actor must be dynamic.

	\param[in] density Density scale factor of the shapes belonging to the actor. <b>Range:</b> [0,inf)
	\param[in] totalMass Total mass of the actor(or zero). <b>Range:</b> [0,inf)

	\return True if successful.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxActorDesc NxBodyDesc NxBodyDesc.mass NxActorDesc.density NxActorDesc.lockCOM

</member>
        <member name="M:NxActor.getGlobalInertiaTensorInverse">
	\brief Retrieves the inverse of the inertia tensor of the actor relative to the world coordinate frame.

	The actor must be dynamic.

	\return The inverse of the inertia tensor in the global frame.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getGlobalInertiaTensor() NxBodyDesc.massSpaceInertia setMassSpaceInertiaTensor()

</member>
        <member name="M:NxActor.getGlobalInertiaTensor">
	\brief Retrieves the inertia tensor of the actor relative to the world coordinate frame.

	The actor must be dynamic.

	\return The global frame inertia tensor of this actor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getGlobalInertiaTensorInverse() NxBodyDesc.massSpaceInertia setMassSpaceInertiaTensor()

</member>
        <member name="M:NxActor.getMassSpaceInertiaTensor">
	\brief  Retrieves the diagonal inertia tensor of the actor relative to the mass coordinate frame.

	This method retrieves a mass frame inertia vector. If you want a global frame inertia tensor(3x3 matrix),
	then see #getGlobalInertiaTensor().

	The actor must be dynamic.

	\return The mass space inertia tensor of this actor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBodyDesc.massSpaceInertia setMassSpaceInertiaTensor() setMass() CMassOffsetLocalPose()

</member>
        <member name="M:NxActor.setMassSpaceInertiaTensor(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the inertia tensor, using a parameter specified in mass space coordinates.
	
	Note that such matrices are diagonal -- the passed vector is the diagonal.

	If you have a non diagonal world/actor space inertia tensor(3x3 matrix). Then you need to
	diagonalize it and set an appropriate mass space transform. See #setCMassOffsetLocalPose().
	
	The actor must be dynamic.

	<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.

	\param[in] m New mass space inertia tensor for the actor. <b>Range:</b> inertia vector

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBodyDesc.massSpaceInertia getMassSpaceInertia() setMass() setCMassOffsetLocalPose()

</member>
        <member name="M:NxActor.getMass">
	\brief Retrieves the mass of the actor.
	
	Static actors will always return 0.

	\return The mass of this actor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setMass() NxBodyDesc.mass setMassSpaceInertiaTensor()

</member>
        <member name="M:NxActor.setMass(System.Single)">
	\brief Sets the mass of a dynamic actor.
	
	The mass must be positive and the actor must be dynamic.
	
	setMass() does not update the inertial properties of the body, to change the inertia tensor
	use setMassSpaceInertiaTensor() or updateMassFromShapes().

	<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.

	\param[in] mass New mass value for the actor. <b>Range:</b> (0,inf)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getMass() NxBodyDesc.mass setMassSpaceInertiaTensor() updateMassFromShapes()

</member>
        <member name="M:NxActor.getCMassGlobalOrientation">
	\brief The getCMassGlobal*() methods retrieve the center of mass pose in world space.

	The actor must be dynamic.

	\return The orientation of the mass frame relative to the global frame.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getCMassGlobalPose() getCMassGlobalPosition() getCMassLocalPose()
	@see NxBodyDesc.massLocalPose

</member>
        <member name="M:NxActor.getCMassGlobalPosition">
	\brief The getCMassGlobal*() methods retrieve the center of mass pose in world space.

	The actor must be dynamic.

	\return The position of the center of mass relative to the global frame.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getCMassGlobalPose() getCMassGlobalOrientation() getCMassLocalPose()
	@see NxBodyDesc.massLocalPose

</member>
        <member name="M:NxActor.getCMassGlobalPose">
	\brief The getCMassGlobal*() methods retrieve the center of mass pose in world space.

	The actor must be dynamic.

	\return The Mass transform for this actor relative to the global frame.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getCMassGlobalPosition() getCMassGlobalOrientation() getCMassLocalPose()
	@see NxBodyDesc.massLocalPose

</member>
        <member name="M:NxActor.getCMassLocalOrientation">
	\brief The getCMassLocal*() methods retrieve the center of mass pose relative to the actor.

	The actor must be dynamic.

	\return The mass orientation relative to the actors frame.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getCMassLocalPose() getCMassLocalPosition() getCMassGlobalPose()
	@see NxBodyDesc.massLocalPose

</member>
        <member name="M:NxActor.getCMassLocalPosition">
	\brief The getCMassLocal*() methods retrieve the center of mass pose relative to the actor.

	The actor must be dynamic.

	\return The center of mass position relative to the actor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getCMassLocalPose() getCMassLocalOrientation() getCMassGlobalPose()
	@see NxBodyDesc.massLocalPose

</member>
        <member name="M:NxActor.getCMassLocalPose">
	\brief The getCMassLocal*() methods retrieve the center of mass pose relative to the actor.

	The actor must be dynamic.

	\return The center of mass pose relative to the actor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getCMassLocalPosition() getCMassLocalOrientation() getCMassGlobalPose()
	@see NxBodyDesc.massLocalPose

</member>
        <member name="M:NxActor.setCMassGlobalOrientation(NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief The setCMassGlobal*() methods move the actor by setting the pose of the center of mass.

	See ::setCMassGlobalPose() for more information.

	The actor must be dynamic.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] mat Actors new orientation, from the transformation of the mass frame to the global frame. <b>Range:</b> rotation matrix.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setCMassGlobalPose() setCMassGlobalPosition() getCMassLocalPose()
	@see NxBodyDesc.massLocalPose

</member>
        <member name="M:NxActor.setCMassGlobalPosition(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief The setCMassGlobal*() methods move the actor by setting the pose of the center of mass.

	See ::setCMassGlobalPose() for more information.

	The actor must be dynamic.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] vec Actors new position, from the transformation of the mass frame to the global frame. <b>Range:</b> position vector

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setCMassGlobalPose() setCMassGlobalOrientation() getCMassLocalPose()
	@see NxBodyDesc.massLocalPose

</member>
        <member name="M:NxActor.setCMassGlobalPose(NxMat34!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief The setCMassGlobal*() methods move the actor by setting the pose of the center of mass.

	Here the transform between the center of mass and the actor frame is held fixed and the actor
	to world transform is updated.
	
	The actor must be dynamic.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] mat Actors new pose, from the transformation of the mass frame to the global frame. <b>Range:</b> rigid body transform.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setCMassGlobalPosition() setCMassGlobalOrientation() getCMassLocalPose()
	@see NxBodyDesc.massLocalPose

</member>
        <member name="M:NxActor.setCMassOffsetGlobalOrientation(NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief The setCMassOffsetGlobal*() methods set the pose of the center of mass relative to world space.

	See ::setCMassOffsetGlobalPose() for more information.

	The actor must be dynamic.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] mat Mass frame orientation offset relative to the global frame. <b>Range:</b> rotation matrix.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setCMassOffsetGlobalPose() setCMassOffsetGlobalPosition() 
	@see NxBodyDesc.massLocalPose

</member>
        <member name="M:NxActor.setCMassOffsetGlobalPosition(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief The setCMassOffsetGlobal*() methods set the pose of the center of mass relative to world space.

	See ::setCMassOffsetGlobalPose() for more information.

	\note Setting an unrealistic center of mass which is a long way from the body can make it difficult for
	the SDK to solve constraints. Perhaps leading to instability and jittering bodies.

	The actor must be dynamic.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] vec Mass frame offset relative to the global frame. <b>Range:</b> position vector

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setCMassOffsetGlobalPose() setCMassOffsetGlobalOrientation()
	@see NxBodyDesc.massLocalPose

</member>
        <member name="M:NxActor.setCMassOffsetGlobalPose(NxMat34!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief The setCMassOffsetGlobal*() methods set the pose of the center of mass relative to world space.

	Note that this will simply transform the parameter to actor space and then call 
	setCMassLocal*(). In other words it only shifts the center of mass but does not move the actor.
	
	The actor must be dynamic.

	\note Setting an unrealistic center of mass which is a long way from the body can make it difficult for
	the SDK to solve constraints. Perhaps leading to instability and jittering bodies.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] mat Mass frame offset transform relative to the global frame. <b>Range:</b> rigid body transform.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setCMassOffsetGlobalPosition() setCMassOffsetGlobalOrientation()
	@see NxBodyDesc.massLocalPose

</member>
        <member name="M:NxActor.setCMassOffsetLocalOrientation(NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief The setCMassOffsetLocal*() methods set the pose of the center of mass relative to the actor.

	See ::setCMassOffsetLocalPose() for more information.

	The actor must be dynamic.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] mat Mass frame orientation offset relative to the actor frame. <b>Range:</b> rotation matrix.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setCMassOffsetLocalPose() setCMassOffsetLocalPosition() setCMassOffsetGlobalPose()
	@see NxBodyDesc.massLocalPose

</member>
        <member name="M:NxActor.setCMassOffsetLocalPosition(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief The setCMassOffsetLocal*() methods set the pose of the center of mass relative to the actor.

	See ::setCMassOffsetLocalPose() for more information.

	\note Setting an unrealistic center of mass which is a long way from the body can make it difficult for
	the SDK to solve constraints. Perhaps leading to instability and jittering bodies.

	The actor must be dynamic.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] vec Mass frame offset relative to the actor frame. <b>Range:</b> position vector

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setCMassOffsetLocalPose() setCMassOffsetLocalOrientation() setCMassOffsetGlobalPose()
	@see NxBodyDesc.massLocalPose

</member>
        <member name="M:NxActor.setCMassOffsetLocalPose(NxMat34!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Mass Manipulation

	\brief The setCMassOffsetLocal*() methods set the pose of the center of mass relative to the actor.	
	
	Methods that automatically compute the center of mass such as updateMassFromShapes() as well as computing
	the mass and inertia using the actors shapes, will set this pose automatically.
	
	The actor must be dynamic.

	\note Changing this transform will not move the actor in the world!

	\note Setting an unrealistic center of mass which is a long way from the body can make it difficult for
	the SDK to solve constraints. Perhaps leading to instability and jittering bodies.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] mat Mass  frame offset transform relative to the actor frame. <b>Range:</b> rigid body transform.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setCMassOffsetLocalPosition() setCMassOffsetLocalOrientation() setCMassOffsetGlobalPose()
	@see NxBodyDesc.massLocalPose

</member>
        <member name="M:NxActor.isDynamic">
	\brief Returns true if the actor is dynamic.

	\return True if this is a dynamic actor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBodyDesc

</member>
        <member name="M:NxActor.resetUserActorPairFiltering">
\brief Reset the user actor pair filtering state for this actor. This will cause filtering
callbacks to be called again for any pairs involving this actor. Use this method
when you wish to change the filtering policy of an actor that may already be in contact
with other actors.

@see NxUserActorPairFiltering

</member>
        <member name="M:NxActor.readActorFlag(NxActorFlag)">
	\brief Reads a particular actor flag.
	
	See the list of flags #NxActorFlag

	\param[in] actorFlag The actor flag to retrieve. See #NxActorFlag. 

	\return The value of the actor flag.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxActorFlag raiseActorFlag() clearActorFlag() NxActorDesc.flags

</member>
        <member name="M:NxActor.clearActorFlag(NxActorFlag)">
	\brief Clears a particular actor flag.
	
	See the list of flags #NxActorFlag

	<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.

	\param[in] actorFlag The actor flag to clear. See #NxActorFlag.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxActorFlag raiseActorFlag() readActorFlag() NxActorDesc.flags

</member>
        <member name="M:NxActor.raiseActorFlag(NxActorFlag)">
	\brief Raises a particular actor flag.
	
	See the list of flags #NxActorFlag

	<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.

	\param[in] actorFlag The actor flag to raise(set). See #NxActorFlag.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxActorFlag clearActorFlag() readActorFlag() NxActorDesc.flags

</member>
        <member name="M:NxActor.getDominanceGroup">
	\brief Retrieves the value set with setDominanceGroup().

	\return The dominance group of this actor.

	@see setDominanceGroup() NxDominanceGroup NxScene::setDominanceGroupPair()

</member>
        <member name="M:NxActor.setDominanceGroup(System.UInt16)">
	\brief Assigns dynamic actors a dominance group identifier.
	
	NxDominanceGroup is a 5 bit group identifier (legal range from 0 to 31).

	This is similar to #NxShape groups, except those serve a different purpose.
	
	The NxScene::setDominanceGroupPair() lets you set certain behaviors for pairs of dominance groups.
	By default every actor is created in group 0.  Static actors must stay in group 0; thus you can only 
	call this on dynamic actors.

	<b>Sleeping:</b> Changing the dominance group does <b>NOT</b> wake the actor up automatically.

	@see getDominanceGroup() NxDominanceGroup NxScene::setDominanceGroupPair()

</member>
        <member name="M:NxActor.getGroup">
	\brief Retrieves the value set with setGroup().

	\return The group ID of this actor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : No
	\li PS3  : Yes
	\li XB360: Yes

	@see setGroup() NxActorGroup

</member>
        <member name="M:NxActor.setGroup(System.UInt16)">
	\brief Assigns the actor to a user defined group of actors.
	
	NxActorGroup is a 16 bit group identifier.

	This is similar to #NxShape groups, except those are only five bits and serve a different purpose.
	
	The NxScene::setActorGroupPairFlags() lets you set certain behaviors for pairs of actor groups.
	By default every actor is created in group 0.

	<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.

	\param[in] actorGroup The actor group flags.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : No
	\li PS3  : Yes
	\li XB360: Yes

	@see getGroup() NxActorGroup

</member>
        <member name="M:NxActor.getShapes">
	\brief Returns an array of shape pointers belonging to the actor.

	These are the shapes used by the actor for collision detection.

	You can retrieve the number of shape pointers by calling #getNbShapes()

	Note: Adding or removing shapes with #createShape() or #releaseShape() will invalidate the pointer.

	\return Array of shapes which are associated with this actor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShape getNbShapes() createShape() releaseShape()

</member>
        <member name="M:NxActor.getNbShapes">
	\brief Returns the number of shapes assigned to the actor.

	You can use #getShapes() to retrieve an array of shape pointers.

	For static actors it is not possible to release all actors associated with the shape.
	An attempt to remove the last shape will be ignored.

	\return Number of shapes associated with this actor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShape getShapes()

</member>
        <member name="M:NxActor.releaseShape(NxShape*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Deletes the specified shape.
	
	This invalidates the pointer returned by getShapes().
	Avoid release calls while the scene is simulating (in between simulate() and fetchResults() calls).
	Note that mass properties for the actor are unchanged by this call unless #updateMassFromShapes is also called.

	<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.

	\param[in] shape Shape to be released.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShape
	@see NxBoxShape NxCapsuleShape NxConvexShape NxPlaneShape NxSphereShape NxTriangleMeshShape NxWheelShape

</member>
        <member name="M:NxActor.createShape(NxShapeDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Shapes

	\brief Creates a new shape and adds it to the list of shapes of this actor.
	
	This invalidates the pointer returned by getShapes().

	\note Mass properties of dynamic actors will not automatically be recomputed
	to reflect the new mass distribution implied by the shape. Follow 
	this call with a call to updateMassFromShapes() to do that.

	\note Creating compounds with a very large number of shapes may adversly affect performance and stability.
	When performing collision tests between a pair of actors containing multiple shapes, a collision check is
	performed between each pair of shapes. This results in N^2 running time.

	<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.

	Only a subset of the shape types are supported in hardware scenes (others will fall back to running in software):-

	Fluids:

	\li Compounds are supported
	\li #NxBoxShape
	\li #NxCapsuleShape
	\li #NxSphereShape
	\li #NxConvexShape

	Hardware Rigid bodies:

	\li Compounds are supported
	\li #NxBoxShape
	\li #NxSphereShape
	\li #NxCapsuleShape
	\li #NxConvexShape (software fallback for &gt; 32 vertices or faces)
	\li #NxTriangleMeshShape
	\li #NxPlaneShape

	In addition mesh pages must be mapped into PPU memory for hardware scenes. No collision detection will be performed
	with portions of the mesh which have not been mapped to PPU memory. See #NxTriangleMeshShape.mapPageInstance()

	\param[in] desc The descriptor for the new shape. See e.g. #NxSphereShapeDesc.
	\return The newly create shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback in some cases)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShape NxShapeDesc
	@see NxBoxShape NxCapsuleShape NxConvexShape NxPlaneShape NxSphereShape NxTriangleMeshShape NxWheelShape

</member>
        <member name="M:NxActor.moveGlobalOrientationQuat(NxQuat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief The moveGlobal* calls serve to move kinematically controlled dynamic actors through the game world.

	See ::moveGlobalPose() for more information.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] quat The desired orientation quaternion for the kinematic actor, in the global frame.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see moveGlobalPosition() moveGlobalPose() NxBodyFlag raiseBodyFlag() NxBodyDesc.flags

</member>
        <member name="M:NxActor.moveGlobalOrientation(NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief The moveGlobal* calls serve to move kinematically controlled dynamic actors through the game world.

	See ::moveGlobalPose() for more information.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] mat The desired orientation for the kinematic actor, in the global frame. <b>Range:</b> rotation matrix.

	\note Although it is possible to only specify the orientation, it might be needed to also specify the body position, using moveGlobalPosition(). 
	If you don't do this, the actor position can start to drift, because of numerical imprecision.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see moveGlobalOrientationQuat() moveGlobalPosition() moveGlobalPose() NxBodyFlag raiseBodyFlag() NxBodyDesc.flags

</member>
        <member name="M:NxActor.moveGlobalPosition(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief The moveGlobal* calls serve to move kinematically controlled dynamic actors through the game world.

	See ::moveGlobalPose() for more information.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] vec The desired position for the kinematic actor, in the global frame. <b>Range:</b> position vector

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see moveGlobalPose() moveGlobalOrientation() moveGlobalOrientationQuat() NxBodyFlag raiseBodyFlag() NxBodyDesc.flags

</member>
        <member name="M:NxActor.moveGlobalPose(NxMat34!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Kinematic Actors

	\brief The moveGlobal* calls serve to move kinematically controlled dynamic actors through the game world.

	You set a dynamic actor to be kinematic using the NX_BF_KINEMATIC body flag,
	used either in the NxBodyDesc or with raiseBodyFlag().
	
	The move command will result in a velocity that, when successfully carried 
	out (i.e. the motion is not blocked due to joints or collisions) inside run*(),
	will move the body into the desired pose. After the move is carried out during
	a single time step, the velocity is returned to zero. Thus, you must
	continuously call this in every time step for kinematic actors so that they 
	move along a path.

	These functions simply store the move destination until run*() is called,
	so consecutive calls will simply overwrite the stored target variable.

	Note that in the future we will provide a mechanism for the motion to be blocked
	in certain cases (such as when a box jams in an automatic door), but currently
	the motion is always fully carried out.	

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] mat The desired pose for the kinematic actor, in the global frame. <b>Range:</b> rigid body transform.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see moveGlobalPosition() moveGlobalOrientation() moveGlobalOrientationQuat() NxBodyFlag raiseBodyFlag() NxBodyDesc.flags

</member>
        <member name="M:NxActor.getGlobalOrientationQuat">
	\brief Retrieves the actors world space orientation.

	The getGlobal*() methods retrieve the actor's current actor space to world space transformation.

	\return Global orientation of the actor as a quaternion.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getGlobalOrientation() setGlobalOrientation() getGlobalPose() getGlobalPosition()

</member>
        <member name="M:NxActor.getGlobalOrientation">
	\brief Retrieves the actors world space orientation.

	The getGlobal*() methods retrieve the actor's current actor space to world space transformation.

	\return Global orientation of object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getGlobalOrientationQuat() setGlobalOrientation() getGlobalPose() getGlobalPosition()

</member>
        <member name="M:NxActor.getGlobalPosition">
	\brief Retrieves the actors world space position.

	The getGlobal*() methods retrieve the actor's current actor space to world space transformation.

	\return Global position of object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setGlobalPosition() getGlobalPose() getGlobalOrientation()

</member>
        <member name="M:NxActor.getGlobalPose">
	\brief Retrieves the actors world space transform.

	The getGlobal*() methods retrieve the actor's current actor space to world space transformation.

	\return Global pose matrix of object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setGlobalPose() getGlobalPosition() getGlobalOrientation()

</member>
        <member name="M:NxActor.setGlobalOrientationQuat(NxQuat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets a dynamic actor's orientation in the world.

	see ::setGlobalPose() for information.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] mat New orientation for the actors frame.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setGlobalOrientation() getGlobalOrientation() setGlobalPose()

</member>
        <member name="M:NxActor.setGlobalOrientation(NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets a dynamic actor's orientation in the world.

	see ::setGlobalPose() for information.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] mat New orientation for the actors frame. <b>Range:</b> rotation matrix.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setGlobalPose() setGlobalPosition() getGlobalOrientation() setGlobalOrientationQuat()

</member>
        <member name="M:NxActor.setGlobalPosition(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets a dynamic actor's position in the world.

	see ::setGlobalPose() for information.

	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] vec New position for the actors frame relative to the global frame. <b>Range:</b> position vector

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setGlobalPose() setGlobalOrientation() getGlobalPosition()

</member>
        <member name="M:NxActor.setGlobalPose(NxMat34!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Global Pose Manipulation

	\brief Methods for setting a dynamic actor's pose in the world.

	These methods instantaneously change the actor space to world space transformation. 

	One should exercise restraint in making use of these methods. 

	Static actors should not be moved at all. There are various internal data structures for static actors
	which may need to be recomputed when one moves. Also, moving static actors will not interact correctly
	with dynamic actors or joints. If you would like to directly control an actor's position and would like to 
	have it correctly interact with dynamic bodies and joints, you should create a dynamic body with the 
	NX_BF_KINEMATIC flag, and then use the moveGlobal*() commands to move it along a path!

	When briefly moving dynamic actors, one should not:
	
	\li Move actors into other actors, thus causing interpenetration (an invalid physical state)
	
	\li Move an actor  that is connected by a joint to another away from the other (thus causing joint error)

	\li When moving jointed actors the joints' cached transform information is destroyed and recreated next frame;
	thus this call is expensive for jointed actors.
	
	setGlobalPose(m) has the same effect as calling	
	setGlobalOrientation(m.M);	and setGlobalPosition(m.t); 
	but setGlobalPose() may be faster as it doesn't recompute some internal values twice.
	
	<b>Sleeping:</b> This call wakes the actor if it is sleeping.

	\param[in] mat Transformation from the actors local frame to the global frame. <b>Range:</b> rigid body transform.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getGlobalPose() setGlobalPosition() setGlobalOrientation() getGlobalPose()

</member>
        <member name="M:NxActor.getName">
	\brief Retrieves the name string set with setName().

	\return Name string associated with object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setName()

</member>
        <member name="M:NxActor.setName(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
	\brief Sets a name string for the object that can be retrieved with getName().
	
	This is for debugging and is not used by the SDK. The string is not copied by the SDK, 
	only the pointer is stored.

	\param[in] name String to set the objects name to.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getName()

</member>
        <member name="M:NxActor.saveToDesc(NxActorDescBase*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Saves the state of the actor to the passed descriptor.

	This method does not save out any shapes belonging to the actor to the descriptor's
	shape vector, nor does it write to its body member. You have to iterate through
	the shapes of the actor and save them manually. In addition for dynamic actors you 
	have to call the #saveBodyToDesc() method.

	\param[out] desc	Descriptor to save object state to.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxActorDesc NxActorDescBase

</member>
        <member name="M:NxActor.getScene">
	\brief Retrieves the scene which this actor belongs to.

	\return Owner Scene.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxScene

</member>
        <member name="M:NxActorDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return True if the current settings are valid

</member>
        <member name="M:NxActorDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxActorDesc.#ctor">
\brief constructor sets to default.

</member>
        <member name="F:NxActorDesc.shapes">
	\brief Shapes composing the actor.

	Shapes should always be specified for static actors during creation. However it is optional for dynamic actors.

	See #NxActor.createShape() for additional notes and limitations.

	<b>Default:</b> empty

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes 
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxActorDescBase.#ctor">
\brief constructor sets to default.

</member>
        <member name="M:NxActorDescBase.getType">
	\brief Retrieve the actor type.

	\return The actor desc type. See #NxActorDescType

</member>
        <member name="M:NxActorDescBase.isValid">
	\brief Returns true if the descriptor is valid.

	\return True if the current settings are valid

</member>
        <member name="M:NxActorDescBase.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="F:NxActorDescBase.compartment">
	\brief The compartment to place the actor in. Must be either a pointer to an NxCompartment of type NX_SCT_RIGIDBODY, or NULL.
	A NULL compartment means creating the actor in the scene proper.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	<b>Default:</b> NULL

</member>
        <member name="F:NxActorDescBase.name">
	\brief Possible debug name. The string is not copied by the SDK, only the pointer is stored.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	<b>Default:</b> NULL

</member>
        <member name="F:NxActorDescBase.userData">
	\brief Will be copied to NxActor::userData

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxActor.userData

</member>
        <member name="F:NxActorDescBase.forceFieldMaterial">
	\brief Force Field Material Index, index != 0 has to be created.

	<b>Default:</b> 0

</member>
        <member name="F:NxActorDescBase.contactReportFlags">
	\brief Combination of ::NxContactPairFlag flags

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxActor::setContactReportFlags()

</member>
        <member name="F:NxActorDescBase.dominanceGroup">
	\brief Dominance group for this actor.
	
	NxDominanceGroup is a 5 bit group identifier (legal range from 0 to 31).
	The NxScene::setDominanceGroupPair() lets you set certain behaviors for pairs of dominance groups.
	By default every actor is created in group 0.  Static actors must stay in group 0.

	<b>Default:</b> 0

</member>
        <member name="F:NxActorDescBase.group">
	\brief The actors group.

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxActor::setGroup()

</member>
        <member name="F:NxActorDescBase.flags">
	\brief Combination of ::NxActorFlag flags

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxActor::raiseActorFlag()

</member>
        <member name="F:NxActorDescBase.body">
	\brief Body descriptor, null for static actors

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBodyDesc

</member>
        <member name="T:NxActorDescBase">
	\brief Actor Descriptor. This structure is used to save and load the state of #NxActor objects.

	If the body descriptor contains a zero mass but the actor descriptor contains a non-zero density,
	we compute a new mass automatically from the density and the shapes.

	Static or dynamic actors:

	\li To create a static actor, use a null body descriptor pointer(and not a body with zero mass). Shapes should
	be specified for the static actor when it is created.
	If you want to create a temporarily static actor that can be made dynamic at runtime, create your
    dynamic actor as usual and use NX_BF_KINEMATIC flags in its body descriptor.

	\li To create a dynamic actor, provide a valid body descriptor with or without shape descriptors. The
	  shapes are not mandatory.

	Mass or density:
	
		To simulate a dynamic actor, the SDK needs a mass and an inertia tensor. 
		(The inertia tensor is the combination of bodyDesc.massLocalPose and bodyDesc.massSpaceInertia)

		These can be specified in several different ways:

		1) actorDesc.density == 0,  bodyDesc.mass &gt; 0, bodyDesc.massSpaceInertia.magnitude() &gt; 0

			Here the mass properties are specified explicitly, there is nothing to compute.

		2) actorDesc.density &gt; 0,	actorDesc.shapes.size() &gt; 0, bodyDesc.mass == 0, bodyDesc.massSpaceInertia.magnitude() == 0

			Here a density and the shapes are given. From this both the mass and the inertia tensor is computed.

		3) actorDesc.density == 0,	actorDesc.shapes.size() &gt; 0, bodyDesc.mass &gt; 0, bodyDesc.massSpaceInertia.magnitude() == 0

			Here a mass and shapes are given. From this the inertia tensor is computed.

		Other combinations of settings are illegal.

		When the SDK computes the inertia properties it uses the actor's shapes.  
		For each shape, the shape geometry, shape mass (or density), and shape positioning within the actor 
		are used to compute the body's mass and inertia properties.  
		
		Setting the individual masses or densities of the shapes of an actor is the most intuitive method
		to specify the mass, center of mass, and inertial properties of a multi	shape actor in order to achieve 
		correct behavior.

		If the actor body has a mass, then the computed inertial properties of the actor are scaled to the specified body mass.  
		Even then, the individual shape masses are still useful since they specify how that mass is distributed within the object.
		i.e. When specified, the actor/body mass properties have priority.

		If you specify a shape density and an actor density then the two are multiplied together to obtain the effective density
		of the actor. So if you set the density of the actor to 2 and the density of the shape to 3 then the effective density 
		of that shape will be 6.

		When the sdk computes the inertial properties the default is to also compute the center of mass.
		To specify an actor's center of mass exactly but still let the SDK compute and diagonalize the inertia 
		tensor raise NxActorDescBase::flags | NX_AF_LOCK_COM.  In this case the center of mass (bodydesc.massLocalPose.t)
		will not be overridden and the computed inertial tensor will be transformed correctly so that
		it will be as if the volume integrals for the moments had been done from the specified point.

		The NX_AF_LOCK_COM is only considered when computing the mass properties during creation, it will
		not be considered when calling NxActor::updateMassFromShapes().

	You should not use the NxActorDescBase class directly, instead use one of the derived classes,
	NxActorDesc or NxActorDesc_Template.

</member>
        <member name="T:NxActorDescType">
\brief Type of actor

</member>
        <member name="F:NX_ADT_POINTER">
\brief Not used
</member>
        <member name="F:NX_ADT_LIST">
\brief Not used
</member>
        <member name="F:NX_ADT_SHAPELESS">
\brief Not used
</member>
        <member name="M:NxShapeDesc.#ctor(NxShapeType)">
	constructor sets to default.

	\param[in] shapeType The type of shape this desc is created for.

</member>
        <member name="M:NxShapeDesc.getType">
	\brief Retrieves the shape type.

	\return The type of the shape. See #NxShapeType.

</member>
        <member name="M:NxShapeDesc.isValid">
\brief Returns true if the descriptor is valid.

\return true if the current settings are valid

</member>
        <member name="M:NxShapeDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="F:NxShapeDesc.nonInteractingCompartmentTypes">
	\brief A combination of ::NxShapeCompartmentType values.

	Defines which compartment types the shape should not interact with.

	\note This member is ignored in the following cases:

	\li Explicitly adding the shape, i.e., its actor, to a rigid body compartment.
	\li Attaching the shape to a fluid emitter.
	\li Attaching the shape to a cloth.
	\li Attaching the shape to a soft body.

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: Yes

	@see NxShape.setNonInteractingCompartmentTypes() NxShapeCompartmentType

</member>
        <member name="F:NxShapeDesc.groupsMask">
	\brief Groups bit mask for collision filtering

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxShapeDesc.name">
	\brief Possible debug name. The string is not copied by the SDK, only the pointer is stored.

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxShapeDesc.userData">
	\brief Will be copied to NxShape::userData.

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxShapeDesc.ccdSkeleton">
	\brief CCD Skeleton

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShape.setCCDSkeleton() NxPhysicsSDK.createCCDSkeleton()

</member>
        <member name="F:NxShapeDesc.materialIndex">
	\brief The material index of the shape.

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxScene.createMaterial() NxShape.setMaterial()

</member>
        <member name="F:NxShapeDesc.group">
	\brief See the documentation for NxShape::setGroup().

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShape.setGroup()

</member>
        <member name="F:NxShapeDesc.shapeFlags">
	\brief A combination of ::NxShapeFlag values.

	<b>Default:</b> NX_SF_VISUALIZATION

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShape.setFlag() NxShapeFlag

</member>
        <member name="F:NxShapeDesc.type">
	\brief The type of the shape (see NxShape.h).
	
	This gets set by the derived class' ctor, the user should not have to change it.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="T:NxShapeDesc">
\brief Descriptor for #NxShape class. 

Used for saving and loading the shape state.

See the derived classes for the different shape types.

@see NxActor.createShape() NxSphereShapeDesc NxPlaneShapeDesc NxConvexShapeDesc NxTriangleMeshShapeDesc
NxCapsuleShapeDesc NxBoxShapeDesc

</member>
        <member name="T:NxShapeCompartmentType">
@} 
\brief Describes the compartment types a rigid body shape might interact with

</member>
        <member name="M:NxShape.setNonInteractingCompartmentTypes(System.UInt32)">
	\brief Sets which compartment types the shape should not interact with.

	The shape will not interact with objects that belong to a compartment of the specified types.

	\note See #NxShapeDesc::nonInteractingCompartmentTypes for limitations.

	\param[in] compartmentTypes A combination of ::NxShapeCompartmentType values.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: Yes

	@see getNonInteractingCompartmentTypes() NxShapeCompartmentType

</member>
        <member name="M:NxShape.getNonInteractingCompartmentTypes">
	\brief Returns which compartment types the shape should not interact with.

	\return A combination of ::NxShapeCompartmentType values.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: Yes

	@see setNonInteractingCompartmentTypes() NxShapeCompartmentType

</member>
        <member name="M:NxShape.getGroupsMask">
	\brief Gets 128-bit mask used for collision filtering. See comments for ::NxGroupsMask

	\return The group mask for the shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setGroupsMask()

</member>
        <member name="M:NxShape.setGroupsMask(NxGroupsMask!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets 128-bit mask used for collision filtering. See comments for ::NxGroupsMask

	<b>Sleeping:</b> Does <b>NOT</b> wake the associated actor up automatically.

	\param[in] mask The group mask to set for the shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getGroupsMask()

</member>
        <member name="M:NxShape.checkOverlapCapsule(NxCapsule!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Checks whether the shape overlaps a world-space capsule or not.

	\param[in] worldCapsule The world space capsule to check against. <b>Range:</b> See #NxCapsule
	\return True if the capsule overlaps the shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxScene.overlapCapsuleShapes()

</member>
        <member name="M:NxShape.checkOverlapAABB(NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Checks whether the shape overlaps a world-space AABB or not.

	\param[in] worldBounds The world space axis aligned box to check against. <b>Range:</b> See #NxBounds3
	\return True if the Axis Aligned Bounding Box overlaps the shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxScene.overlapAABBShapes()

</member>
        <member name="M:NxShape.checkOverlapOBB(NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Checks whether the shape overlaps a world-space OBB or not.

	\param[in] worldBox The world space oriented box to check against. <b>Range:</b> See #NxBox
	\return True if the Oriented Bounding Box overlaps the shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxScene.overlapOBBShapes()

</member>
        <member name="M:NxShape.checkOverlapSphere(NxSphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Checks whether the shape overlaps a world-space sphere or not.

	\param[in] worldSphere The sphere description in the global frame to test against. <b>Range:</b> See #NxSphere
	\return True if the sphere overlaps the shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxScene.overlapSphereShapes()

</member>
        <member name="M:NxShape.raycast(NxRay!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.UInt32,NxRaycastHit*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
@name Raycasting and Overlap Testing

	\brief casts a world-space ray against the shape.

	maxDist is the maximum allowed distance for the ray. You can use this for segment queries.
	hintFlags is a combination of ::NxRaycastBit flags.
	firstHit is a hint saying you're only interested in a boolean answer.

	Note: Make certain that the direction vector of NxRay is normalized.

	\param[in] worldRay The ray to intersect against the shape in the global frame. <b>Range</b> See #NxRay
	\param[in] maxDist The maximum distance to check along the ray. <b>Range:</b> (0,inf)
	\param[in] hintFlags a combination of ::NxRaycastBit flags. Specifies which members of NxRaycastHit the user is interested in(eg normal, material etc)
	\param[out] hit Retrieves the information computed from a ray intersection
	\param[in] firstHit is a hint saying you're only interested in a boolean answer.
	\return True if the ray intersects the shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxScene.raycastAnyShape() NxScene.raycastAnyBounds()

</member>
        <member name="M:NxShape.getName">
	\brief retrieves the name string set with setName().
	\return The name associated with the shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setName()

</member>
        <member name="M:NxShape.setName(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
	\brief Sets a name string for the object that can be retrieved with #getName().
	
	This is for debugging and is not used by the SDK.
	The string is not copied by the SDK, only the pointer is stored.

	\param[in] name The name string to set the objects name to.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getName()

</member>
        <member name="M:NxShape.isHeightField">
	\brief Attempts to cast to an #NxHeightFieldShape

	Returns NULL if this object is not of the appropriate type.

	\return NULL if the shape is not an #NxHeightFieldShape. Otherwise a pointer to the shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShapeType NxHeightFieldShape

</member>
        <member name="M:NxShape.isTriangleMesh">
	\brief Attempts to cast to an #NxTriangleMeshShape

	Returns NULL if this object is not of the appropriate type.

	\return NULL if the shape is not an #NxTriangleMeshShape. Otherwise a pointer to the shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShapeType NxTriangleMeshShape

</member>
        <member name="M:NxShape.isConvexMesh">
	\brief Attempts to cast to an #NxConvexShape

	Returns NULL if this object is not of the appropriate type.

	\return NULL if the shape is not an #NxConvexShape. Otherwise a pointer to the shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShapeType NxConvexShape

</member>
        <member name="M:NxShape.isWheel">
	\brief Attempts to cast to an #NxWheelShape

	Returns NULL if this object is not of the appropriate type.

	\return NULL if the shape is not an #NxWheelShape. Otherwise a pointer to the shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShapeType NxWheelShape

</member>
        <member name="M:NxShape.isCapsule">
	\brief Attempts to cast to an #NxCapsuleShape

	Returns NULL if this object is not of the appropriate type.

	\return NULL if the shape is not an #NxCapsuleShape. Otherwise a pointer to the shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShapeType NxCapsuleShape

</member>
        <member name="M:NxShape.isBox">
	\brief Attempts to cast to an #NxBoxShape

	Returns NULL if this object is not of the appropriate type.

	\return NULL if the shape is not an #NxBoxShape. Otherwise a pointer to the shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShapeType NxBoxShape

</member>
        <member name="M:NxShape.isSphere">
	\brief Attempts to cast to an #NxSphereShape

	Returns NULL if this object is not of the appropriate type.

	\return NULL if the shape is not an #NxSphereShape. Otherwise a pointer to the shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShapeType NxSphereShape

</member>
        <member name="M:NxShape.isPlane">
	\brief Attempts to cast to an #NxPlaneShape.

	Returns NULL if this object is not of the appropriate type.

	\return NULL if the shape is not an #NxPlaneShape. Otherwise a pointer to the shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShapeType NxPlaneShape

</member>
        <member name="M:NxShape.is(NxShapeType)">
@name Is... Shape Type

	\brief Type casting operator. The result may be cast to the desired subclass type.

	\param[in] type The type of shape to attempt a cast to.
	\return NULL if the shape is not type. Otherwise a pointer to the shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShapeType

</member>
        <member name="M:NxShape.getCCDSkeleton">
	\brief Retrieves the CCDSkeleton for this shape.

	\return The CCD skeleton associated with this shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShapeDesc.ccdSkeleton NxPhysicsSDK.createCCDSkeleton() setCCDSkeleton()

</member>
        <member name="M:NxShape.setCCDSkeleton(NxCCDSkeleton*)">
	\brief Assigns a CCD Skeleton mesh.  

	Note how CCDSkeletons can be shared between shapes.  

	<h3>Visualizations:</h3>
	\li #NX_VISUALIZE_COLLISION_CCD
	\li #NX_VISUALIZE_COLLISION_SKELETONS

	\param[in] ccdSkel The CCDSkeleton to assign to the shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShapeDesc.ccdSkeleton NxPhysicsSDK.createCCDSkeleton() getCCDSkeleton()

</member>
        <member name="M:NxShape.getType">
	\brief returns the type of shape.

	\return The shape type of the shape. See #NxShapeType.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShapeType

</member>
        <member name="M:NxShape.getSkinWidth">
	\brief Retrieves the skin width. See #NxShapeDesc::skinWidth.

	\return The skin width of the shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getSkinWidth() NxParameter

</member>
        <member name="M:NxShape.setSkinWidth(System.Single)">
	\brief Sets the skin width. See #NxShapeDesc::skinWidth.

	<b>Sleeping:</b> Does <b>NOT</b> wake the associated actor up automatically.

	\param[in] skinWidth The new skin width. <b>Range:</b> (0,inf)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getSkinWidth
	@see NxParameter

</member>
        <member name="M:NxShape.getMaterial">
	\brief Retrieves the material index currently assigned to the shape.

	\return The material index of the material associated with the shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes
	
	@see setMaterial() NxMaterialIndex

</member>
        <member name="M:NxShape.setMaterial(System.UInt16)">
	\brief Assigns a material index to the shape.
	
	The material index can be retrieved by calling NxMaterial::getMaterialIndex().
	If the material index is invalid, it will still be recorded, but 
	the default material (at index 0) will effectively be used for simulation.

	<b>Sleeping:</b> Does <b>NOT</b> wake the associated actor up automatically.

	\param[in] matIndex The material index to assign to the shape. See #NxMaterial

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxScene.createMaterial() getMaterial() NxMaterialIndex NxMaterial.getMaterialIndex()

</member>
        <member name="M:NxShape.getGlobalOrientation">
	\brief The getGlobal*() methods retrieve the shape's current world space pose. This is 
	the local pose multiplied by the actor's current global pose.

	\return Orientation of the shape realative to the global frame.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setGlobalOrientation() getGlobalPose() getGlobalPosition()

</member>
        <member name="M:NxShape.getGlobalPosition">
	\brief The getGlobal*() methods retrieve the shape's current world space pose. This is 
	the local pose multiplied by the actor's current global pose.

	\return Position of the shape relative to the global frame.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setGlobalPosition() getGlobalPose() getGlobalOrientation()

</member>
        <member name="M:NxShape.getGlobalPose">
	\brief The getGlobal*() methods retrieve the shape's current world space pose. This is 
	the local pose multiplied by the actor's current global pose.

	\return Pose of shape relative to the global frame.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setGlobalPose() getGlobalPosition() getGlobalOrientation()

</member>
        <member name="M:NxShape.setGlobalOrientation(NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief The setGlobal() calls are convenience methods which transform the passed parameter
	into the current local space of the actor and then call setLocalPose().

	<b>Sleeping:</b> Does <b>NOT</b> wake the associated actor up automatically.

	<i>Note:</i> Does not automatically update the inertia properties of the owning actor (if applicable); use NxActor::updateMassFromShapes() to do this.
	\param[in] mat The new shape orientation relative to the global frame. <b>Range:</b> orientation matrix

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setLocalPose() getGlobalOrientation() setGlobalPosition() setGlobalOrientation()

</member>
        <member name="M:NxShape.setGlobalPosition(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief The setGlobal() calls are convenience methods which transform the passed parameter
	into the current local space of the actor and then call setLocalPose().

	<b>Sleeping:</b> Does <b>NOT</b> wake the associated actor up automatically.

	<i>Note:</i> Does not automatically update the inertia properties of the owning actor (if applicable); use NxActor::updateMassFromShapes() to do this.
	\param[in] vec The new shape position, relative to the global frame. <b>Range:</b> position vector

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setLocalPose() getGlobalPosition() setGlobalPosition() setGlobalOrientation()

</member>
        <member name="M:NxShape.setGlobalPose(NxMat34!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief The setGlobal() calls are convenience methods which transform the passed parameter
	into the current local space of the actor and then call setLocalPose().

	<b>Sleeping:</b> Does <b>NOT</b> wake the associated actor up automatically.

	<i>Note:</i> Does not automatically update the inertia properties of the owning actor (if applicable); use NxActor::updateMassFromShapes() to do this.
	\param[in] mat The new shape pose, relative to the global frame. <b>Range:</b> rigid body transform

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setLocalPose() getGlobalPose() setGlobalPosition() setGlobalOrientation()

</member>
        <member name="M:NxShape.getLocalOrientation">
	\brief The getLocal*() methods retrieve the pose of the shape in actor space, i.e. relative to the actor they are owned by.
	This transformation is identity by default.

	\return Orientation of shape relative to actors frame.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setLocalOrientation() getLocalPose() NxShapeDesc.localPose

</member>
        <member name="M:NxShape.getLocalPosition">
	\brief The getLocal*() methods retrieve the pose of the shape in actor space, i.e. relative to the actor they are owned by.

	This transformation is identity by default.

	\return Position of shape relative to actors frame.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setLocalPosition() getLocalPose() NxShapeDesc.localPose

</member>
        <member name="M:NxShape.getLocalPose">
	\brief The getLocal*() methods retrieve the pose of the shape in actor space, i.e. relative to the actor they are owned by.
	This transformation is identity by default.

	\return Pose of shape relative to the actors frame.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setLocalPose() NxShapeDesc.localPose

</member>
        <member name="M:NxShape.setLocalOrientation(NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief The setLocal*() methods set the pose of the shape in actor space, i.e. relative to the actor they are owned by.

	This transformation is identity by default.

	<b>Sleeping:</b> Does <b>NOT</b> wake the associated actor up automatically.

	<i>Note:</i> Does not automatically update the inertia properties of the owning actor (if applicable); use NxActor::updateMassFromShapes() to do this.
	\param[in] mat The new orientation relative to the actor frame.	<b>Range:</b> rotation matrix

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setLocalPose() NxShapeDesc.localPose getLocalOrientation()

</member>
        <member name="M:NxShape.setLocalPosition(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief The setLocal*() methods set the pose of the shape in actor space, i.e. relative to the actor they are owned by.
	
	This transformation is identity by default.

	<b>Sleeping:</b> Does <b>NOT</b> wake the associated actor up automatically.

	<i>Note:</i> Does not automatically update the inertia properties of the owning actor (if applicable); use NxActor::updateMassFromShapes() to do this.
	\param[in] vec The new position of the shape relative to the actor frame. <b>Range:</b> position vector

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setLocalPose() NxShapeDesc.localPose getLocalPosition()

</member>
        <member name="M:NxShape.setLocalPose(NxMat34!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Pose Manipulation

	\brief The setLocal*() methods set the pose of the shape in actor space, i.e. relative to the actor they are owned by.
	
	This transformation is identity by default.

	<b>Sleeping:</b> Does <b>NOT</b> wake the associated actor up automatically.

	<i>Note:</i> Does not automatically update the inertia properties of the owning actor (if applicable); use NxActor::updateMassFromShapes() to do this.
	\param[in] mat The new transform from the actor frame to the shape frame. <b>Range:</b> rigid body transform

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getLocalPose() NxShapeDesc.localPose()

</member>
        <member name="M:NxShape.getFlag(NxShapeFlag)">
	\brief Retrieves shape flags.

	\param[in] flag The flag to retrieve.
	\return The value of the flag specified.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShapeFlag setFlag()

</member>
        <member name="M:NxShape.setFlag(NxShapeFlag,System.Boolean)">
	\brief Sets shape flags

	The shape may be turned into a trigger by setting one or more of the
	above TriggerFlag-s to true. A trigger shape will not collide
	with other shapes. Instead, if a shape enters the trigger's volume, 
	a trigger event will be sent to the user via the NxUserTriggerReport::onTrigger method.
	You can set a NxUserTriggerReport object with NxScene::setUserTriggerReport().

	Since version 2.1.1 this is also used to setup generic (non-trigger) flags.

	<b>Sleeping:</b> Does <b>NOT</b> wake the associated actor up automatically.

	\param[in] flag The new shape flags to set for this shape. See #NxShapeFlag.
	\param[in] value True to set the flags. False to clear the flags specified in flag.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShapeFlag getFlag()

</member>
        <member name="M:NxShape.getWorldBounds(NxBounds3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Returns a world space AABB enclosing this shape.

	\param[out] dest Retrieves the world space bounds.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBounds3

</member>
        <member name="M:NxShape.getGroup">
	\brief Retrieves the value set with #setGroup().

	NxCollisionGroup is an integer between 0 and 31.

	\return The collision group this shape belongs to.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setGroup() NxCollisionGroup

</member>
        <member name="M:NxShape.setGroup(System.UInt16)">
	\brief Sets which collision group this shape is part of.
	
	Default group is 0. Maximum possible group is 31.
	Collision groups are sets of shapes which may or may not be set
	to collision detect with each other; this can be set using NxScene::setGroupCollisionFlag()

	<b>Sleeping:</b> Does <b>NOT</b> wake the associated actor up automatically.

	\param[in] collisionGroup The collision group for this shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getGroup() NxCollisionGroup

</member>
        <member name="M:NxShape.getActor">
	\brief Retrieves the actor which this shape is associated with.

	\return The actor this shape is associated with.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxActor

</member>
        <member name="T:NxBounds3">
@} 
\addtogroup physics
  @{

\addtogroup physics
  @{

</member>
        <member name="M:NxBodyDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return True if the current settings are valid

</member>
        <member name="M:NxBodyDesc.setToDefault">
\brief (re)sets the structure to the default, mass == 0 (an immediate call to isValid() will return false). 	

</member>
        <member name="M:NxBodyDesc.#ctor">
\brief Constructor sets to default, mass == 0 (an immediate call to isValid() will return false). 

</member>
        <member name="F:NxBodyDesc.flags">
	\brief Combination of ::NxBodyFlag flags

	<b>Default:</b> NX_BF_VISUALIZATION | NX_BF_ENERGY_SLEEP_TEST

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Partial (only supports NX_BF_KINEMATIC, NX_BF_DISABLE_GRAVITY)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBodyFlag NxActor.raiseBodyFlag() NxActor.clearBodyFlag()

</member>
        <member name="T:NxBodyDesc">
\addtogroup physics
  @{

\addtogroup physics
  @{

\addtogroup physics
  @{

\brief Descriptor for the optional rigid body dynamic state of #NxActor.

@see NxActor NxActorDesc NxScene.createActor()


@} 
</member>
        <member name="M:NxCompartment.getFlags">
	\brief Retrieves the compartment flags.

	\return The compartment flags.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCompartmentDesc.flags NxCompartmentFlag setFlags()

</member>
        <member name="M:NxCompartment.setFlags(System.UInt32)">
	\brief Sets the compartment flags, a combination of the bits defined by the enum ::NxCompartmentFlag.

	\param[in] flags #NxCompartmentFlag combination.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCompartmentDesc.flags NxCompartmentFlag getFlags()

</member>
        <member name="M:NxCompartment.saveToDesc(NxCompartmentDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Saves the compartment to a descriptor. Please note that the device code will be the same as the 
	value returned by getDeviceCode(), i.e. not necessarily the same as the value you assigned when first
	creating the compartment (when using auto-assign).

	\return true

</member>
        <member name="M:NxCompartment.fetchResults(System.Boolean)">
	This is the big brother to checkResults() it basically makes the results of the compartment's simulation readable.
	

	The entire scene incl. the compartments will still be locked for writing until you call fetchResults(NX_RIGID_BODY_FINISHED).

	\param[in] block When set to true will block until the condition is met.
	\return True if the results have been fetched.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxCompartment.checkResults(System.Boolean)">
	\brief This checks to see if the simulation of the objects in this compartment has completed.

	This does not cause the data available for reading to be updated with the results of the simulation, it is simply a status check.
	The bool will allow it to either return immediately or block waiting for the condition to be met so that it can return true

	\param[in] block When set to true will block until the condition is met.
	\return True if the results are available.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxCompartment.getTiming(System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxTimeStepMethod*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*)">
	\brief Retrieves simulation timing parameters.

	\param[in] maxTimestep Maximum size to divide a substep into. <b>Range:</b> (0,inf)
	\param[in] maxIter Maximum number of iterations to divide a timestep into.
	\param[in] method Method to use for timestep (either variable time step or fixed). See #NxTimeStepMethod.
	\param[in] numSubSteps The number of sub steps the time step will be divided into.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setTiming() setTimeScale()

</member>
        <member name="M:NxCompartment.setTiming(System.Single,System.UInt32,NxTimeStepMethod)">
 	\brief Sets simulation timing parameters used to simulate the compartment.  

	The initial default settings are inherited from the primary scene.

	If method is NX_TIMESTEP_FIXED, elapsedTime(simulate() parameter) is internally subdivided into up to
	maxIter substeps no larger than maxTimestep.
	
	If elapsedTime is not a multiple of maxTimestep then any remaining time is accumulated 
	to be added onto the elapsedTime for the next time step.

	If more sub steps than maxIter are needed to advance the simulation by elapsed time, then
	the remaining time is also accumulated for the next call to simulate().
	
	The timestep method of TIMESTEP_FIXED is strongly preferred for stable, reproducible simulation.

	Alternatively NX_TIMESTEP_VARIABLE can be used, in this case the first two parameters
	are not used.	See also ::NxTimeStepMethod.

	\param[in] maxTimestep Maximum size of a substep. <b>Range:</b> (0,inf)
	\param[in] maxIter Maximum number of iterations to divide a timestep into.
	\param[in] method Method to use for timestep (either variable time step or fixed). See #NxTimeStepMethod.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setTimeScale() getTiming()

</member>
        <member name="M:NxCompartment.getTimeScale">
	\return the time scale for the compartment.

	@see NxCompartmentDesc::timeScale setTimeScale

</member>
        <member name="M:NxCompartment.setTimeScale(System.Single)">
	\brief Sets the time scale for the compartment.

	@see NxCompartmentDesc::timeScale getTimeScale

</member>
        <member name="M:NxCompartment.gridHashTablePower">
\return the paging grid power.

</member>
        <member name="M:NxCompartment.getGridHashCellSize">
\return the paging grid cell size.

</member>
        <member name="M:NxCompartment.getDeviceCode">
	\brief The device code that is specified when creating a compartment or the automatically
	assigned device code, if NX_DC_PPU_AUTO_ASSIGN was used.

	\return the ::NxDeviceCode of the compartment.

</member>
        <member name="M:NxCompartment.getType">
\return the compartment simulation type.  Will be removed in 3.0, as compartments will become type-neutral.

</member>
        <member name="M:NxCompartmentDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return return true if the current settings are valid

</member>
        <member name="F:NxCompartmentDesc.timeScale">
	\brief It is possible to scale the simulation time steps of this compartment relative to the primary scene using this nonnegative value.  A scale of zero does not simulate the compartment. The default value is 1.0f.

	Note: The time scale is taken into account after the number of substeps has been calculated. This means that the maximum timestep setting of the compartment can be exceeded when timeScale is above 1.0f.

</member>
        <member name="F:NxCompartmentDesc.deviceCode">
\brief A NxDeviceCode, incl. a PPU index from 0 to 31.
@see NxDeviceCode

</member>
        <member name="T:NxCompartmentDesc">
\brief Descriptor class for NxCompartment.  A compartment is a portion of the scene that can
be simulated on a different hardware device than other parts of the scene.

</member>
        <member name="T:NxCompartmentType">
@} 
\addtogroup physics
  @{

\addtogroup physics
  @{

</member>
        <member name="M:NxScene.getSolverBatchSize">
	\brief Retrieves the number of actors required to spawn a separate rigid body solver thread.

	\return Current number of actors required to spawn a separate rigid body solver thread.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Not applicable
	\li PS3  : Not applicable
	\li XB360: Yes

	@see NxSceneDesc.solverBatchSize setSolverBatchSize()

</member>
        <member name="M:NxScene.setSolverBatchSize(System.UInt32)">
	\brief Sets the number of actors required to spawn a separate rigid body solver thread.

	\note If internal multi threading is disabled (see #NX_SF_ENABLE_MULTITHREAD) this call will
	have no effect.

	\param[in] solverBatchSize Number of actors required to spawn a separate rigid body solver thread.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Not applicable
	\li PS3  : Not applicable
	\li XB360: Yes

	@see NxSceneDesc.solverBatchSize getSolverBatchSize()

</member>
        <member name="M:NxScene.getDynamicTreeRebuildRateHint">
	\brief Retrieves the rebuild rate of the dynamic tree pruning structure.

	\return The rebuild rate of the dyamic tree pruning structure.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSceneDesc.dynamicTreeRebuildRateHint setDynamicTreeRebuildRateHint()

</member>
        <member name="M:NxScene.setDynamicTreeRebuildRateHint(System.UInt32)">
	\brief Sets the rebuild rate of the dynamic tree pruning structure.

	\param[in] dynamicTreeRebuildRateHint Rebuild rate of the dynamic tree pruning structure.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSceneDesc.dynamicTreeRebuildRateHint getDynamicTreeRebuildRateHint()

</member>
        <member name="M:NxScene.releaseSceneQuery(NxSceneQuery*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">

	\brief Release a scene query object.

	\param[in] query The query object to release.
	\return True on success.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (software)
	\li PS3  : Yes
	\li XB360: Yes

	@see createSceneQuery() NxSceneQuery 

</member>
        <member name="M:NxScene.createSceneQuery(NxSceneQueryDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Create a batched query object.

	\param[in] desc Descriptor used to modify the created query object.
	\return A new query object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (software)
	\li PS3  : Yes
	\li XB360: Yes

	@see releaseSceneQuery() NxSceneQueryDesc NxSceneQuery

</member>
        <member name="M:NxScene.unlockQueries">
	\brief Unlock parallel raycast/overlap queries.

	See #lockQueries() for more details.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: Yes

	@see lockQueries()

</member>
        <member name="M:NxScene.lockQueries">
	\brief Blocks all parallel raycast/overlap queries.

	This method should be used to lock raycasts from other threads while the SDK state is being updated in a way
	which will affect raycasting/overlap queries.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: Yes

	@see unlockQueries()

</member>
        <member name="M:NxScene.shutdownWorkerThreads">
	\brief Release threads which are blocking to allow the SDK to be destroyed safely.

	Note: This also applies to SDK managed threads. So calling shutdownWorkerThreads will release 
	all threads which are waiting using NX_WAIT_SHUTDOWN, which includes internal SDK threads.

	When internal threads are released by shutdownWorkerThreads() they will exit.

	In a typical application, the user should call shutdownWorkerThreads prior to destroying the
	scene. Then they will block until all user owned threads have left the API. It is then 
	safe to release the scene.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: Yes

	@see pollForBackgroundWork()

</member>
        <member name="M:NxScene.pollForBackgroundWork(NxThreadWait)">
	\brief Polls for background work.
	
	Returns NX_THREAD_NOWORK if no work is available, NX_THREAD_MOREWORK if
	there may be work remaining to execute or NX_THREAD_SHUTDOWN if
	the thread was released by shutdownWorkerThreads().

	The function waits for work to execute according the the waitType argument.

	The NX_WAIT_SIMULATION_END does not make sense for background tasks, as they are not 
	associated with a particular simulation step.

	\param[in] waitType Specifies how long the function should wait for work.
	\return Informs the user about the reason for returning.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: Yes

	@see resetPollForWork() NxThreadWait NxThreadPollResult

</member>
        <member name="M:NxScene.resetPollForWork">
	\brief Reset parallel simulation

	Resets parallel simulation so that threads calling pollForWork do not 
	return NX_THREAD_SIMULATION_END, but instead wait for a new simulation
	step to start.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: Yes


	@see pollForWork() NxThreadPollResult NxThreadWait

</member>
        <member name="M:NxScene.pollForWork(NxThreadWait)">
	 \brief Poll for work to execute on the current thread.
	
	Returns NX_THREAD_SIMULATION_END if the simulation step ended, 
	NX_THREAD_NOWORK if no work is available, NX_THREAD_MOREWORK if
	there may be work remaining to execute.

	The function waits for work to execute according the the waitType argument.

	The function will continue to return NX_THREAD_SIMULATION_END until the 
	#resetPollForWork() method is called.
	
	\param[in] waitType Specifies how long the function should wait for work.
	\return Informs the user about the reason for returning.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: Yes

	@see resetPollForWork() NxThreadWait NxThreadPollResult

</member>
        <member name="M:NxScene.readProfileData(System.Boolean)">
	Accesses internal profiler.  If clearData is true, the profile counters are reset.  You will most likely want to call readProfileData(true)
	right after calling fetchResults().  If that is not the time you want to read out the data, just call readProfileData(false) at some other place
	in your code.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxScene.flushCaches">
	Flush internal caches.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxScene.fetchResults(NxSimulationStatus,System.Boolean,System.UInt32*)">
	This is the big brother to checkResults() it basically does the following:
	
	\code
	if ( checkResults(enum, block) )
	{
		fire appropriate callbacks
		swap buffers
		if (CheckResults(all_enums, false))
			make IsWritable() true
		return true
	}
	else
		return false

	\endcode

	\param[in] status The part of the simulation to fetch results for (eg NX_RIGID_BODY_FINISHED). See #NxSimulationStatus.
	\param[in] block When set to true will block until the condition is met.
	\param[out] errorState Used to retrieve hardware error codes. A non zero value indicates an error.
	\return True if the results have been fetched.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see simulate() checkResults()

</member>
        <member name="M:NxScene.checkResults(NxSimulationStatus,System.Boolean)">
	\brief This checks to see if the part of the simulation run whose results you are interested in has completed.

	This does not cause the data available for reading to be updated with the results of the simulation, it is simply a status check.
	The bool will allow it to either return immediately or block waiting for the condition to be met so that it can return true

	This method replaces wait()
	
	\param[in] status The part of the simulation to check (eg NX_RIGID_BODY_FINISHED). See #NxSimulationStatus.
	\param[in] block When set to true will block until the condition is met.
	\return True if the results are available.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see simulate() fetchResults()

</member>
        <member name="M:NxScene.simulate(System.Single)">
 	\brief Advances the simulation by an elapsedTime time.
	
	If elapsedTime is large, it is internally subdivided according to parameters provided with the 
	#setTiming() method. See #setTiming() for a more detailed discussion of the elapsedTime parameter 
	and time stepping behavior.
 
 	Calls to simulate() should pair with calls to fetchResults():
 	Each fetchResults() invocation corresponds to exactly one simulate()
 	invocation; calling simulate() twice without an intervening fetchResults()
 	or fetchResults() twice without an intervening simulate() causes an error
 	condition.
 
 	scene-&gt;simulate();
 	...do some processing until physics is computed...
 	scene-&gt;fetchResults();
 	...now results of run may be retrieved.
 
 	Applications should not modify physics objects between calls to
 	simulate() and fetchResults();
 
  	This method replaces startRun().
	

	\param[in] elapsedTime Amount of time to advance simulation by. <b>Range:</b> (0,inf)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see fetchResults() checkResults()

</member>
        <member name="M:NxScene.isWritable">
	\brief This is a query to see if the scene is in a state that allows the application to update scene state.

	\return True if the scene can be written by the application.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxScene.getSoftBodies">
	\brief Returns an array of soft body objects.

	\return an array of soft body pointers with size getNbSoftBodies().

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getNbSoftBodies()

</member>
        <member name="M:NxScene.getNbSoftBodies">
	\return the number of soft bodies.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getSoftBodies()

</member>
        <member name="M:NxScene.releaseSoftBody(NxSoftBody*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	Deletes the specified soft body. The soft body must be in this scene.
	Do not keep a reference to the deleted instance.
	Avoid release calls while the scene is simulating (in between simulate() and fetchResults() calls).

	\param softBody Soft body to release.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBody

</member>
        <member name="M:NxScene.createSoftBody(NxSoftBodyDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name SoftBody

	Creates a soft body in this scene. NxSoftBodyDesc::isValid() must return true.

	\param softBodyDesc Description of the soft body object to create. See #NxSoftBodyDesc.
	\return The new soft body.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc NxSoftBody

</member>
        <member name="M:NxScene.getCloths">
	\brief Returns an array of cloth objects.

	\return an array of cloth pointers with size getNbCloths().

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getNbCloths()

</member>
        <member name="M:NxScene.getNbCloths">
	\return the number of cloths.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getCloths()

</member>
        <member name="M:NxScene.releaseCloth(NxCloth*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	Deletes the specified cloth. The cloth must be in this scene.
	Do not keep a reference to the deleted instance.
	Avoid release calls while the scene is simulating (in between simulate() and fetchResults() calls).

	\param cloth Cloth to release.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCloth

</member>
        <member name="M:NxScene.createCloth(NxClothDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Cloth

	Creates a cloth in this scene. NxClothDesc::isValid() must return true.

	\param clothDesc Description of the cloth object to create. See #NxClothDesc.
	\return The new cloth.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc NxCloth

</member>
        <member name="M:NxScene.cookFluidMeshHotspot(NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.Single,System.Single,System.Single,System.Single,NxCompartment*,System.Boolean)">
	\brief Pre-cooks all triangles from static NxTriangleMeshShapes of the scene which are intersecting with the given bounds.
	
	The pre-cooking will only be valid for Fluids which share the specified parameters (see NxFluidDesc)
	
	\param[in] bounds The volume whose contents should be pre-cooked
	\param[in] packetSizeMultiplier
	\param[in] restParticlesPerMeter 
	\param[in] kernelRadiusMultiplier
	\param[in] motionLimitMultiplier
	\param[in] collisionDistanceMultiplier
	\param[in] compartment The specific compartment to perform the pre-cooking for.
	\param[in] forceStrictCookingFormat Forces specified cooking parameters. Otherwise they might internaly be reinterpreted depending on created fluids. Not implemented yet.

	\return Operation succeeded.
	@see NxFluidDesc

</member>
        <member name="M:NxScene.getFluids">
	\brief Get an array of fluids belonging to the scene.

	\return an array of fluid pointers with size getNbFluids().

	\return An array of fluid objects belonging to this scene.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getNbFluids()

</member>
        <member name="M:NxScene.getNbFluids">
	\brief Get the number of fluids belonging to the scene.

	\return the number of fluids.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getFluids()

</member>
        <member name="M:NxScene.releaseFluid(NxFluid*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Deletes the specified fluid.	The fluid must be in this scene.

	Also releases any screen surface meshes created from the fluid.

	Do not keep a reference to the deleted instance.
	Avoid release calls while the scene is simulating (in between simulate() and fetchResults() calls).

	\param[in] fluid Fluid to release.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see createFluid()

</member>
        <member name="M:NxScene.createFluid(NxFluidDescBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Fluids

	\brief Creates a fluid in this scene. 
	
	NxFluidDesc::isValid() must return true.

	\param[in] fluidDesc Description of the fluid object to create. See #NxFluidDesc.
	\return The new fluid.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see releaseFluid()

</member>
        <member name="M:NxScene.checkOverlapCapsule(NxCapsule!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShapesType,System.UInt32,NxGroupsMask!System.Runtime.CompilerServices.IsConst*)">
	\brief Checks whether a world-space capsule overlaps something or not.

	\note Because the SDK double buffers shape state, a shape will not be updated until a simulation step is 
	taken. For example the result of setting the global pose is not immediatly visible.

	\param[in] worldCapsule Capsule description in world space. <b>Range:</b> See #NxCapsule
	\param[in] shapeType Choose if to intersect with static, dynamic or both types of shape. See #NxShapesType.
	\param[in] activeGroups Mask used to filter shape objects. See #NxShape::setGroup
	\param[in] groupsMask Alternative mask used to filter shapes. See #NxShape::setGroupsMask

	\return True if the capsule overlaps a shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCapsule NxShapesType NxShape.setGroup NxShape.setGroupsMask

</member>
        <member name="M:NxScene.checkOverlapOBB(NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShapesType,System.UInt32,NxGroupsMask!System.Runtime.CompilerServices.IsConst*)">
	\brief Checks whether a world-space OBB overlaps a shape or not.

	\note Because the SDK double buffers shape state, a shape will not be updated until a simulation step is 
	taken. For example the result of setting the global pose is not immediatly visible.

	\param[in] worldBox Oriented Bounding Box in world space. <b>Range:</b> See #NxBounds3
	\param[in] shapeType Choose if to intersect with static, dynamic or both types of shape. See #NxShapesType.
	\param[in] activeGroups Mask used to filter shape objects. See #NxShape::setGroup
	\param[in] groupsMask Alternative mask used to filter shapes. See #NxShape::setGroupsMask

	\return True if the OBB overlaps a shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBounds3 NxShapesType overlapOBBShapes NxShape.checkOverlapOBB()

</member>
        <member name="M:NxScene.checkOverlapAABB(NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShapesType,System.UInt32,NxGroupsMask!System.Runtime.CompilerServices.IsConst*)">
	\brief Checks whether a world-space AABB overlaps a shape or not.

	\note Because the SDK double buffers shape state, a shape will not be updated until a simulation step is 
	taken. For example the result of setting the global pose is not immediatly visible.

	\param[in] worldBounds Axis Aligned Bounding Box in world space. <b>Range:</b> See #NxBounds3
	\param[in] shapeType Choose if to intersect with static, dynamic or both types of shape. See #NxShapesType.
	\param[in] activeGroups Mask used to filter shape objects. See #NxShape::setGroup
	\param[in] groupsMask Alternative mask used to filter shapes. See #NxShape::setGroupsMask

	\return True if the AABB overlaps a shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBounds3 NxShapesType overlapAABBShapes NxShape.checkOverlapAABB()

</member>
        <member name="M:NxScene.checkOverlapSphere(NxSphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShapesType,System.UInt32,NxGroupsMask!System.Runtime.CompilerServices.IsConst*)">
	\brief Checks whether a world-space sphere overlaps a shape or not.

	\note Because the SDK double buffers shape state, a shape will not be updated until a simulation step is 
	taken. For example the result of setting the global pose is not immediatly visible.

	\param[in] worldSphere Sphere description in world space. <b>Range:</b> See #NxSphere
	\param[in] shapeType Choose if to intersect with static, dynamic or both types of shape. See #NxShapesType.
	\param[in] activeGroups Mask used to filter shape objects. See #NxShape::setGroup
	\param[in] groupsMask Alternative mask used to filter shapes. See #NxShape::setGroupsMask

	\return True if the sphere overlaps a shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSphere NxShapesType overlapSphereShapes NxShape.checkOverlapSphere()

</member>
        <member name="M:NxScene.cullShapes(System.UInt32,NxPlane!System.Runtime.CompilerServices.IsConst*,NxShapesType,System.UInt32,NxShape**,NxUserEntityReport&lt;NxShape**&gt;*,System.UInt32,NxGroupsMask!System.Runtime.CompilerServices.IsConst*)">
	\brief Returns the set of shapes which are in the negative half space of a number of planes.
	
	This function returns the set of shapes whose axis aligned bounding volumes are in the negative 
	half space(side the normal points away from) of all the planes passed in.
	
	However the set of shapes returned is not conservative, ie additional shapes may be returned which
	do not actually intersect the union of the planes negative half space.

	You can test against static and/or dynamic objects by adjusting 'shapeType'.
	Shapes are written to the static array 'shapes', which should be big enough to hold 'nbShapes'.
	An alternative is to use the ::NxUserEntityReport callback mechanism.

	The function returns the total number of collided shapes.

	This function can be used for view-frustum culling by passing the 6 camera planes to the function.

	\note Because the SDK double buffers shape state, a shape will not be updated until a simulation step is 
	taken. For example the result of setting the global pose is not immediatly visible.

	\warning Passing more than 32 planes to this function is unsupported and may result in undefined behavior.
	
	\param[in] nbPlanes Number of planes to test. (worldPlanes should contain this many planes)
	\param[in] worldPlanes Set of planes to test. <b>Range:</b> See #NxPlane
	\param[in] shapeType Choose if to intersect with static, dynamic or both types of shape. See #NxShapesType.
	\param[in] nbShapes Number of shapes that the buffer shapes can hold.
	\param[out] shapes Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes.
	\param[in] callback Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes.
	\param[in] activeGroups Mask used to filter shape objects. See #NxShape::setGroup
	\param[in] groupsMask Alternative mask used to filter shapes. See #NxShape::setGroupsMask

	\return the total number of collided shapes.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxPlane overlapAABBShapes() overlapSphereShapes() NxShapesType NxUserEntityReport NxShape.setGroup()

</member>
        <member name="M:NxScene.linearCapsuleSweep(NxCapsule!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.Void*,System.UInt32,NxSweepQueryHit*,NxUserEntityReport&lt;NxSweepQueryHit&gt;*,System.UInt32,NxGroupsMask!System.Runtime.CompilerServices.IsConst*)">
	\brief Performs a linear sweep through space with an oriented capsule.

	The function a capsule through space and reports any shapes in the scene
	which it intersects. Apart from the number of shapes intersected in this way, and the shapes
	intersected, information on the closest intersection is put in an #NxSweepQueryHit structure which 
	can be processed in the callback function if provided.
	Which shapes in the scene are regarded is specified through the flags parameter.

	\note Because the SDK double buffers shape state, a shape will not be updated until a simulation step is 
	taken. For example the result of setting the global pose is not immediatly visible.

	\param[in] worldCapsule The oriented capsule (#NxCapsule object) that is to be swept
	\param[in] motion Length and direction of the sweep
	\param[in] flags Flags controlling the mode of the sweep
	\param[in] userData User data to impart to the returned data struct
	\param[in] nbShapes Maximum number of shapes to report <b>Range:</b> [1,NX_MAX_U32]
	\param[out] shapes Pointer to buffer for reported shapes
	\param[in] callback Callback function invoked on the closest hit (if any)
	\param[in] activeGroups Mask used to filter shape objects. See #NxShape::setGroup
	\param[in] groupsMask Alternative mask used to filter shapes. See #NxShape::setGroupsMask

	\return The number of hits reported.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCapsule NxShape NxSweepQueryHit NxSweepFlags NxUserEntityReport NxScene

</member>
        <member name="M:NxScene.linearOBBSweep(NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.Void*,System.UInt32,NxSweepQueryHit*,NxUserEntityReport&lt;NxSweepQueryHit&gt;*,System.UInt32,NxGroupsMask!System.Runtime.CompilerServices.IsConst*)">
	\brief Performs a linear sweep through space with an oriented box.

	The function sweeps an oriented box through space and reports any shapes in the scene
	which it intersects. Apart from the number of shapes intersected in this way, and the shapes
	intersected, information on the closest intersection is put in an #NxSweepQueryHit structure which 
	can be processed in the callback function if provided.
	Which shapes in the scene are regarded is specified through the flags parameter.

	\note Because the SDK double buffers shape state, a shape will not be updated until a simulation step is 
	taken. For example the result of setting the global pose is not immediatly visible.

	\param[in] worldBox The oriented box (#NxBox object) that is to be swept
	\param[in] motion Length and direction of the sweep
	\param[in] flags Flags controlling the mode of the sweep
	\param[in] userData User data to impart to the returned data struct
	\param[in] nbShapes Maximum number of shapes to report <b>Range:</b> [1,NX_MAX_U32]
	\param[out] shapes Pointer to buffer for reported shapes
	\param[in] callback Callback function invoked on the closest hit (if any)
	\param[in] activeGroups Mask used to filter shape objects. See #NxShape::setGroup
	\param[in] groupsMask Alternative mask used to filter shapes. See #NxShape::setGroupsMask

	\return The number of hits reported.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBox NxShape NxSweepQueryHit NxSweepFlags NxUserEntityReport NxScene

</member>
        <member name="M:NxScene.releaseSweepCache(NxSweepCache*)">
\brief Deletes a sweep cache. See the Guide, "Sweep API" section, for more
information on sweep caches.
Avoid release calls while the scene is simulating (in between simulate() and fetchResults() calls).
@see NxActor

</member>
        <member name="M:NxScene.createSweepCache">
\brief Creates a sweep cache, for use with NxActor::linearSweep(). See the Guide, "Sweep API" section for 
more information.
@see NxActor

</member>
        <member name="M:NxScene.overlapCapsuleShapes(NxCapsule!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShapesType,System.UInt32,NxShape**,NxUserEntityReport&lt;NxShape**&gt;*,System.UInt32,NxGroupsMask!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
	\brief Returns the set of shapes overlapped by the world-space capsule.
	
	You can test against static and/or dynamic objects by adjusting 'shapeType'. 
	Shapes are written to the static array 'shapes', which should be big enough to hold 'nbShapes'.
	An alternative is to use the ::NxUserEntityReport callback mechanism.

	The function returns the total number of collided shapes.

	\note Because the SDK double buffers shape state, a shape will not be updated until a simulation step is 
	taken. For example the result of setting the global pose is not immediatly visible.

	\param[in] worldCapsule capsule in world space. <b>Range:</b> See #NxCapsule
	\param[in] shapeType Choose if to intersect with static, dynamic or both types of shape. See #NxShapesType.
	\param[in] nbShapes Number of shapes that the buffer shapes can hold.
	\param[out] shapes Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes.
	\param[in] callback Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes.
	\param[in] activeGroups Mask used to filter shape objects. See #NxShape::setGroup
	\param[in] groupsMask Alternative mask used to filter shapes. See #NxShape::setGroupsMask
	\param[in] accurateCollision True to test the capsule against the actual shapes, false to test against the AABBs only.

	\return the total number of collided shapes.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBounds3 NxShapesType overlapCapsuleShapes NxUserEntityReport NxShape.checkOverlapCapsule()

</member>
        <member name="M:NxScene.overlapOBBShapes(NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShapesType,System.UInt32,NxShape**,NxUserEntityReport&lt;NxShape**&gt;*,System.UInt32,NxGroupsMask!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
	\brief Returns the set of shapes overlapped by the world-space OBB.
	
	You can test against static and/or dynamic objects by adjusting 'shapeType'. 
	Shapes are written to the static array 'shapes', which should be big enough to hold 'nbShapes'.
	An alternative is to use the ::NxUserEntityReport callback mechanism.

	The function returns the total number of collided shapes.

	\note Because the SDK double buffers shape state, a shape will not be updated until a simulation step is 
	taken. For example the result of setting the global pose is not immediatly visible.

	\param[in] worldBox Oriented Bounding Box in world space. <b>Range:</b> See #NxBox
	\param[in] shapeType Choose if to intersect with static, dynamic or both types of shape. See #NxShapesType.
	\param[in] nbShapes Number of shapes that the buffer shapes can hold.
	\param[out] shapes Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes.
	\param[in] callback Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes.
	\param[in] activeGroups Mask used to filter shape objects. See #NxShape::setGroup
	\param[in] groupsMask Alternative mask used to filter shapes. See #NxShape::setGroupsMask
	\param[in] accurateCollision True to test the OBB against the actual shapes, false to test against the AABBs only.

	\return the total number of collided shapes.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBounds3 NxShapesType overlapOBBShapes NxUserEntityReport NxShape.checkOverlapOBB()

</member>
        <member name="M:NxScene.overlapAABBShapes(NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShapesType,System.UInt32,NxShape**,NxUserEntityReport&lt;NxShape**&gt;*,System.UInt32,NxGroupsMask!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
	\brief Returns the set of shapes overlapped by the world-space AABB.
	
	You can test against static and/or dynamic objects by adjusting 'shapeType'. 
	Shapes are written to the static array 'shapes', which should be big enough to hold 'nbShapes'.
	An alternative is to use the ::NxUserEntityReport callback mechanism.

	The function returns the total number of collided shapes.

	\note Because the SDK double buffers shape state, a shape will not be updated until a simulation step is 
	taken. For example the result of setting the global pose is not immediatly visible.

	\param[in] worldBounds Axis Aligned Bounding Box in world space. <b>Range:</b> See #NxBounds3
	\param[in] shapeType Choose if to intersect with static, dynamic or both types of shape. See #NxShapesType.
	\param[in] nbShapes Number of shapes that the buffer shapes can hold.
	\param[out] shapes Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes.
	\param[in] callback Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes.
	\param[in] activeGroups Mask used to filter shape objects. See #NxShape::setGroup
	\param[in] groupsMask Alternative mask used to filter shapes. See #NxShape::setGroupsMask
	\param[in] accurateCollision True to test the AABB against the actual shapes, false to test against the AABBs only.

	\return the total number of collided shapes.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBounds3 NxShapesType overlapAABBShapes NxUserEntityReport NxShape.checkOverlapAABB()

</member>
        <member name="M:NxScene.overlapSphereShapes(NxSphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShapesType,System.UInt32,NxShape**,NxUserEntityReport&lt;NxShape**&gt;*,System.UInt32,NxGroupsMask!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
@name Overlap Testing

	\brief Returns the set of shapes overlapped by the world-space sphere.
	
	You can test against static and/or dynamic objects by adjusting 'shapeType'. 
	Shapes are written to the static array 'shapes', which should be big enough to hold 'nbShapes'.
	An alternative is to use the ::NxUserEntityReport callback mechanism.

	The function returns the total number of collided shapes.

	\note Because the SDK double buffers shape state, a shape will not be updated until a simulation step is 
	taken. For example the result of setting the global pose is not immediatly visible.

	\param[in] worldSphere Sphere description in world space. <b>Range:</b> See #NxSphere
	\param[in] shapeType Choose if to intersect with static, dynamic or both types of shape. See #NxShapesType.
	\param[in] nbShapes Number of shapes that the buffer shapes can hold.
	\param[out] shapes Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes.
	\param[in] callback Alternative method to retrieve overlapping shapes. Is called with sets of overlapping shapes.
	\param[in] activeGroups Mask used to filter shape objects. See #NxShape::setGroup
	\param[in] groupsMask Alternative mask used to filter shapes. See #NxShape::setGroupsMask
	\param[in] accurateCollision True to test the sphere against the actual shapes, false to test against the AABBs only.

	\return the total number of collided shapes.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSphere NxShapesType overlapAABBShapes NxUserEntityReport NxShape.checkOverlapSphere()

</member>
        <member name="M:NxScene.raycastClosestShape(NxRay!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShapesType,NxRaycastHit*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.Single,System.UInt32,NxGroupsMask!System.Runtime.CompilerServices.IsConst*,NxShape**)">
	\brief Returns the first shape of type shapeType that is hit along the ray.
	
	The world space intersection point, and the distance along the ray are also provided.
	hintFlags is a combination of ::NxRaycastBit flags.

	\note Make certain that the direction vector of NxRay is normalized.

	\note Because the SDK double buffers shape state, a shape will not be updated until a simulation step is 
	taken. For example the result of setting the global pose is not immediatly visible.

	\param[in] worldRay The ray to cast in the global frame. <b>Range:</b> See #NxRay
	\param[in] shapeType Choose if to raycast against static, dynamic or both types of shape. See #NxShapesType.
	\param[out] hit Description of the intersection. See #NxRaycastHit.
	\param[in] groups Mask used to filter shape objects. See #NxShape::setGroup
	\param[in] maxDist Max distance to check along the ray for intersecting objects. <b>Range:</b> (0,inf) 
	\param[in] hintFlags Allows the user to specify which field of #NxRaycastHit they are interested in. See #NxRaycastBit
	\param[in] groupsMask Alternative mask used to filter shapes. See #NxShape::setGroupsMask
	\param[in] cache Possible cache for persistent raycasts, filled out by the SDK.

	\return The shape which is hit.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see raycastAllShapes() NxRay NxShapesType NxRaycastHit NxShape.setGroup() NxRaycastBit

</member>
        <member name="M:NxScene.raycastClosestBounds(NxRay!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShapesType,NxRaycastHit*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.Single,System.UInt32,NxGroupsMask!System.Runtime.CompilerServices.IsConst*)">
	\brief Returns the first axis aligned bounding box enclosing a shape of type shapeType that is hit along the ray.
	
	The world space intersection point, and the distance along the ray are also provided.
	hintFlags is a combination of ::NxRaycastBit flags.

	\note Make certain that the direction vector of NxRay is normalized.

	\note Because the SDK double buffers shape state, a shape will not be updated until a simulation step is 
	taken. For example the result of setting the global pose is not immediatly visible.

	\param[in] worldRay The ray to cast in the global frame. <b>Range:</b> See #NxRay
	\param[in] shapeType Choose if to raycast against static, dynamic or both types of shape. See #NxShapesType.
	\param[out] hit Description of the intersection. See #NxRaycastHit.
	\param[in] groups Mask used to filter shape objects. See #NxShape::setGroup
	\param[in] maxDist Max distance to check along the ray for intersecting objects. <b>Range:</b> (0,inf) 
	\param[in] hintFlags Allows the user to specify which field of #NxRaycastHit they are interested in. See #NxRaycastBit
	\param[in] groupsMask Alternative mask used to filter shapes. See #NxShape::setGroupsMask

	\return The shape which is hit.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see raycastAllBounds() NxRay NxShapesType NxRaycastHit NxShape.setGroup() NxRaycastBit

</member>
        <member name="M:NxScene.raycastAllShapes(NxRay!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxUserRaycastReport*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShapesType,System.UInt32,System.Single,System.UInt32,NxGroupsMask!System.Runtime.CompilerServices.IsConst*)">
	\brief Calls the report's hitCallback() method for all the shapes of type ShapeType intersected by the ray.
	
	hintFlags is a combination of ::NxRaycastBit flags.
	Returns the number of shapes hit. The point of impact is provided as a parameter to hitCallback().

	\note Make certain that the direction vector of NxRay is normalized.

	\note Because the SDK double buffers shape state, a shape will not be updated until a simulation step is 
	taken. For example the result of setting the global pose is not immediatly visible.

	<h3>Example</h3>

	\include NxUserRaycastReport_Usage.cpp


	\param[in] worldRay The ray to cast in the global frame. <b>Range:</b> See #NxRay
	\param[in] report User callback, to be called when an intersection is encountered.
	\param[in] shapesType Choose if to raycast against static, dynamic or both types of shape. See #NxShapesType.
	\param[in] groups Mask used to filter shape objects. See #NxShape::setGroup
	\param[in] maxDist Max distance to check along the ray for intersecting objects. <b>Range:</b> (0,inf) 
	\param[in] hintFlags Allows the user to specify which field of #NxRaycastHit they are interested in. See #NxRaycastBit
	\param[in] groupsMask Alternative mask used to filter shapes. See #NxShape::setGroupsMask

	\return the number of shapes hit

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see raycastAnyShape() raycastAllBounds() NxRay NxUserRaycastReport NxShapesType NxShape.setGroup() NxRaycastHit

</member>
        <member name="M:NxScene.raycastAllBounds(NxRay!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxUserRaycastReport*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShapesType,System.UInt32,System.Single,System.UInt32,NxGroupsMask!System.Runtime.CompilerServices.IsConst*)">
	\brief Calls the report's hitCallback() method for all the axis aligned bounding boxes enclosing shapes of type ShapeType intersected by the ray.
	
	The point of impact is provided as a parameter to hitCallback().
	hintFlags is a combination of ::NxRaycastBit flags.
	Returns the number of shapes hit.

	\note Make certain that the direction vector of NxRay is normalized.

	\note Because the SDK double buffers shape state, a shape will not be updated until a simulation step is 
	taken. For example the result of setting the global pose is not immediatly visible.

	\param[in] worldRay The ray to cast in the global frame. <b>Range:</b> See #NxRay
	\param[in] report User callback, to be called when an intersection is encountered.
	\param[in] shapesType Choose if to raycast against static, dynamic or both types of shape. See #NxShapesType.
	\param[in] groups Mask used to filter shape objects. See #NxShape::setGroup
	\param[in] maxDist Max distance to check along the ray for intersecting objects. <b>Range:</b> (0,inf) 
	\param[in] hintFlags Allows the user to specify which field of #NxRaycastHit they are interested in.
	\param[in] groupsMask Alternative mask used to filter shapes. See #NxShape::setGroupsMask

	\return the number of shapes hit.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see raycastAnyBounds() raycastAllShapes() NxRay NxUserRaycastReport NxShapesType NxShape.setGroup() NxRaycastHit

</member>
        <member name="M:NxScene.raycastAnyShape(NxRay!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShapesType,System.UInt32,System.Single,NxGroupsMask!System.Runtime.CompilerServices.IsConst*,NxShape**)">
	\brief Returns true if any shape of type ShapeType is intersected by the ray.

	\note Make certain that the direction vector of NxRay is normalized.

	\note Because the SDK double buffers shape state, a shape will not be updated until a simulation step is 
	taken. For example the result of setting the global pose is not immediatly visible.

	\param[in] worldRay The ray to cast in the global frame. <b>Range:</b> See #NxRay
	\param[in] shapesType Choose if to raycast against static, dynamic or both types of shape. See #NxShapesType.
	\param[in] groups Mask used to filter shape objects. See #NxShape::setGroup
	\param[in] maxDist Max distance to check along the ray for intersecting objects. <b>Range:</b> (0,inf) 
	\param[in] groupsMask Alternative mask used to filter shapes. See #NxShape::setGroupsMask
	\param[in] cache Possible cache for persistent raycasts, filled out by the SDK.

	\return Returns true if any shape of type ShapeType is intersected by the ray.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShapesType NxRay NxShape.setGroup()  raycastAnyBounds()

</member>
        <member name="M:NxScene.raycastAnyBounds(NxRay!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShapesType,System.UInt32,System.Single,NxGroupsMask!System.Runtime.CompilerServices.IsConst*)">
@name Raycasting

	\brief Returns true if any axis aligned bounding box enclosing a shape of type shapeType is intersected by the ray.

	\note Make certain that the direction vector of NxRay is normalized.

	\note Because the SDK double buffers shape state, a shape will not be updated until a simulation step is 
	taken. For example the result of setting the global pose is not immediatly visible.

	\param[in] worldRay The ray to cast in the global frame. <b>Range:</b> See #NxRay
	\param[in] shapesType Choose if to raycast against static, dynamic or both types of shape. See #NxShapesType.
	\param[in] groups Mask used to filter shape objects. See #NxShape::setGroup
	\param[in] maxDist Max distance to check along the ray for intersecting bounds. <b>Range:</b> (0,inf)
	\param[in] groupsMask Alternative mask used to filter shapes. See #NxShape::setGroupsMask

	\return true if any axis aligned bounding box enclosing a shape of type shapeType is intersected by the ray

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShapesType NxRay NxShape.setGroup()  raycastAnyShape()

</member>
        <member name="M:NxScene.getUserActorPairFiltering">
	\brief Gets the custom actor pair filtering in use for this scene.

	\return Filtering class that defines the callback used for custom pair filtering.

	@see NxUserActorPairFiltering setUserActorPairFiltering NxActor::resetUserActorPairFiltering

</member>
        <member name="M:NxScene.setUserActorPairFiltering(NxUserActorPairFiltering*)">
	\brief Sets the custom actor pair filtering to use for this scene.

	\param callback Filtering class that defines the callback to use for custom pair filtering.

	@see NxUserActorPairFiltering getUserActorPairFiltering NxActor::resetUserActorPairFiltering

</member>
        <member name="M:NxScene.getUserContactReport">
	\brief Retrieves the callback pointer set with setUserContactReport().

	\return The current user contact reporter. See #NxUserContactReport.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxUserContactReport setUserContactReport()

</member>
        <member name="M:NxScene.setUserContactReport(NxUserContactReport*)">
	\brief Sets a contact report object which receives collision contact events.

	\param[in] callback User contact callback. See #NxUserContactReport.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxUserContactReport getUserContactReport()

</member>
        <member name="M:NxScene.getUserTriggerReport">
	\brief Retrieves the callback pointer set with setUserTriggerReport().

	\return The current user trigger pointer. See #NxUserTriggerReport.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxUserTriggerReport setUserTriggerReport()

</member>
        <member name="M:NxScene.setUserTriggerReport(NxUserTriggerReport*)">
	\brief Sets a trigger report object which receives collision trigger events.

	\param[in] callback User trigger callback. See #NxUserTriggerReport.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxUserTriggerReport getUserTriggerReport()

</member>
        <member name="M:NxScene.getUserContactModify">
	\brief Retrieves the NxUserContactModify pointer set with setUserContactModify().

	\return The current user contact modify callback pointer. See #NxUserContactModify.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxUserContactModify setUserContactModify()

</member>
        <member name="M:NxScene.setUserContactModify(NxUserContactModify*)">
	\brief Sets a user callback object, which receives callbacks on all contacts generated for specified actors.

	\param[in] callback Asynchronous user contact modification callback. See #NxUserContactModify.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxScene.getSoftBodyUserNotify">
	\brief Retrieves the NxSoftBodyUserNotify pointer set with setSoftBodyUserNotify().

	\return The current user softbody notify pointer. See #NxSoftBodyUserNotify.

	<b>Platform:</b>
	\li PC SW: No
	\li PPU  : No
	\li PS3  : No
	\li XB360: No

	@see NxSoftBodyUserNotify setSoftBodyUserNotify()

</member>
        <member name="M:NxScene.setSoftBodyUserNotify(NxSoftBodyUserNotify*)">
	\brief Sets a user notify object which receives special simulation events when they occur.

	\param[in] callback User softbody notification callback. See #NxSoftBodyUserNotify.

	<b>Platform:</b>
	\li PC SW: No
	\li PPU  : No
	\li PS3  : No
	\li XB360: No

	@see NxSoftBodyUserNotify getSoftBodyUserNotify

</member>
        <member name="M:NxScene.getClothUserNotify">
	\brief Retrieves the NxClothUserNotify pointer set with setClothUserNotify().

	\return The current user cloth notify pointer. See #NxClothUserNotify.

	<b>Platform:</b>
	\li PC SW: No
	\li PPU  : No
	\li PS3  : No
	\li XB360: No

	@see NxClothUserNotify setClothUserNotify()

</member>
        <member name="M:NxScene.setClothUserNotify(NxClothUserNotify*)">
	\brief Sets a user notify object which receives special simulation events when they occur.

	\param[in] callback User cloth notification callback. See #NxClothUserNotify.

	<b>Platform:</b>
	\li PC SW: No
	\li PPU  : No
	\li PS3  : No
	\li XB360: No

	@see NxClothUserNotify getClothUserNotify

</member>
        <member name="M:NxScene.getFluidUserNotify">
	\brief Retrieves the NxFluidUserNotify pointer set with setfluidUserNotify().

	\return The current user fluid notify pointer. See #NxFluidUserNotify.

	<b>Platform:</b>
	\li PC SW: No
	\li PPU  : No
	\li PS3  : No
	\li XB360: No

	@see NxFluidUserNotify setFluidUserNotify()

</member>
        <member name="M:NxScene.setFluidUserNotify(NxFluidUserNotify*)">
	\brief Sets a user notify object which receives special simulation events when they occur.

	\param[in] callback User fluid notification callback. See #NxFluidUserNotify.

	<b>Platform:</b>
	\li PC SW: No
	\li PPU  : No
	\li PS3  : No
	\li XB360: No

	@see NxFluidUserNotify getFluidUserNotify

</member>
        <member name="M:NxScene.getUserNotify">
	\brief Retrieves the userNotify pointer set with setUserNotify().

	\return The current user notify pointer. See #NxUserNotify.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxUserNotify setUserNotify()

</member>
        <member name="M:NxScene.setUserNotify(NxUserNotify*)">
@name Callbacks

	\brief Sets a user notify object which receives special simulation events when they occur.

	\param[in] callback User notification callback. See #NxUserNotify.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxUserNotify getUserNotify

</member>
        <member name="M:NxScene.getMaxCPUForLoadBalancing">
	\brief Call to get the maximum CPU for use when load-balancing.

	@see setMaxCPUForLoadBalancing()

</member>
        <member name="M:NxScene.setMaxCPUForLoadBalancing(System.Single)">
	\brief Not yet implemented!
	
	Call to set the maximum CPU for use when load-balancing. 

	The SDK may choose to balance physics load by simulating assets on the CPU which could 
	otherwise be simulated on the PPU. Use this function to allocate a portion of the CPU
	for this purpose. Note that the SDK only load-balances assets created in compartments 
	with the attribute NX_DC_PPU_AUTO_ASSIGN, and that the default CPU allocated is zero.

	\param[in] cpuFraction The maximum fraction of the total host CPU to use - for example 
	0.2 would equate to 20% of a single core or might use 10% of each core or 20% of one 
	core on a dual-core CPU.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxDeviceCode getMaxCPUForLoadBalancing()

</member>
        <member name="M:NxScene.getLimits(NxSceneLimits*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Call to retrieve the expected object count limits set in the scene descriptor.

	\param[out] limits Used to retrieve the limits for the scene(e.g. maximum number of actors). See #NxSceneLimits.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSceneLimits getStats() NxSceneStats

</member>
        <member name="M:NxScene.getStats2">
	\brief Call this method to retrieve extended statistics about the current scene.

	\return Used to retrieve statistics for the scene. See #NxSceneStats2. 
	Note that this is a pointer to data that changes with each simulation call; 
	the relevant data must be copied in order to save it.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxScene.getStats(NxSceneStats*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Call this method to retrieve statistics about the current scene.

	\param[out] stats Used to retrieve statistics for the scene. See #NxSceneStats.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : No
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSceneStats getLimits()

</member>
        <member name="M:NxScene.getPhysicsSDK">
	\brief Call this method to retrieve the Physics SDK.

	\return The physics SDK this scene is associated with.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxPhysicsSDK

</member>
        <member name="M:NxScene.getDebugRenderable">
	\brief Retrieves the debug renderable.
	
	This will contain the results of any active visualization for this scene.
	\return The debug renderable.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : No
	\li PS3  : Yes
	\li XB360: Yes

	@see NxDebugRenderable

</member>
        <member name="M:NxScene.getTiming(System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxTimeStepMethod*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*)">
	\brief Retrieves simulation timing parameters.

	\param[in] maxTimestep Maximum size to divide a substep into. <b>Range:</b> (0,inf)
	\param[in] maxIter Maximum number of iterations to divide a timestep into.
	\param[in] method Method to use for timestep (either variable time step or fixed). See #NxTimeStepMethod.
	\param[in] numSubSteps The number of sub steps the time step will be divided into.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setTiming()

</member>
        <member name="M:NxScene.setTiming(System.Single,System.UInt32,NxTimeStepMethod)">
 	\brief Sets simulation timing parameters used in simulate(elapsedTime).

	If method is NX_TIMESTEP_FIXED, elapsedTime(simulate() parameter) is internally subdivided into up to
	maxIter substeps no larger than maxTimestep.
	
	If elapsedTime is not a multiple of maxTimestep then any remaining time is accumulated 
	to be added onto the elapsedTime for the next time step.

	If more sub steps than maxIter are needed to advance the simulation by elapsed time, then
	the remaining time is also accumulated for the next call to simulate().
	
	The timestep method of TIMESTEP_FIXED is strongly preferred for stable, reproducible simulation.

	Alternatively NX_TIMESTEP_VARIABLE can be used, in this case the first two parameters
	are not used.	See also ::NxTimeStepMethod.

	\param[in] maxTimestep Maximum size of a substep. <b>Range:</b> (0,inf)
	\param[in] maxIter Maximum number of iterations to divide a timestep into.
	\param[in] method Method to use for timestep (either variable time step or fixed). See #NxTimeStepMethod.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see flushStream() simulate() fetchResults() checkResults()

</member>
        <member name="M:NxScene.flushStream">
	\brief Flush the scene's command queue for processing.

	Flushes any buffered commands so that they get executed.
	Ensures that commands buffered in the system will continue to make forward progress until completion.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setTiming() simulate() fetchResults() checkResults()

</member>
        <member name="M:NxScene.getMaterialFromIndex(System.UInt16)">
	\brief Retrieves the material with the given material index.
	
	There is always at least one material in the Scene, the default material (index 0). If the
	specified material index is out of range (larger than getHighestMaterialIndex) or belongs
	to a material that has been released, then the default material is returned, but no error
	is reported. 
	
	You can always get a pointer to the default material by specifying index 0. You can change
	the properties of the default material by changing the properties directly on the material.
	It is not possible to release the default material, calling releaseMaterial(defaultMaterial)
	has no effect.

	\param[in] matIndex Material index to retrieve.
	\return The associated material.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxMaterial NxMaterialIndex NxScene.createMaterial() getHighestMaterialIndex()

</member>
        <member name="M:NxScene.getHighestMaterialIndex">
	\brief Returns current highest valid material index.
	
	Note that not all indices below this are valid if some of them belong to meshes that
	have been freed.

	\return The highest material index.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxMaterial NxMaterialIndex NxScene.createMaterial()

</member>
        <member name="M:NxScene.getMaterialArray(NxMaterial**,System.UInt32,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Writes the scene's array of material pointers to a user buffer.
	
	bufferSize is the number of pointers (not bytes) that the buffer can hold.
	usersIterator is an iterator that the user should initialize to 0 to start copying the array from the beginning.
	Once the first call succeeds, the SDK will have changed the value of the iterator (in some data structure specific way) such that the
	next get*Array() call will return the next batch of values.  This way a large internal array can be read out with several calls into 
	a smaller user side buffer.
	
	Returns the number of pointers written, this should be less or equal to bufferSize.  This will also return the default material which exists without having to be created.

	The ordering of the materials in the array is not specified.

	Usage example:
	\code
	NxMaterial * ptrs[3];
	NxU32 iterator = 0;
	NxU32 materialCount;
	while (materialCount = s-&gt;getMaterialArray(ptrs, 3, iterator))
		while(materialCount--) processMaterial(ptrs[materialCount]);

	\endcode

	\param[out] userBuffer The buffer to receive material pointers.
	\param[in] bufferSize The number of material pointers which can be stored in the buffer.
	\param[in,out] usersIterator Cookie used to continue iteration from the last position.
	\return The number of material pointers written to userBuffer.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getNbMaterials() NxMaterial

</member>
        <member name="M:NxScene.getNbMaterials">
@name Materials

	\brief Return the number of materials in the scene.

	Note that the returned value is not related to material indices (NxMaterialIndex).
	Those may not be allocated continuously, and its values may be higher than getNbMaterials().
	This will also include the default material which exists without having to be created.

	\return The size of the internal material array.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getMaterialArray()

</member>
        <member name="M:NxScene.getIslandArrayFromActor(NxActor*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxActor**,System.UInt32,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Writes pointers to the actors making up the collision island of a certain actor to a user buffer

	A collision island is a group of objects that are connected through bounds overlaps or joint constraints.

	bufferSize is the number of pointers (not bytes) that the buffer can hold.
	usersIterator is an iterator that the user should initialize to 0 to start copying the array from the beginning.
	Once the first call succeeds, the SDK will have changed the value of the iterator (in some data structure specific way) such that the
	next get*Array() call will return the next batch of values.  This way a large internal array can be read out with several calls into 
	a smaller user side buffer.

	Returns the number of pointers written, this should be less or equal to bufferSize.  This will include the specified actor.

	The ordering of the actors in the array is not specified.
	Note that this call is invalid while the scene is simulating (in between simulate() and fetchResults() calls).
	Also, the island is based on the state just before the last simulation step, which means the islands may be somewhat inaccurate, especially for fast moving objects.

	Usage example:
	\code
	NxActor * ptrs[3];
	NxU32 iterator = 0;
	NxU32 actorCount;
	while (actorCount = s-&gt;getIslandArrayFromActor(actor, ptrs, 3, iterator))
		while(actorCount--) processActor(ptrs[actorCount]);

	\endcode

	\param[in] actor The actor for which to return island information
	\param[out] userBuffer The buffer to receive actor pointers.
	\param[in] bufferSize The number of actor pointers which can be stored in the buffer.
	\param[in,out] userIterator Cookie used to continue iteration from the last position.
	\return The number of actor pointers written to userBuffer.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getBoundForIslandSize() NxActor

</member>
        <member name="M:NxScene.getBoundForIslandSize(NxActor*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Returns an upper bound for the number of actors in the collision island of a certain actor

    A collision island is a group of objects that are connected through bounds overlaps or joint constraints.

	\param[in] actor The actor for which to return island information

	\return The maximum size of the internal actor array.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getIslandArrayFromActor()

</member>
        <member name="M:NxScene.getNextEffector">
	\brief Retrieves the next effector when iterating through the effectors in the scene.
	
	First call resetEffectorIterator(), then call this method repeatedly until it returns
	zero. After a call to resetEffectorIterator(), repeated calls to getNextEffector() should return a sequence of getNbEffectors()
	effector pointers. The getNbEffectors()+1th call will return 0.
	Creating or deleting effectors resets the joint iterator.

	@see resetEffectorIterator.

	\return The next effector in the iteration sequence. Or NULL when the end of the list of joints is reached.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see resetEffectorIterator() getNbEffectors()

</member>
        <member name="M:NxScene.resetEffectorIterator">
    \brief Restarts the effector iterator so that the next call to ::getNextEffector() returns the first effector in the scene.
	
	Creating or deleting effectors resets the joint iterator.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getNextEffector() getNbEffectors()

</member>
        <member name="M:NxScene.getNbEffectors">
	\brief Returns the number of effectors in the scene.

	\return the number of effectors in this scene.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getNextEffector()

</member>
        <member name="M:NxScene.getNextJoint">
	\brief Retrieves the next joint when iterating.
	
	First call resetJointIterator(), then call this method repeatedly until it returns
	zero. After a call to resetJointIterator(), repeated calls to getNextJoint() should return a sequence of getNbJoints()
	joint pointers. The getNbJoints()+1th call will return 0.
	Creating or deleting joints resets the joint iterator.

	@see resetJointIterator.

	\return The next joint in the iteration sequence. Or NULL when the end of the list of joints is reached.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see resetJointIterator() getNbJoints()

</member>
        <member name="M:NxScene.resetJointIterator">

	\brief Restarts the joint iterator so that the next call to ::getNextJoint() returns the first joint in the scene.

	Creating or deleting joints resets the joint iterator.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see resetJointIterator() getNbJoints()

</member>
        <member name="M:NxScene.getNbJoints">
	\brief Returns the number of joints in the scene (excluding "dead" joints).
	Note that this includes compartments.

	\return the number of joints in this scene.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getNextJoint()

</member>
        <member name="M:NxScene.getTotalNbShapes">
	\brief Returns the total number of shapes in the scene, including compounds' sub-shapes.
	Note that this also includes compartments and mirrored shapes in compartments.

	\return the total number of shapes.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getNbStaticShapes()
	@see getNbDynamicShapes()

</member>
        <member name="M:NxScene.getNbDynamicShapes">
	\brief Returns the number of dynamic shapes in the scene.
	Note that this includes compartments and mirrored shapes in compartments.

	\return the number of dynamic shapes.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getNbStaticShapes()
	@see getTotalNbShapes()

</member>
        <member name="M:NxScene.getNbStaticShapes">
	\brief Returns the number of static shapes in the scene.
	Note that this includes compartments and mirrored shapes in compartments.

	\return The number of static shapes.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getNbDynamicShapes();
	@see getTotalNbShapes()

</member>
        <member name="M:NxScene.getActiveTransforms(System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Queries the NxScene for a list of the NxActors whose transforms have been 
	updated during the previous simulation step

	Note: NX_SF_ENABLE_ACTIVETRANSFORMS must be set.

	\param[out] nbTransformsOut The number of transforms returned.

	\return A pointer to the list of NxActiveTransforms generated during the last call to fetchResults().

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxActiveTransform

</member>
        <member name="M:NxScene.getActors">
	\brief Retrieve an array of all the actors in the scene.

	\return an array of actor pointers with size getNbActors().

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getNbActors()

</member>
        <member name="M:NxScene.getNbActors">
@name Enumeration

	\brief Retrieve the number of actors in the scene.
	\return the number of actors.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getActors()

</member>
        <member name="M:NxScene.getFilterConstant1">
	\brief Gets filtering constant K1. See comments for ::NxGroupsMask

	\return the filtering constant, as a mask. See #NxGroupsMask.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setFilterOps() setFilterBool() setFilterConstant0() setFilterConstant1() getFilterConstant0()

</member>
        <member name="M:NxScene.getFilterConstant0">
	\brief Gets filtering constant K0. See comments for ::NxGroupsMask

	\return the filtering constant, as a mask. See #NxGroupsMask.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setFilterOps() setFilterBool() setFilterConstant0() setFilterConstant1() getFilterConstant1()

</member>
        <member name="M:NxScene.getFilterBool">
	\brief Retrieves filtering's boolean value. See comments for ::NxGroupsMask

	\return flag Boolean value for filter.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setFilterBool() setFilterConstant0() setFilterConstant1()

</member>
        <member name="M:NxScene.getFilterOps(NxFilterOp*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxFilterOp*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxFilterOp*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Retrieves filtering operation. See comments for ::NxGroupsMask

	\param[out] op0 First filter operator.
	\param[out] op1 Second filter operator.
	\param[out] op2 Third filter operator.

	See the user guide page "Contact Filtering" for more details.	

	\return the filter operation requested

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setFilterOps() setFilterBool() setFilterConstant0() setFilterConstant1()

</member>
        <member name="M:NxScene.setFilterConstant1(NxGroupsMask!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Setups filtering's K1 value. See comments for ::NxGroupsMask

	<b>Sleeping:</b> Does <b>NOT</b> wake the actors up automatically.

	\param[in] mask The new group mask. See #NxGroupsMask.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setFilterOps() setFilterBool() setFilterConstant0()

</member>
        <member name="M:NxScene.setFilterConstant0(NxGroupsMask!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Setups filtering's K0 value. See comments for ::NxGroupsMask

	<b>Sleeping:</b> Does <b>NOT</b> wake the actors up automatically.

	\param[in] mask The new group mask. See #NxGroupsMask.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setFilterOps() setFilterBool() setFilterConstant1()

</member>
        <member name="M:NxScene.setFilterBool(System.Boolean)">
	\brief Setups filtering's boolean value. See comments for ::NxGroupsMask

	<b>Sleeping:</b> Does <b>NOT</b> wake the actors up automatically.

	\param[in] flag Boolean value for filter.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setFilterOps() setFilterConstant0() setFilterConstant1()

</member>
        <member name="M:NxScene.setFilterOps(NxFilterOp,NxFilterOp,NxFilterOp)">
	\brief Setups filtering operations. See comments for ::NxGroupsMask

	<b>Sleeping:</b> Does <b>NOT</b> wake the actors up automatically.

	\param[in] op0 Filter op 0.
	\param[in] op1 Filter op 1.
	\param[in] op2 Filter op 2.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setFilterBool() setFilterConstant0() setFilterConstant1()

</member>
        <member name="M:NxScene.getActorGroupPairArray(NxActorGroupPair*,System.UInt32,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Writes the scene's array of actor group flags (as set by setActorGroupPairFlags) to a user buffer.

	bufferSize is the number of NxActorGroupPairs (not bytes) that the buffer can hold.
	usersIterator is an iterator that the user should initialize to 0 to start copying the array from the beginning.
	Once the first call succeeds, the SDK will have changed the value of the iterator (in some data structure specific way) such that the
	next get*Array() call will return the next batch of values.  This way a large internal array can be read out with several calls into 
	a smaller user side buffer.

	\return the number of pairs written, this should be less or equal to bufferSize.

	The ordering of the elements in the array is not specified.

	\param[out] userBuffer The buffer to receive NxActorGroupPairs.
	\param[in] bufferSize The number of NxActorGroupPairs which can be stored in the buffer.
	\param[in,out] userIterator Cookie used to continue iteration from the last position.
	\return The number of pairs written to userBuffer.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getNbActorGroupPairs() NxActorGroupPair

</member>
        <member name="M:NxScene.getNbActorGroupPairs">
	\brief Gets the number of actor group flags (as set by setActorGroupPairFlags).

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: Yes

	@see NxActorGroupPair, getActorGroupPairFlags(), getActorGroupPairArray()

</member>
        <member name="M:NxScene.getActorGroupPairFlags(System.UInt16,System.UInt16)">
	\brief This reads the value set with #setActorGroupPairFlags.

	\param[in] group1 First Group
	\param[in] group2 Second Group
	\return The contact reporting flags associated with this actor pair. See #setActorGroupPairFlags.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setActorPairFlags() NxActorGroup NxActor.getGroup() NxActor.setGroup()

</member>
        <member name="M:NxScene.setActorGroupPairFlags(System.UInt16,System.UInt16,System.UInt32)">
	\brief With this method one can set contact reporting flags between actors belonging to a pair of groups.

	It is possible to assign each actor to a group using NxActor::setGroup(). This is a different
	set of groups from the shape groups despite the similar name. Here up to 0xffff different groups are permitted,
	With this method one can set contact reporting flags between actors belonging to a pair of groups.

	The following flags are permitted:

	NX_NOTIFY_ON_START_TOUCH
	NX_NOTIFY_ON_END_TOUCH	
	NX_NOTIFY_ON_TOUCH
	NX_NOTIFY_ON_START_TOUCH_FORCE_THRESHOLD
	NX_NOTIFY_ON_END_TOUCH_FORCE_THRESHOLD
	NX_NOTIFY_ON_TOUCH_FORCE_THRESHOLD
	NX_NOTIFY_ON_IMPACT		
	NX_NOTIFY_ON_ROLL		
	NX_NOTIFY_ON_SLIDE	

	See ::NxContactPairFlag.

	Note that finer grain control of pairwise flags is possible using the functions
	NxScene::setShapePairFlags() and NxScene::setActorPairFlags().

	<b>Sleeping:</b> Does <b>NOT</b> wake the actors up automatically.

	\param[in] group1 First group.
	\param[in] group2 Second group
	\param[in] flags Flags to control contact reporting. See #NxContactPairFlag.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getActorGroupPairFlags() NxActorGroup NxActor.getGroup() NxActor.setGroup()

</member>
        <member name="M:NxScene.getDominanceGroupPair(System.UInt16,System.UInt16)">
	\brief Samples the dominance matrix.

	@see setDominanceGroupPair() NxDominanceGroup NxConstraintDominance NxActor::setDominanceGroup() NxActor::getDominanceGroup()

</member>
        <member name="M:NxScene.getGroupCollisionFlag(System.UInt16,System.UInt16)">
	\brief Determines if collision detection is performed between a pair of groups.

	NxCollisionGroup is an integer between 0 and 31.

	\param[in] group1 First Group.
	\param[in] group2 Second Group.
	\return True if the groups could collide.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setGroupCollisionFlag() NxCollisionGroup NxShape.setGroup() NxShape.getGroup()

</member>
        <member name="M:NxScene.getPairFlagArray(NxPairFlag*,System.UInt32)">
	\brief Retrieves the pair flag data.
	
	The high bit of each 32 bit flag field denotes whether a pair is a shape or
	an actor pair. numPairs is the number of pairs the buffer can hold. The user is responsible for
	allocating and deallocating the buffer. Call ::getNbPairs() to check what the number of pairs should be.
	

	\param[out] userArray Pointer to user array to receive pair flags. should be at least sizeof(NxPairFlag)*numPairs in size.
	\param[in] numPairs Number of pairs the user buffer can hold.
	\return The number of pairs written to userArray.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : No
	\li PS3  : Yes
	\li XB360: Yes

	@see NxContactPairFlag setShapePairFlags() setActorPairFlags() getNbPairs()

</member>
        <member name="M:NxScene.getNbPairs">
	\brief Returns the number of pairs for which pairFlags are defined. 
	Note that this includes compartments.

	This includes actor and shape pairs.

	\return The number of pairs.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxContactPairFlag setShapePairFlags() setActorPairFlags() getPairFlagArray()

</member>
        <member name="M:NxScene.getShapePairFlags(NxShape*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShape*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Similar to #getActorPairFlags(), but for a pair of shapes.

	The two shape references must not reference the same shape.

	\param[in] shapeA Shape A
	\param[in] shapeB SHape B
	\return The shape pair flags.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setShapePairFlags() NxContactPairFlag

</member>
        <member name="M:NxScene.setShapePairFlags(NxShape*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShape*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
	\brief Similar to #setActorPairFlags(), but for a pair of shapes.
	
	NX_IGNORE_PAIR is the only thing allowed
	as a shape pair flag.  All of the NX_NOTIFY flags should be used at the actor level.
	The two shape references must not reference the same shape.

	<b>Sleeping:</b> Does <b>NOT</b> wake the associated actors up automatically.

	\param[in] shapeA Shape A
	\param[in] shapeB Shape B
	\param[in] nxContactPairFlag New set of shape contact pair flags.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getShapePairFlags() NxContactPairFlag

</member>
        <member name="M:NxScene.getActorPairFlags(NxActor*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxActor*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Retrieves the pair flags for the given pair of actors.
	
	The pair flags are a combination of bits
	defined by ::NxContactPairFlag. If no pair record is found, zero is returned.
	The two actor references must not reference the same actor.

	\param[in] actorA Actor A
	\param[in] actorB Actor B
	\return The actor pair flags.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes
	
	@see setActorPairFlags() NxContactPairFlag

</member>
        <member name="M:NxScene.setActorPairFlags(NxActor*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxActor*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
@name Collision Filtering and Grouping

	\brief Sets the pair flags for the given pair of actors.

	The pair flags are a combination of bits
	defined by ::NxContactPairFlag. Calling this on an actor that has no shape(s) has no effect.
	The two actor references must not reference the same actor.

	It is important to note that the SDK stores pair flags per shape, even for actor pair flags. 
	This means that shapes should be created before actor pair flags are set, otherwise the pair
	flags will be ignored.

	<b>Sleeping:</b> Does <b>NOT</b> wake the actors up automatically.

	\param[in] actorA Actor A
	\param[in] actorB Actor B
	\param[in] nxContactPairFlag New set of contact pair flags. See #NxContactPairFlag

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getActorPairFlags() NxContactPairFlag

</member>
        <member name="M:NxScene.getCompartmentArray(NxCompartment**,System.UInt32,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Writes the scene's array of NxCompartment pointers to a user buffer.

	bufferSize is the number of pointers (not bytes) that the buffer can hold.
	usersIterator is an iterator that the user should initialize to 0 to start copying the array from the beginning.
	Once the first call succeeds, the SDK will have changed the value of the iterator (in some data structure specific way) such that the
	next get*Array() call will return the next batch of values.  This way a large internal array can be read out with several calls into 
	a smaller user side buffer.

	Returns the number of pointers written, this should be less or equal to bufferSize.

	The ordering of the compartments in the array is not specified.

	\param[out] userBuffer The buffer to receive compartment pointers.
	\param[in] bufferSize The number of compartment pointers which can be stored in the buffer.
	\param[in,out] usersIterator Cookie used to continue iteration from the last position.
	\return The number of compartment pointers written to userBuffer.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getNbCompartments() NxCompartment

</member>
        <member name="M:NxScene.getNbCompartments">
	\brief Returns the number of compartments created in the scene.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCompartment, getCompartmentArray()

</member>
        <member name="M:NxScene.createCompartment(NxCompartmentDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Creates a scene compartment.

	A scene compartment is a portion of the scene that can
	be simulated on a different hardware device than other parts of the scene.
	See also the User's Guide on Compartments.

	\param[in] compDesc The NxCompartment descriptor to use to create a compartment.
	\return the new compartment.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCompartment

</member>
        <member name="M:NxScene.releaseMaterial(NxMaterial*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Deletes the specified material.
	
	The material must be in this scene.
	Do not keep a reference to the deleted instance.
	If you release a material while shapes or meshes are referencing its material index,
	the material assignment of these objects becomes undefined.
	Avoid release calls while the scene is simulating (in between simulate() and fetchResults() calls).

	\param[in] material The material to release.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see createMaterial() NxMaterial

</member>
        <member name="M:NxScene.createMaterial(NxMaterialDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Creates a new NxMaterial.

	The material library consists of an array of material objects. Each
	material has a well defined index that can be used to refer to it.
	If an object (shape or triangle) references an undefined material,
	the default material with index 0 is used instead.

	\param[in] matDesc The material desc to use to create a material. See #NxMaterialDesc.
	\return The new material.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxMaterial NxMaterialDesc releaseMaterial()

</member>
        <member name="M:NxScene.setForceFieldScale(System.UInt16,System.UInt16,System.Single)">
	\brief Set the scaling value for a given variety/material pair.
	\param[in] var A Variety index.
	\param[in] mat A Material index.
	\param[in] val The value to set at the variety/material coordinate in the table. Setting the value to big or to low may cause invalid floats in the kernel output.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxScene.getForceFieldScale(System.UInt16,System.UInt16)">
	\brief Get the scaling value for a given variety/material pair.
	\return The scaling value for a given variety/material pair.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxScene.releaseForceFieldMaterial(System.UInt16)">
	\brief Releases a forcefield material index and the related column in the scaling table.
	\param[in] mat The material index to release.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxScene.getHighestForceFieldMaterial">
	\brief Returns the highest allocated force field material.
	\return The highest allocated force field material. See #NxForceFieldMaterial

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxScene.createForceFieldMaterial">
	\brief Creates a new index for objects(actor, fluid, cloth, softbody) to access the scaling table, creates a new column in the scaling table.
	\return NxForceFieldMaterial See #NxForceFieldMaterial

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxScene.releaseForceFieldVariety(System.UInt16)">
	\brief Releases a forcefield variety index and the related row in the scaling table.
	\param[in] mat The variery index to release.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxScene.getHighestForceFieldVariety">
	\brief Returns the highest allocated force field variety.
	\return Highest variety index See #NxForceFieldVariety

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxScene.getNextForceFieldShapeGroup">
	\brief Retrieves the next shape group when iterating.
	\return NxForceFieldShapeGroup. See #NxForceFieldShapeGroup

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxScene.resetForceFieldShapeGroupsIterator">
\brief Restarts the shape groups iterator so that the next call to getNextForceFieldShapeGroup() returns the first shape group in the force scene. 

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes [SW fallback]
\li PS3  : Yes
\li XB360: Yes

</member>
        <member name="M:NxScene.getNbForceFieldShapeGroups">
	\brief Returns the number of shape groups in the scene.

	\return The number of shape groups in the scene.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxScene.releaseForceFieldShapeGroup(NxForceFieldShapeGroup*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Releases a force field shape group.

	\param[in] group The group which is to be relased. See #NxForceFieldShapeGroup.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxScene.createForceFieldShapeGroup(NxForceFieldShapeGroupDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Creates a new force field shape group.  

	\param[in] desc The force field group descriptor. See #NxForceFieldShapeGroupDesc.
	\return NxForceFieldShapeGroup. See #NxForceFieldShapeGroup

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxScene.getNextForceFieldLinearKernel">
	\brief Retrieves the next linear kernel when iterating. 

	\return NxForceFieldLinearKernel  

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxScene.resetForceFieldLinearKernelsIterator">
	\brief Restarts the linear kernels iterator so that the next call to getNextForceFieldLinearKernel(). 

	\return The first shape group in the force scene.  

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxScene.getNbForceFieldLinearKernels">
	\brief Returns the number of linear kernels in the scene. 

	\return number of linear kernels in the scene.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxScene.releaseForceFieldLinearKernel(NxForceFieldLinearKernel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief releases a linear force field kernel
	\param[in] kernel to be released.
	\return NxForceFieldLinearKernel. See #NxForceFieldLinearKernel

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxScene.createForceFieldLinearKernel(NxForceFieldLinearKernelDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief creates a forcefield kernel which uses the same linear function as pre 2.8 force fields

	\param[in] kernelDesc The linear kernel desc to use to create a linear kernel for force fields. See #NxForceFieldLinearKernelDesc.
	\return NxForceFieldLinearKernel. See #NxForceFieldLinearKernel

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxScene.getForceFields">
	\brief Gets the force fields in the scene.

	\return Array of pointers to NxForceField objects. Use #getNbForceFields to find the size of the array.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxScene.getNbForceFields">
	\brief Gets the number of force fields in the scene.

	\return The force field count.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxScene.releaseForceField(NxForceField*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Deletes the force field passed.

	Do not keep a reference to the deleted instance.
	Avoid release calls while the scene is simulating (in between simulate() and fetchResults() calls).

	\param[in] forceField The effector to delete.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see createForceField NxForceField

</member>
        <member name="M:NxScene.createForceField(NxForceFieldDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Creates a force field.

	\param[in] forceFieldDesc The descriptor for the force field to create. See #NxForceFieldDesc.
	\return The new force field.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

	@see releaseForceField NxForceField NxForceFieldDesc

</member>
        <member name="M:NxScene.releaseEffector(NxEffector*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Deletes the effector passed.

	Do not keep a reference to the deleted instance.
	Avoid release calls while the scene is simulating (in between simulate() and fetchResults() calls).

	<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.

	\param[in] effector The effector to delete.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see createSpringAndDamperEffector NxSpringAndDamperEffector

</member>
        <member name="M:NxScene.createEffector(NxEffectorDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Creates an effector.

	\param[in] desc The descriptor for the effector to create. See #NxEffectorDesc.
	\return The new effector.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSpringAndDamperEffectorDesc NxSpringAndDamperEffector releaseEffector()

</member>
        <member name="M:NxScene.createSpringAndDamperEffector(NxSpringAndDamperEffectorDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Deprecated.  Use createEffector() instead.

	<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.

	\param[in] springDesc The descriptor for the spring and damper effector to create. See #NxSpringAndDamperEffectorDesc.
	\return The new spring and damper.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSpringAndDamperEffectorDesc NxSpringAndDamperEffector releaseEffector()

</member>
        <member name="M:NxScene.releaseJoint(NxJoint*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Deletes the specified joint.
	
	The joint must be in this scene.
	Do not keep a reference to the deleted instance.
	Avoid release calls while the scene is simulating (in between simulate() and fetchResults() calls).

	<b>Sleeping:</b> This call wakes the actor(s) if they are sleeping.

	\param[in] joint The joint to release.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxScene.createJoint(NxJointDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Creates a joint.
	
	The joint type depends on the type of joint desc passed in.

	<b>Sleeping:</b> This call wakes the actor(s) if they are sleeping.

	\param[in] jointDesc The descriptor for the joint to create. E.g. #NxSphericalJointDesc,#NxRevoluteJointDesc etc
	\return The new joint.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Up to 64k per scene)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxJoint NxJointDesc releaseJoint() NxJoint
	@see NxRevoluteJoint NxSphericalJoint NxPrismaticJoint NxCylindricalJoint NxD6Joint NxDistanceJoint
	NxFixedJoint NxPointInPlaneJoint NxPointOnLineJoint

</member>
        <member name="M:NxScene.releaseActor(NxActor*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Deletes the specified actor.
	
	Also releases any body and/or shapes associated with the actor.

	The actor must be in this scene.
	Do not keep a reference to the deleted instance.
	Avoid release calls while the scene is simulating (in between simulate() and fetchResults() calls).

	Note: deleting a static actor will not wake up any sleeping objects that were
	sitting on it. Use a kinematic actor instead to get this behavior.

	Releasing an actor will affect any joints that are connected to the actor.
	Such joints will be moved to a list of "dead joints" and automatically deleted upon 
	scene deletion, or explicitly by the user by calling NxScene::releaseJoint(). It is
	recommended to always remove all joints that reference actors before the actors
	themselves are removed. It is not possible to retrieve the list of dead joints.

	<b>Sleeping:</b> This call will awaken any sleeping actors contacting the deleted actor (directly or indirectly).

	\param[in] actor The actor to release.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see createActor() NxActor

</member>
        <member name="M:NxScene.createActor(NxActorDescBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Create/Release Objects

	\brief Creates an actor in this scene.
	
	NxActorDesc::isValid() must return true.

	<b>Sleeping:</b> This call wakes the actors if they are sleeping.

	\param[in] desc Descriptor for actor to create. See #NxActorDescBase
	\return The new actor.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Limits on numbers and types of actors)
	\li PS3  : Yes
	\li XB360: Yes

	@see NxActor NxActorDesc NxActorDescBase releaseActor()

</member>
        <member name="M:NxScene.getGravity(NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Retrieves the current gravity setting.

	\param[out] vec Used to retrieve the current gravity for the scene.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setGravity() NxSceneDesc.gravity

</member>
        <member name="M:NxScene.setGravity(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets a constant gravity for the entire scene.

	<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.

	\param[in] vec A new gravity vector(e.g. NxVec3(0.0f,-9.8f,0.0f) ) <b>Range:</b> force vector

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSceneDesc.gravity getGravity()

</member>
        <member name="M:NxScene.getInternal">
\brief Gets a private interface to an internal debug object.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

</member>
        <member name="M:NxScene.getSimType">
	\brief Get the simulation type.

	\return The simulation type. See #NxSimulationType

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: No

	@see NxSceneDesc.simType

</member>
        <member name="M:NxScene.getFlags">
	\brief Get the scene flags.

	\return The scene flags. See #NxSceneFlags

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSceneFlags

</member>
        <member name="M:NxScene.saveToDesc(NxSceneDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Saves the Scene descriptor.

	\param[out] desc The descriptor used to retrieve the state of the object.
	\return True on success.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSceneDesc

</member>
        <member name="T:NxScene">
 \brief A scene is a collection of bodies, constraints, and effectors which can interact.

 The scene simulates the behavior of these objects over time. Several scenes may exist 
 at the same time, but each body, constraint, or effector object is specific to a scene 
 -- they may not be shared.

 For example, attempting to create a joint in one scene and then using it to attach
 bodies from a different scene results in undefined behavior.

 <h3>Creation</h3>

 Example:

 \include NxScene_Create.cpp

 @see NxSceneDesc NxPhysicsSDK.createScene() NxPhysicsSDK.releaseScene()


@} 

@} 

@} 
\addtogroup physics
  @{

</member>
        <member name="M:NxProfileData.getNamedZone(NxProfileZoneName)">
\brief Returns some named profile zones.  

Note: though copies of these named zones do appear in the above array, this function may 
return pointers to objects not included above.  May return NULL if the zone is not available.

</member>
        <member name="T:NxProfileData">
\brief Array of profiling data. 

 profileZones points to an array of numZones profile zones.  Zones are sorted such that the parent zones always come before their children.  
 Some zones have multiple parents (code called from multiple places) in which case only the relationship to the first parent is displayed.
 returned by NxScene::readProfileData().

</member>
        <member name="T:NxProfileZoneName">
\brief Names for a number of profile zones that should always be available.  Can be used with NxProfileData::getNamedZone()

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: No

</member>
        <member name="T:NxActiveTransform">
\brief Data struct for use with Active Transform Notification.
Used with NxScene::getActiveTransforms().

@see NxScene

</member>
        <member name="F:NX_WAIT_SHUTDOWN">
	\brief Wait until NxScene.shutdownWorkerThreads() is called.

	@see NxScene.shutdownWorkerThreads

</member>
        <member name="F:NX_WAIT_SIMULATION_END">
	\brief The poll function will wait until the end of the simulation tick for work.

	Valid for pollForWork()

	@see NxScene.pollForWork()

</member>
        <member name="F:NX_WAIT_NONE">
	\brief The poll function will return immediately if there is no work available.

	Valid for pollForWork() and pollForBackgroundWork()

	@see NxScene.pollForWork() NxScene.pollForBackgroundWork()

</member>
        <member name="T:NxThreadPollResult">
\brief Polling result for SDK managed threading.

@see NxScene.pollForWork()

</member>
        <member name="F:NX_THREAD_SHUTDOWN">
	\brief The function returned because the user call shutdownWorkerThreads()

	When the user calls NxScene.shutdownWorkerThreads() the SDK releases all blocked threads.
	Threads which are released return NX_THREAD_SHUTDOWN.	

</member>
        <member name="F:NX_THREAD_SIMULATION_END">
\brief The function returned because the simulation tick finished.

</member>
        <member name="F:NX_THREAD_MOREWORK">
\brief There may be more work waiting for execution.

</member>
        <member name="F:NX_THREAD_NOWORK">
\brief There is no work to execute at the time the function was called.

</member>
        <member name="T:NxSimulationStatus">
 enum to check if a certain part of the SDK has finished.
 used in:
 bool checkResults(NxSimulationStatus, bool block = false)
 bool fetchResults(NxSimulationStatus, bool block = false)

 @see NxScene.checkResults() NxScene.fetchResults()

</member>
        <member name="F:NX_PRIMARY_FINISHED">
\brief Refers to the primary scene having finished.  The scene will still be locked for writing until you call fetchResults(NX_RIGID_BODY_FINISHED).

</member>
        <member name="F:NX_RIGID_BODY_FINISHED">
\brief Refers to the primary scene and all compartments having finished, the new results being readable, and everything being writeable.

</member>
        <member name="T:NxStandardFences">
\brief Enum describing synchronization conditions.

</member>
        <member name="T:NxPairFlag">
\brief Struct used by NxScene::getPairFlagArray().

The high bit of each 32 bit	flag field denotes whether a pair is a shape or an actor pair.
The flags are defined by the enum NxContactPairFlag.

@see NxScene.getPairFlagArray

</member>
        <member name="T:NxActor">
@} 

\brief NxActor is the main simulation object in the physics SDK.

The actor is owned by and contained in a NxScene.

An actor may optionally encapsulate a dynamic rigid body by setting the body member of the
actor's descriptor when it is created. Otherwise the actor will be static (fixed in the world).

<h3>Creation</h3>
Instances of this class are created by calling #NxScene::createActor() and deleted with #NxScene::releaseActor().

See #NxActorDescBase for a more detailed description of the parameters which can be set when creating an actor.

Example (Static Actor):

\include NxActor_CreateStatic.cpp

Example (Dynamic Actor):

\include NxActor_CreateDynamic.cpp

<h3>Visualizations</h3>
\li #NX_VISUALIZE_ACTOR_AXES
\li #NX_VISUALIZE_BODY_AXES
\li #NX_VISUALIZE_BODY_MASS_AXES
\li #NX_VISUALIZE_BODY_LIN_VELOCITY
\li #NX_VISUALIZE_BODY_ANG_VELOCITY
\li #NX_VISUALIZE_BODY_JOINT_GROUPS


@see NxActorDesc NxBodyDesc NxScene.createActor() NxScene.releaseActor()


@} 
\addtogroup physics
  @{


@} 
\addtogroup physics
  @{


@} 
\addtogroup physics
  @{


@} 
\addtogroup physics
  @{


@} 

@} 
\addtogroup physics
  @{


@} 
\addtogroup physics
  @{

\addtogroup physics
  @{

</member>
        <member name="M:NxSoftBodyMesh.getReferenceCount">
	\brief Gets the number of soft body instances referencing this soft body mesh.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBody

</member>
        <member name="M:NxSoftBodyMesh.saveToDesc(NxSoftBodyMeshDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Saves the soft body mesh descriptor. 
	A soft body mesh is created via the cooker. The cooker potentially changes the
	order of the arrays references by the pointers vertices and triangles.
	Since saveToDesc returns the data of the cooked mesh, this data might
	differ from the originally provided data. Note that this is in contrast to the meshData
	member of NxSoftBodyDesc, which is guaranteed to provide data in the same order as
	that used to create the mesh.
	
	\param desc The descriptor used to retrieve the state of the object.
	\return True on success.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyMeshDesc

</member>
        <member name="M:NxSoftBodyMeshDesc.isValid">
\brief Returns true if the current settings are valid

</member>
        <member name="M:NxSoftBodyMeshDesc.setToDefault">
\brief (Re)sets the structure to the default.	

</member>
        <member name="M:NxSoftBodyMeshDesc.#ctor">
\brief Constructor sets to default.

</member>
        <member name="F:NxSoftBodyMeshDesc.vertexFlags">
\brief Pointer to first vertex flag. Flags are of type #NxSoftBodyVertexFlags

Caller may add vertexFlagStrideBytes bytes to the pointer to access the next vertex flag.

</member>
        <member name="F:NxSoftBodyMeshDesc.vertexMasses">
\brief Pointer to first vertex mass.

Caller may add vertexMassStrideBytes bytes to the pointer to access the next vertex mass.

</member>
        <member name="F:NxSoftBodyMeshDesc.flags">
\brief Flags bits, combined from values of the enum ::NxSoftBodyMeshFlags

</member>
        <member name="F:NxSoftBodyMeshDesc.tetrahedra">
	\brief Pointer to first tetrahedron.
	
	Caller may add tetrahedronStrideBytes bytes to the pointer to access the next tetrahedron.
	
	These are quadruples of 0 based indices:
	vert0 vert1 vert2 vert3
	vert0 vert1 vert2 vert3
	vert0 vert1 vert2 vert3
	...

	where vertex is either a 32 or 16 bit unsigned integer. There are numTetrahedra*4 indices.

	This is declared as a void pointer because it is actually either an NxU16 or a NxU32 pointer.

</member>
        <member name="F:NxSoftBodyMeshDesc.vertices">
\brief Pointer to first vertex point.

Caller may add vertexStrideBytes bytes to the pointer to access the next point.

</member>
        <member name="T:NxSoftBodyMeshDesc">
\brief Descriptor class for #NxSoftBodyMesh.

The mesh data is *copied* when an NxSoftBodyMesh object is created from this descriptor. 
After the creation the user may discard the basic mesh data.

@see NxSoftBodyMesh

</member>
        <member name="T:NxSoftBodyVertexFlags">
\brief Soft body vertex flags.

@see NxSoftBodyMeshDesc.vertexFlags

</member>
        <member name="F:NX_SOFTBODY_VERTEX_TEARABLE">
\brief Specifies whether a soft body vertex can be torn.

</member>
        <member name="T:NxSoftBodyMeshFlags">
@} 
\addtogroup softbody
  @{

\addtogroup softbody
  @{

\brief Soft body mesh flags.

@see NxSoftBodyMeshDesc.flags

</member>
        <member name="F:NX_SOFTBODY_MESH_TEARABLE">
	Not supported in current release.

	\brief Specifies whether extra space is allocated for tearing on the PPU.
	If this flag is not set, less memory is needed on the PPU but tearing is not possible.

</member>
        <member name="M:NxSoftBody.setForceFieldMaterial(System.UInt16)">
	\brief Sets the actor's force field material index, default index is 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxSoftBody.getForceFieldMaterial">
	\brief Retrieves the actor's force field material index, default index is 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxSoftBody.getCompartment">
	\brief Retrieves the soft body's simulation compartment, as specified by the user at creation time.
	\return NULL if the soft body is not simulated in a compartment or if it was specified to run in 
	the default soft body compartment, otherwise the simulation compartment.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCompartment

</member>
        <member name="M:NxSoftBody.getName">
	\brief Retrieves the name string set with setName().

	\return Name string associated with object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setName()

</member>
        <member name="M:NxSoftBody.getScene">
	\brief Retrieves the scene which this soft body belongs to.

	\return Owner Scene.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxScene

</member>
        <member name="M:NxSoftBody.overlapAABBTetrahedra(NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Finds tetrahedra touching the input bounds.

	\warning This method returns a pointer to an internal structure using the indices member. Hence the
	user should use or copy the indices before calling any other API function.

	\param[in] bounds Bounds to test against in world space. <b>Range:</b> See #NxBounds3
	\param[out] nb Retrieves the number of tetrahedral indices touching the AABB.
	\param[out] indices Returns an array of touching tetrahedra indices. 
	The tetrahedral indices correspond to the tetrahedra referenced to by NxSoftBodyDesc.meshdata (#NxMeshData).
	Tetrahedron i has the vertices 4i, 4i+1, 4i+2 and 4i+3  in the array NxMeshData.indicesBegin.
	\return True if there is an overlap.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBounds3 NxSoftBodyDesc NxMeshData

</member>
        <member name="M:NxSoftBody.addForceAtPos(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,NxForceMode)">
	\brief Applies a radial force (or impulse) at a particular position. All vertices
	within radius will be affected with a quadratic drop-off. 

	Because forces are reset at the end of every timestep, 
	you can maintain a total external force on an object by calling this once every frame.

    ::NxForceMode determines if the force is to be conventional or impulsive.

	\param[in] position Position to apply force at.
	\param[in] magnitude Magnitude of the force/impulse to apply.
	\param[in] radius The sphere radius in which particles will be affected. <b>Range:</b> position vector
	\param[in] mode The mode to use when applying the force/impulse 
	(see #NxForceMode, supported modes are NX_FORCE, NX_IMPULSE, NX_ACCELERATION, NX_VELOCITY_CHANGE).

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxForceMode 

</member>
        <member name="M:NxSoftBody.addForceAtVertex(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,NxForceMode)">
	\brief Applies a force (or impulse) defined in the global coordinate frame, to a particular 
	vertex of the soft body. 

	Because forces are reset at the end of every timestep, 
	you can maintain a total external force on an object by calling this once every frame.

    ::NxForceMode determines if the force is to be conventional or impulsive.

	\param[in] force Force/impulse to add, defined in the global frame. <b>Range:</b> force vector
	\param[in] vertexId Number of the vertex to add the force at. <b>Range:</b> position vector
	\param[in] mode The mode to use when applying the force/impulse 
	(see #NxForceMode, supported modes are NX_FORCE, NX_IMPULSE, NX_ACCELERATION, NX_VELOCITY_CHANGE)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxForceMode 

</member>
        <member name="M:NxSoftBody.setName(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
	\brief Sets a name string for the object that can be retrieved with getName().
	
	This is for debugging and is not used by the SDK. The string is not copied by 
	the SDK, only the pointer is stored.

	\param[in] name String to set the objects name to.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getName()

</member>
        <member name="M:NxSoftBody.getFlags">
	\brief Retrieves the flags.

	\return The soft body flags.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.flags NxSoftBodyFlag setFlags()

</member>
        <member name="M:NxSoftBody.setFlags(System.UInt32)">
	\brief Sets the flags, a combination of the bits defined by the enum ::NxSoftBodyFlag.

	\param[in] flags #NxSoftBodyFlag combination.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.flags NxSoftBodyFlag getFlags()

</member>
        <member name="M:NxSoftBody.putToSleep">
	\brief Forces the soft body to sleep. 
	
	The soft body will fall asleep.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see isSleeping() getSleepLinearVelocity() wakeUp()

</member>
        <member name="M:NxSoftBody.wakeUp(System.Single)">
	\brief Wakes up the soft body if it is sleeping.  

	The wakeCounterValue determines how long until the soft body is put to sleep, a value of zero means 
	that the soft body is sleeping. wakeUp(0) is equivalent to NxSoftBody::putToSleep().

	\param[in] wakeCounterValue New sleep counter value. <b>Range:</b> [0,inf]
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see isSleeping() getSleepLinearVelocity() putToSleep()

</member>
        <member name="M:NxSoftBody.setSleepLinearVelocity(System.Single)">
	\brief Sets the linear velocity below which a soft body may go to sleep.
	
	A soft body whose linear velocity is above this threshold will not be put to sleep.
	
	If the threshold value is negative,	the velocity threshold is set using the NxPhysicsSDK's 
	NX_DEFAULT_SLEEP_LIN_VEL_SQUARED parameter.
    
	\param[in] threshold Linear velocity below which a soft body may sleep. <b>Range:</b> (0,inf]

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see isSleeping() getSleepLinearVelocity() wakeUp() putToSleep()

</member>
        <member name="M:NxSoftBody.getSleepLinearVelocity">
	\brief Returns the linear velocity below which a soft body may go to sleep.
	
	A soft body whose linear velocity is above this threshold will not be put to sleep.
    
    @see isSleeping

	\return The threshold linear velocity for sleeping.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see isSleeping() getSleepLinearVelocity() wakeUp() putToSleep() setSleepLinearVelocity()

</member>
        <member name="M:NxSoftBody.isSleeping">
	\brief Returns true if this soft body is sleeping.

	When a soft body does not move for a period of time, it is no longer simulated in order to save time. This state
	is called sleeping. However, because the object automatically wakes up when it is either touched by an awake object,
	or one of its properties is changed by the user, the entire sleep mechanism should be transparent to the user.
	
	If a soft body is asleep after the call to NxScene::fetchResults() returns, it is guaranteed that the position of the soft body 
	vertices was not changed. You can use this information to avoid updating dependent objects.
	
	\return True if the soft body is sleeping.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see isSleeping() getSleepLinearVelocity() wakeUp() putToSleep()

</member>
        <member name="M:NxSoftBody.getMinAdhereVelocity">
	\brief If the NX_SBF_ADHERE flag is set the soft body moves partially in the frame 
	of the attached actor. 

	This feature is useful when the soft body is attached to a fast moving shape.
	In that case the soft body adheres to the shape it is attached to while only 
	velocities below the parameter minAdhereVelocity are used for secondary effects.

	\return Returns the minimal velocity for the soft body to adhere (unit length / s)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.minAdhereVelocity setMinAdhereVelocity()

</member>
        <member name="M:NxSoftBody.setMinAdhereVelocity(System.Single)">
	\brief If the NX_SBF_ADHERE flag is set the soft body moves partially in the frame 
	of the attached actor. 

	This feature is useful when the soft body is attached to a fast moving shape.
	In that case the soft body adheres to the shape it is attached to while only 
	velocities below the parameter minAdhereVelocity are used for secondary effects.

	\param[in] velocity The minimal velocity for the soft body to adhere (unit length / s)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.minAdhereVelocity getMinAdhereVelocity()

</member>
        <member name="M:NxSoftBody.getExternalAcceleration">
	\brief Retrieves the external acceleration which affects all non attached particles of the soft body

	\return The acceleration vector (unit length / s^2)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.externalAcceleration setExternalAcceleration()

</member>
        <member name="M:NxSoftBody.setExternalAcceleration(NxVec3)">
	\brief Sets an external acceleration which affects all non attached particles of the soft body

	\param[in] acceleration The acceleration vector (unit length / s^2)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.externalAcceleration getExternalAcceleration()

</member>
        <member name="M:NxSoftBody.getToFluidResponseCoefficient">
	\brief Retrieves response coefficient for collisions from this soft body to fluids

	\return The response coefficient.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.toFluidResponseCoefficient setToFluidResponseCoefficient()

</member>
        <member name="M:NxSoftBody.setToFluidResponseCoefficient(System.Single)">
	\brief Sets the response coefficient for collisions from this soft body to fluids

	\param[in] coefficient The response coefficient 

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.toFluidResponseCoefficient getToFluidResponseCoefficient()

</member>
        <member name="M:NxSoftBody.getFromFluidResponseCoefficient">
	\brief Retrieves response coefficient for collisions from fluids to this soft body

	\return The response coefficient.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.fromFluidResponseCoefficient setFromFluidResponseCoefficient()

</member>
        <member name="M:NxSoftBody.setFromFluidResponseCoefficient(System.Single)">
	\brief Sets the response coefficient for collisions from fluids to this soft body

	\param[in] coefficient The response coefficient 

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.fromFluidResponseCoefficient getFromFluidResponseCoefficient()

</member>
        <member name="M:NxSoftBody.getAttachmentResponseCoefficient">
	\brief Retrieves the attachment response coefficient

	\return The attachment response coefficient.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.attachmentResponseCoefficient setAttachmentResponseCoefficient()

</member>
        <member name="M:NxSoftBody.setAttachmentResponseCoefficient(System.Single)">
	\brief Sets the attachment response coefficient

	\param[in] coefficient The attachment response coefficient in the range from 0 to 1.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.attachmentResponseCoefficient getAttachmentResponseCoefficient()

</member>
        <member name="M:NxSoftBody.getCollisionResponseCoefficient">
	\brief Retrieves the collision response coefficient.

	\return The collision response coefficient.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.collisionResponseCoefficient setCollisionResponseCoefficient()

</member>
        <member name="M:NxSoftBody.setCollisionResponseCoefficient(System.Single)">
	\brief Sets the collision response coefficient.

	\param[in] coefficient The collision response coefficient (0 or greater).
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.collisionResponseCoefficient getCollisionResponseCoefficient()

</member>
        <member name="M:NxSoftBody.loadStateFromStream(NxStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Loads the current soft body state from a stream. 
	
	setShapePointers must be called prior to this function if attachments and collisions are to be loaded. 
	Tearable soft bodies are currently not supported.
	A saved state contains platform specific data and can thus only be loaded on back on the same platform.

	\param[in] stream The user supplied stream that holds the soft body state.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see saveStateToStream() queryShapePointers() getShapePointers() setShapePointers() 

</member>
        <member name="M:NxSoftBody.saveStateToStream(NxStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
	\brief Saves the current soft body state to a stream. 
	
	queryShapePointers must be called prior to this function in order for attachments and collisions to be saved. 
	Tearable soft bodies are currently not supported.
	A saved state contains platform specific data and can thus only be loaded on back on the same platform.

	\param[in] stream The user supplied stream to hold the soft body state.
	\param[in] permute If true, the order of the vertices output will correspond to that of the associated
	NxSoftBodyMesh's saveToDesc mehod; if false (the default), it will correspond to the original NxSoftBodyMesh descriptor
	used to create the mesh. These may differ due to cooking.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see loadStateFromStream() queryShapePointers() getShapePointers() setShapePointers() 

</member>
        <member name="M:NxSoftBody.setShapePointers(NxShape**,System.UInt32)">
	\brief Loads pointers to the currently interacting shapes from memory.

	\param[in] shapePointers The user supplied array that holds the shape pointers. Must be in the exact same order as the shapes were retrieved by getShapePointers.
	\param[in] numShapes The size of the supplied array.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see queryShapePointers() getShapePointers() saveStateToStream() loadStateFromStream()

</member>
        <member name="M:NxSoftBody.getShapePointers(NxShape**,System.UInt32*)">
	\brief Saves pointers to the currently interacting shapes to memory

	\param[in] shapePointers The user supplied array to hold the shape pointers.
	\param[in] flags The optional user supplied array to hold the attachment shape flags for the various shapes.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see queryShapePointers() setShapePointers() saveStateToStream() loadStateFromStream()

</member>
        <member name="M:NxSoftBody.getStateByteSize">
	\brief Gets the byte size of the current soft body state.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getNumberOfParticles()

</member>
        <member name="M:NxSoftBody.queryShapePointers">
	\brief Queries the soft body for the currently interacting shapes. Must be called prior to saveStateToStream in order for attachments and collisons to be saved.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getShapePointers() setShapePointers() saveStateToStream() loadStateFromStream()

</member>
        <member name="M:NxSoftBody.getNumberOfParticles">
	\brief Gets the number of soft body particles.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setVelocities() getVelocities() setPositions() getPositions() 

</member>
        <member name="M:NxSoftBody.getVelocities(System.Void*,System.UInt32)">
	\brief Gets the velocities of the soft body.

	The user must supply a buffer large enough to hold all velocities (i.e same number of elements as number of vertices).

	\param[in] buffer The user supplied buffer to hold all velocities of the soft body.
	\param[in] byteStride The stride in bytes between the velocity vectors in the buffer. Default is size of NxVec3.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setVelocities() setPositions() getPositions() getNumberOfParticles()

</member>
        <member name="M:NxSoftBody.getVelocity(System.UInt32)">
	\brief Gets the velocity of a particular vertex of the soft body.

	\param[in] vertexId Index of the vertex.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setPosition() getPosition() setVelocity() setVelocities() getVelocities()  getNumberOfParticles()

</member>
        <member name="M:NxSoftBody.setVelocities(System.Void*,System.UInt32)">
	\brief Sets the velocities of the soft body.

	The user must supply a buffer containing all velocities (i.e same number of elements as number of vertices).

	\param[in] buffer The user supplied buffer containing all velocities for the soft body.
	\param[in] byteStride The stride in bytes between the velocity vectors in the buffer. Default is size of NxVec3.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getVelocities() setPositions() getPositions() getNumberOfParticles()

</member>
        <member name="M:NxSoftBody.setVelocity(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
	\brief Sets the velocity of a particular vertex of the soft body.

	\param[in] position New velocity of the vertex.
	\param[in] vertexId Index of the vertex.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setPosition() getPosition() getVelocity() setVelocities() getVelocities()  getNumberOfParticles()

</member>
        <member name="M:NxSoftBody.getPositions(System.Void*,System.UInt32)">
	\brief Gets the positions of the soft body.

	The user must supply a buffer large enough to hold all positions (i.e same number of elements as number of particles).

	\param[in] buffer The user supplied buffer to hold all positions of the soft body.
	\param[in] byteStride The stride in bytes between the position vectors in the buffer. Default is size of NxVec3.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setPositions() setVelocities() getVelocities() getNumberOfParticles()

</member>
        <member name="M:NxSoftBody.getPosition(System.UInt32)">
	\brief Gets the position of a particular vertex of the soft body.

	\param[in] vertexId Index of the vertex.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setPosition() setPositions() getPositions() setVelocity() getVelocity() getNumberOfParticles()

</member>
        <member name="M:NxSoftBody.setPositions(System.Void*,System.UInt32)">
	\brief Sets the positions of the soft body.

	The user must supply a buffer containing all positions (i.e same number of elements as number of vertices).

	\param[in] buffer The user supplied buffer containing all positions for the soft body.
	\param[in] byteStride The stride in bytes between the position vectors in the buffer. Default is size of NxVec3.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getPositions() setVelocities() getVelocities() getNumberOfParticles()

</member>
        <member name="M:NxSoftBody.setPosition(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
	\brief Sets the position of a particular vertex of the soft body.

	\param[in] position New position of the vertex.
	\param[in] vertexId Index of the vertex.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getPosition() setPositions() getPositions() setVelocity() getVelocity() getNumberOfParticles()

</member>
        <member name="M:NxSoftBody.getValidBounds(NxBounds3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	Note: Valid bounds do not have an effect on soft bodies in the current version.

	\brief Returns the valid bounds of the soft body in world space.

	\param[out] validBounds The valid bounds.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.validBounds setValidBounds() NxBounds3

</member>
        <member name="M:NxSoftBody.setValidBounds(NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	Note: Valid bounds do not have an effect on soft bodies in the current version.

	\brief Sets the valid bounds of the soft body in world space.

	If the flag NX_SBF_VALIDBOUNDS is set, these bounds defines the volume
	outside of which soft body particles are automatically removed from the simulation. 

	\param[in] validBounds The valid bounds.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.validBounds getValidBounds() NxBounds3

</member>
        <member name="M:NxSoftBody.getSplitPairData">
	\brief Returns a copy of the user buffer wrapper for the soft body split pairs.

	\return User buffer wrapper.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodySplitPairData setSplitPairData() NxSoftBodyDesc.splitPairData

</member>
        <member name="M:NxSoftBody.setSplitPairData(NxSoftBodySplitPairData*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the user buffer wrapper for the soft body split pairs.

	\param[in,out] splitPairData User buffer wrapper.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodySplitPairData NxSoftBodyDesc.splitPairData

</member>
        <member name="M:NxSoftBody.getMeshData">
	\brief Returns a copy of the user buffer wrapper for the soft body mesh.
	
	\return User buffer wrapper.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxMeshData setMeshData() NxSoftBodyDesc.meshData

</member>
        <member name="M:NxSoftBody.setMeshData(NxMeshData*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the user buffer wrapper for the soft body mesh.

	\param[in,out] meshData User buffer wrapper.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxMeshData NxSoftBodyDesc.meshData

</member>
        <member name="M:NxSoftBody.getGroupsMask">
	\brief Sets 128-bit mask used for collision filtering.

	\return The group mask for the soft body.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setGroupsMask() NxGroupsMask

</member>
        <member name="M:NxSoftBody.setGroupsMask(NxGroupsMask!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets 128-bit mask used for collision filtering.

	\param[in] groupsMask The group mask to set for the soft body.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getGroupsMask() NxGroupsMask

</member>
        <member name="M:NxSoftBody.getGroup">
	\brief Retrieves the value set with #setGroup().

	\return The collision group this soft body belongs to.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCollisionGroup

</member>
        <member name="M:NxSoftBody.setGroup(System.UInt16)">
	\brief Sets which collision group this soft body is part of.

	\param[in] collisionGroup The collision group for this soft body.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCollisionGroup

</member>
        <member name="M:NxSoftBody.raycast(NxRay!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Executes a raycast against the soft body.

	\param[in] worldRay The ray in world space.
	\param[out] hit The hit position.
	\param[out] vertexId Index to the nearest vertex hit by the raycast.

	\return true if the ray hits the soft body.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxSoftBody.tearVertex(System.UInt32!System.Runtime.CompilerServices.IsConst,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\note Experimental feature, not yet fully supported.

	\brief [Experimental] Tears the soft body at a given vertex. 

	First the vertex is duplicated. The tetrahedra on one side of the split plane keep 
	the original vertex. For all tetrahedra on the opposite side the original vertex is 
	replaced by the new one. The split plane is defined by the world location of the 
	vertex and the normal provided by the user.

	Note: TearVertex performs a user defined vertex split in contrast to an automatic split
	that is performed when the flag NX_SBF_TEARABLE is set. Therefore, tearVertex works 
	even if NX_SBF_TEARABLE is not set in NxSoftBodyDesc.flags.

	Note: For tearVertex to work in hardware mode, the softBodyMesh has to be cooked with the
	flag NX_SOFTBODY_MESH_TEARABLE set in NxSoftBodyMeshDesc.flags.

	\param[in] vertexId Index of the vertex to tear.
	\param[in] normal The normal of the split plane.
	\return true if the split had an effect (i.e. there were tetrahedra on both sides of the split plane)

	@see NxSoftBodyFlag, NxSoftBodyMeshFlags, NxSoftBodyDesc.flags

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxSoftBody.freeVertex(System.UInt32!System.Runtime.CompilerServices.IsConst)">
	\brief Frees a previously attached soft body vertex.

	\param[in] vertexId Index of the vertex to free.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see attachVertexToGlobalPosition() attachVertexToShape() detachFromShape()

</member>
        <member name="M:NxSoftBody.attachVertexToGlobalPosition(System.UInt32!System.Runtime.CompilerServices.IsConst,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Attaches a soft body vertex to a position in world space.

	\param[in] vertexId Index of the vertex to attach.
	\param[in] pos The position in world space.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyAttachmentFlag NxSoftBodyDesc.attachmentTearFactor NxSoftBodyDesc.attachmentResponseCoefficient freeVertex() attachToShape()

</member>
        <member name="M:NxSoftBody.attachVertexToShape(System.UInt32,NxShape!System.Runtime.CompilerServices.IsConst*,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
	\brief Attaches a soft body vertex to a local position within a shape.

	\param[in] vertexId Index of the vertex to attach.
	\param[in] shape Shape to attach the vertex to.
	\param[in] localPos The position relative to the pose of the shape.
	\param[in] attachmentFlags One or two way interaction, tearable or non-tearable

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShape freeVertex() NxSoftBodyAttachmentFlag attachToShape()

</member>
        <member name="M:NxSoftBody.detachFromShape(NxShape!System.Runtime.CompilerServices.IsConst*)">
	\brief Detaches the soft body from a shape it has been attached to before. 

	If the soft body has not been attached to the shape before, the call has no effect.

	\param[in] shape Shape from which the soft body should be detached.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyAttachmentFlag NxSoftBodyDesc.attachmentTearFactor NxSoftBodyDesc.attachmentResponseCoefficient freeVertex() attachToShape()

</member>
        <member name="M:NxSoftBody.attachToCollidingShapes(System.UInt32)">
	\brief Attaches the soft body to all shapes, currently colliding. 

	\note This method only works with primitive and convex shapes. Since the inside of a general 
	triangle mesh is not clearly defined.
	\note Collisions with attached shapes are automatically switched off to increase the stability.

	\param[in] attachmentFlags One or two way interaction, tearable or non-tearable

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyAttachmentFlag NxSoftBodyDesc.attachmentTearFactor NxSoftBodyDesc.attachmentResponseCoefficient freeVertex()

</member>
        <member name="M:NxSoftBody.attachToShape(NxShape!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
	\brief Attaches the soft body to a shape. All soft body vertices currently inside the shape are attached.

	\note This method only works with primitive and convex shapes. Since the inside of a general 
	triangle mesh is not clearly defined.
	\note Collisions with attached shapes are automatically switched off to increase the stability.

	\param[in] shape Shape to which the soft body should be attached to.
	\param[in] attachmentFlags One or two way interaction, tearable or non-tearable
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyAttachmentFlag freeVertex() attachToCollidingShapes()

</member>
        <member name="M:NxSoftBody.getWorldBounds(NxBounds3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Returns a world space AABB enclosing all soft body particles.

	\param[out] bounds Retrieves the world space bounds.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBounds3

</member>
        <member name="M:NxSoftBody.setSolverIterations(System.UInt32)">
	\brief Sets the soft body solver iterations.

	\param[in] iterations The new solver iteration count for the soft body.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.solverIterations getSolverIterations()

</member>
        <member name="M:NxSoftBody.getSolverIterations">
	\brief Retrieves the soft body solver iterations.

	\return solver iterations of the soft body.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.solverIterations setSolverIterations()

</member>
        <member name="M:NxSoftBody.getRelativeGridSpacing">
	\brief Gets the relative grid spacing for the broad phase.
	The soft body is represented by a set of world aligned cubical cells in broad phase.
	The size of these cells is determined by multiplying the length of the diagonal
	of the AABB of the initial soft body size with this constant.

	\return relative grid spacing.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.relativeGridSpacing

</member>
        <member name="M:NxSoftBody.getDensity">
	\brief Gets the soft body density.

	\return density of the soft body.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.density

</member>
        <member name="M:NxSoftBody.getParticleRadius">
	\brief Gets the soft body particle radius.

	\return particle radius of the soft body.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.particleRadius setParticleRadius()

</member>
        <member name="M:NxSoftBody.setParticleRadius(System.Single)">
	\brief Sets the soft body particle radius (must be positive).

	\param[in] particleRadius The particle radius of the soft body.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.particleRadius getParticleRadius()

</member>
        <member name="M:NxSoftBody.getAttachmentTearFactor">
	\brief Retrieves the attachment soft body tear factor.

	\return tear attachment factor of the soft body.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.attachmentTearFactor setAttachmentTearFactor()

</member>
        <member name="M:NxSoftBody.setAttachmentTearFactor(System.Single)">
	\brief Sets the soft body attachment tear factor (must be larger than one).

	\param[in] factor The attachment tear factor for the soft body

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.attachmentTearFactor getAttachmentTearFactor()

</member>
        <member name="M:NxSoftBody.getTearFactor">
	\brief Retrieves the soft body tear factor.

	\return tear factor of the soft body.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.tearFactor setTearFactor()

</member>
        <member name="M:NxSoftBody.setTearFactor(System.Single)">
	\brief Sets the soft body tear factor (must be larger than one).

	\param[in] factor The tear factor for the soft body

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.tearFactor getTearFactor()

</member>
        <member name="M:NxSoftBody.getFriction">
	\brief Retrieves the soft body friction coefficient.

	\return Friction coefficient of the soft body.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes
	
	@see NxSoftBodyDesc.friction setFriction()

</member>
        <member name="M:NxSoftBody.setFriction(System.Single)">
	\brief Sets the soft body friction coefficient in the range from 0 to 1.

	\param[in] friction The friction of the soft body.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.friction getFriction()

</member>
        <member name="M:NxSoftBody.getDampingCoefficient">
	\brief Retrieves the damping coefficient.

	\return damping coefficient of the soft body.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes
	
	@see NxSoftBodyDesc.dampingCoefficient setDampingCoefficient()

</member>
        <member name="M:NxSoftBody.setDampingCoefficient(System.Single)">
	\brief Sets the damping coefficient in the range from 0 to 1.

	\param[in] dampingCoefficient damping coefficient of the soft body.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.dampingCoefficient getDampingCoefficient()

</member>
        <member name="M:NxSoftBody.getStretchingStiffness">
	\brief Retrieves the soft body stretching stiffness.

	\return stretching stiffness of the soft body.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.stretchingStiffness setStretchingStiffness()

</member>
        <member name="M:NxSoftBody.setStretchingStiffness(System.Single)">
	\brief Sets the soft body stretching stiffness in the range from 0 to 1.

	Note: The stretching stiffness must be larger than 0.

	\param[in] stiffness Stiffness of the soft body.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.stretchingStiffness getStretchingStiffness()

</member>
        <member name="M:NxSoftBody.getVolumeStiffness">
	\brief Retrieves the soft body volume stiffness.

	\return Volume stiffness of the soft body.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.volumeStiffness setVolumeStiffness()

</member>
        <member name="M:NxSoftBody.setVolumeStiffness(System.Single)">
	\brief Sets the soft body volume stiffness in the range from 0 to 1.
 
	\param[in] stiffness The volume stiffness of this soft body.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.volumeStiffness getVolumeStiffness()

</member>
        <member name="M:NxSoftBody.getSoftBodyMesh">
	\brief Returns a pointer to the corresponding soft body mesh.

	\return The soft body mesh associated with this soft body.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.softBodyMesh

</member>
        <member name="M:NxSoftBody.saveToDesc(NxSoftBodyDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Saves the soft body descriptor.

	\param[out] desc The descriptor used to retrieve the state of the object.
	\return True on success.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc

</member>
        <member name="M:NxSoftBodyDesc.isValid">
\brief Returns true if the current settings are valid

</member>
        <member name="M:NxSoftBodyDesc.setToDefault">
\brief (Re)sets the structure to the default.	

</member>
        <member name="M:NxSoftBodyDesc.#ctor">
\brief Constructor sets to default.

</member>
        <member name="F:NxSoftBodyDesc.compartment">
	\brief The compartment to place the soft body in. The soft body feature currently uses the cloth 
	simulation, so this must be either a pointer to an NxCompartment of type NX_SCT_SOFTBODY 
	(or NX_SCT_CLOTH, since cloth and softbody currently use the same compartments), or NULL.
	A NULL compartment means creating the soft body in the first available cloth compartment 
	(a default cloth compartment is created if none exists). A software soft body with a NULL 
	compartment is created in the scene on which createSoftBody() is called.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	<b>Default:</b> NULL

</member>
        <member name="F:NxSoftBodyDesc.name">
	\brief Possible debug name. The string is not copied by the SDK, only the pointer is stored.

	<b>Default:</b> NULL

	@see NxSoftBody.setName() NxSoftBody.getName()

</member>
        <member name="F:NxSoftBodyDesc.userData">
	\brief Will be copied to NxSoftBody::userData

	<b>Default:</b> NULL

	@see NxSoftBody.userData

</member>
        <member name="F:NxSoftBodyDesc.flags">
	\brief Flag bits.

	<b>Default:</b> NX_SBF_GRAVITY | NX_SBF_VOLUME_CONSERVATION

	@see NxSoftBodyFlag NxSoftBody.setFlags()

</member>
        <member name="F:NxSoftBodyDesc.validBounds">
	\brief If the flag NX_SBF_VALIDBOUNDS is set, this variable defines the volume
	outside of which soft body particles are automatically removed from the simulation. 

	@see NX_SBF_VALIDBOUNDS NxSoftBody.setValidBounds()

</member>
        <member name="F:NxSoftBodyDesc.forceFieldMaterial">
	\brief Force Field Material Index, index != 0 has to be created.

	<b>Default:</b> 0

</member>
        <member name="F:NxSoftBodyDesc.groupsMask">
	\brief Sets the 128-bit mask used for collision filtering.

	<b>Default:</b> 0

	@see NxGroupsMask NxSoftBody.setGroupsMask() NxSoftBody.getGroupsMask()

</member>
        <member name="F:NxSoftBodyDesc.collisionGroup">
	\brief Sets which collision group this soft body is part of.

	<b>Range:</b> [0, 31]
	<b>Default:</b> 0

	NxSoftBody.setCollisionGroup()

</member>
        <member name="F:NxSoftBodyDesc.splitPairData">
\brief 	The buffers in splitPairData are used to communicate the split tetrahedra data of the soft body back to the user.

@see NxSoftBodySplitPairData

</member>
        <member name="F:NxSoftBodyDesc.meshData">
	\brief The buffers in meshData are used to communicate the dynamic data of the soft body back to the user.
	
	For example vertex positions and connectivity (tetrahedra). The internal order
	of the contents of meshData's buffers will remain the same as that in the initial mesh data used to create the mesh.

	<b>Default:</b> See #NxMeshData

	@see NxMeshData NxSoftBody.setMeshData()

</member>
        <member name="F:NxSoftBodyDesc.externalAcceleration">
	\brief External acceleration which affects all non attached particles of the soft body. 

	<b>Default:</b> (0,0,0)

	@see NxSoftBody.setExternalAcceleration()

</member>
        <member name="F:NxSoftBodyDesc.solverIterations">
	\brief Number of solver iterations. 

	Note: Small numbers make the simulation faster while the soft body gets less stiff.

	<b>Default:</b> 5
	<b>Range:</b> [1,inf)

	@see NxSoftBody.setSolverIterations()

</member>
        <member name="F:NxSoftBodyDesc.minAdhereVelocity">
	\brief If the NX_SBF_ADHERE flag is set the soft body moves partially in the frame 
	of the attached actor. 

	This feature is useful when the soft body is attached to a fast moving shape.
	In that case the soft body adheres to the shape it is attached to while only 
	velocities below the parameter minAdhereVelocity are used for secondary effects.

	<b>Default:</b> 1.0
	<b>Range:</b> [0,inf)

	@see NX_SBF_ADHERE

</member>
        <member name="F:NxSoftBodyDesc.globalPose">
	\brief The global pose of the soft body in the world.

	<b>Default:</b> Identity Transform

</member>
        <member name="F:NxSoftBodyDesc.softBodyMesh">
	\brief The cooked soft body mesh.

	<b>Default:</b> NULL

	@see NxSoftBodyMesh NxSoftBodyMeshDesc NxSoftBody.getSoftBodyMesh()

</member>
        <member name="T:NxSoftBodyDesc">
\brief Descriptor class for #NxSoftBody.

@see NxSoftBody NxSoftBody.saveToDesc()

</member>
        <member name="M:NxSoftBodySplitPairData.#ctor">
\brief Constructor sets to default.

</member>
        <member name="M:NxSoftBodySplitPairData.isValid">
\brief Returns true if the current settings are valid

</member>
        <member name="M:NxSoftBodySplitPairData.setToDefault">
\brief (Re)sets the structure to the default.	

</member>
        <member name="F:NxSoftBodySplitPairData.splitPairsByteStride">
	\brief The separation (in bytes) between consecutive split pairs.

	The first split pair is found at location <tt>splitPairsBegin</tt>;
	the second is at <tt>splitPairsBegin + splitPairsByteStride</tt>;
	and so on.

</member>
        <member name="F:NxSoftBodySplitPairData.splitPairsBegin">
	\brief The pointer to the user-allocated buffer of split pairs.

	If set to NULL, split pairs are not written.

</member>
        <member name="F:NxSoftBodySplitPairData.numSplitPairsPtr">
	\brief Points to the user-allocated memory holding the number of splits stored in the buffer.

	If the SDK writes to a given split buffer, it also sets the numbers of entries written.
	If this is set to NULL, the SDK can't write to the buffer.

</member>
        <member name="F:NxSoftBodySplitPairData.maxSplitPairs">
	\brief Specifies the maximal number of splits the buffer can hold.

	If there are more splits in one time step than the buffer can hold, some will go unreported.

</member>
        <member name="T:NxSoftBodySplitPairData">
\brief User-side class for receiving tetrahedron split events for torn softbodies.

The user can optionally receive tetrahedron split event data if a soft body gets torn.
One split is represented by a pair of tetrahedron indices and a pair of face indices.
The tetrahedra indices can be used to locate the vertex index quadruple belonging to 
the two mesh tetrahedra involved in split.

Each pair is garantueed to be reported only once.

</member>
        <member name="T:NxSoftBodySplitPair">
\brief User-side class specifying a tetrahedron split generated from a torn soft body.

</member>
        <member name="T:NxSoftBodyAttachmentFlag">
\brief Soft body attachment flags.

@see NxSoftBody.attachToShape() NxSoftBody.attachToCollidingShapes() NxSoftBody.attachVertexToShape()

</member>
        <member name="F:NX_SOFTBODY_ATTACHMENT_TEARABLE">
	\brief When this flag is set, the attachment is tearable.

	@see NxSoftBodyDesc.attachmentTearFactor

</member>
        <member name="F:NX_SOFTBODY_ATTACHMENT_TWOWAY">
	\brief The default is only object-&gt;soft body interaction (one way).

	With this flag set, soft body-&gt;object interaction is turned on as well.
	
	Care should be taken if objects with small masses (either through low 
	density or small volume) are attached, as the simulation may easily become unstable. 
	The NxSoftBodyDesc.attachmentResponseCoefficient field should be used to lower
	the magnitude of the impulse transfer from the soft body to the attached rigid body.

</member>
        <member name="T:NxSoftBodyFlag">
\brief Collection of flags describing the behavior of a soft body.

@see NxSoftBody NxSoftBodyMesh NxSoftBodyMeshDesc

</member>
        <member name="F:NX_SBF_ADHERE">
	\brief Moves soft body partially in the frame of the attached actor. 

	This feature is useful when the soft body is attached to a fast moving shape.
	In that case the soft body adheres to the shape it is attached to while only 
	velocities below the parameter minAdhereVelocity are used for secondary effects.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.minAdhereVelocity

</member>
        <member name="F:NX_SBF_DISABLE_DYNAMIC_CCD">
	\brief Disable continuous collision detection with dynamic actors. 
	Dynamic actors are handled as static ones.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NX_SBF_FLUID_COLLISION">
	\brief Enable/disable collision handling between this soft body and fluids. 

	Note: With the current implementation, do not switch on fluid collision for
	many soft bodies. Create scenes with a few bodies because the memory usage
	increases linearly with the number of soft bodies.
	The performance of the collision detection is dependent on both the particle 
	radius of the soft body and the particle radius of the fluid, so tuning 
	these parameters might improve the performance significantly.

	Note: The current implementation does not obey the NxScene::setGroupCollisionFlag
	settings. If NX_SBF_FLUID_COLLISION is set, collisions will take place even if
	collisions between the groups that the corresponding soft body and fluid belong to are
	disabled.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.fluidCollisionResponseCoefficient

</member>
        <member name="F:NX_SBF_VALIDBOUNDS">
	\brief If the flag NX_SBF_VALIDBOUNDS is set, soft body particles outside the volume
	defined by NxSoftBodyDesc.validBounds are automatically removed from the simulation. 

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.validBounds

</member>
        <member name="F:NX_SBF_COMDAMPING">
	\brief Enable/disable center of mass damping of internal velocities. 

	This flag only has an effect if the flag NX_SBF_DAMPING is set. If set, 
	the global rigid body modes (translation and rotation) are extracted from damping. 
	This way, the soft body can freely move and rotate even under high damping. 
	Use NxSoftBodyDesc.dampingCoefficient to control damping. 

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.dampingCoefficient

</member>
        <member name="F:NX_SBF_HARDWARE">
\brief Defines whether this soft body is simulated on the PPU.

To simulate a soft body on the PPU
set this flag and create the soft body in a regular software scene. 
Note: only use this flag during creation, do not change it using NxSoftBody.setFlags().

</member>
        <member name="F:NX_SBF_TEARABLE">
	\brief Defines whether the soft body is tearable. 
	
	Make sure meshData.maxVertices and the corresponding buffers
	in meshData are substantially larger (e.g. 2x) than the number 
	of original vertices since tearing will generate new vertices.
	When the buffer cannot hold the new vertices anymore, tearing stops.
	If this buffer is chosen big enough, the entire mesh can be 
	torn into all constituent tetrahedral elements. 
	(The theoretical maximum needed is 12 times the original number of vertices. 
	For reasonable mesh topologies, this should never be reached though.)
	
	If the soft body is simulated on the hardware, additional buffer 
	limitations that cannot be controlled by the user exist. Therefore, soft 
	bodies might cease to tear apart further, even though not all space in 
	the user buffer is used up.

	Note: For tearing in hardware, make sure you cook the mesh with
	the flag NX_SOFTBODY_MESH_TEARABLE set in the NxSoftBodyMeshDesc.flags.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.tearFactor NxSoftBodyDesc.meshData NxSoftBodyMeshDesc.flags

</member>
        <member name="F:NX_SBF_COLLISION_TWOWAY">
	\brief Enable/disable two way collision of the soft body with the rigid body scene.
	
	In either case, the soft body is influenced by colliding rigid bodies.
	If NX_SBF_COLLISION_TWOWAY is not set, rigid bodies are not influenced by 
	colliding with the soft body. Use NxSoftBodyDesc.collisionResponseCoefficient to
	control the strength of the feedback force on rigid bodies.

	When using two way interaction care should be taken when setting the density of the attached objects.
	For example if an object with a very low or high density is attached to a soft body then the simulation 
	may behave poorly. This is because impulses are only transfered between the soft body and rigid body solver
	outside the solvers.

	Two way interaction works best when NX_SF_SEQUENTIAL_PRIMARY is set in the primary scene. If not set,
	collision and attachment artifacts may happen.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.collisionResponseCoefficient

</member>
        <member name="F:NX_SBF_DAMPING">
	\brief Enable/disable damping of internal velocities. Use NxSoftBodyDesc.dampingCoefficient
	to control damping.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.dampingCoefficient

</member>
        <member name="F:NX_SBF_VOLUME_CONSERVATION">
	\brief Enable/disable volume conservation. Select volume conservation through 
	NxSoftBodyDesc.volumeStiffness.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.volumeStiffness

</member>
        <member name="F:NX_SBF_GRAVITY">
	\brief Enable/disable gravity. If off, the soft body is not subject to the gravitational force
	of the rigid body scene.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NX_SBF_VISUALIZATION">
	\brief Enable/disable debug visualization. 

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NX_SBF_SELFCOLLISION">
	\brief Enable/disable self-collision handling within a single soft body.
	
	Note: self-collisions are only handled inbetween the soft body's particles, i.e.,
	particles do not collide against the tetrahedra of the soft body.
	The user should therefore specify a large enough particleRadius to avoid
	most interpenetrations. See NxSoftBodyDesc.particleRadius.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NX_SBF_DISABLE_COLLISION">
	\brief Disable collision handling with the rigid body scene. 

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSoftBodyDesc.collisionResponseCoefficient

</member>
        <member name="F:NX_SBF_STATIC">
	\brief Makes the soft body static. 

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="T:NxSoftBodyMesh">
@} 
\addtogroup softbody
  @{

\addtogroup softbody
  @{

</member>
        <member name="M:NxClothMesh.getReferenceCount">
	\brief Gets the number of cloth instances referencing this cloth mesh.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCloth

</member>
        <member name="M:NxClothMesh.saveToDesc(NxClothMeshDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Saves the cloth descriptor. 
	A cloth mesh is created via the cooker. The cooker potentially changes the
	order of the arrays references by the pointers points and triangles.	
	Since saveToDesc returns the data of the cooked mesh, this data might
	differ from the originally provided data. Note that this is in contrast to the meshData
	member of NxClothDesc, which is guaranteed to provide data in the same order as
	that used to create the mesh.
	
	\param desc The descriptor used to retrieve the state of the object.
	\return True on success.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothMeshDesc

</member>
        <member name="T:NxStream">
@} 

@} 

\addtogroup foundation
  @{

\brief Callback class for data serialization.

The user needs to supply an NxStream implementation to a number of methods to allow the SDK to read or write
chunks of binary data. This allows flexibility for the source/destination of the data. For example the NxStream
could store data in a file, memory buffer or custom file format.

\note It is the users resposibility to ensure that the data is written to the appropriate offset. NxStream does not 
expose any seeking functionality.

<h3>Example</h3>

\include NxStream_Example.cpp

@see NxPhysicsSDK.createTriangleMesh() NxPhysicsSDK.createConvexMesh() NxTriangleMesh.load()


</member>
        <member name="M:NxClothMeshDesc.isValid">
\brief Returns true if the current settings are valid

</member>
        <member name="M:NxClothMeshDesc.setToDefault">
\brief (Re)sets the structure to the default.	

</member>
        <member name="M:NxClothMeshDesc.#ctor">
\brief Constructor sets to default.

</member>
        <member name="F:NxClothMeshDesc.weldingDistance">
	\brief For welding close vertices.

	If the NX_CLOTH_MESH_WELD_VERTICES flag is set, the cooker maps close vertices 
	(i.e. vertices closer than NxClothMeshDesc.weldingDistance) to a single internal vertex.
	This is useful when more than one vertex at the same location is used for handling
	multiple texture coordinates. With welding, the mesh does not fall apart when simulated.

	@see NxClothMeshFlags

</member>
        <member name="F:NxClothMeshDesc.vertexFlags">
\brief Pointer to first vertex flag. Flags are of type #NxClothVertexFlags

Caller may add vertexFlagStrideBytes bytes to the pointer to access the next vertex flag.

</member>
        <member name="F:NxClothMeshDesc.vertexMasses">
\brief Pointer to first vertex mass.

Caller may add vertexMassStrideBytes bytes to the pointer to access the next vertex mass.

</member>
        <member name="T:NxClothMeshDesc">
\brief Descriptor class for #NxClothMesh.

Note that this class is derived from NxSimpleTriangleMesh which contains the
members that describe the basic mesh. The mesh data is *copied* when an
NxClothMesh object is created from this descriptor. After the creation the
user may discard the basic mesh data.

@see NxClothMesh NxSimpleTriangleMesh

</member>
        <member name="T:NxClothVertexFlags">
\brief Cloth vertex flags.

@see NxClothMeshDesc.vertexFlags

</member>
        <member name="F:NX_CLOTH_VERTEX_TEARABLE">
\brief Specifies whether a cloth vertex can be torn.

</member>
        <member name="F:NX_CLOTH_VERTEX_ATTACHED">
\brief Specifies whether a cloth vertex is attached to a global position.

</member>
        <member name="T:NxClothMeshFlags">
@} 
\addtogroup cloth
  @{

\addtogroup cloth
  @{

\brief Cloth mesh flags.

@see NxClothMeshDesc.flags

</member>
        <member name="F:NX_CLOTH_MESH_WELD_VERTICES">
	\brief Welds close vertices.

	If this flag is set, the cooker maps close vertices (i.e. vertices closer than
	NxClothMeshDesc.weldingDistance) to a single internal vertex.
	This is useful when more than one vertex at the same location is used for handling
	multiple texture coordinates. With welding, the mesh does not fall apart when simulated.

	@see NxClothMeshDesc.weldingDistance

</member>
        <member name="F:NX_CLOTH_MESH_TEARABLE">
\brief Specifies whether extra space is allocated for tearing.
If this flag is not set, less memory is needed but tearing is not possible.
These flags for clothMeshes extend the set of flags defined in NxMeshFlags.

</member>
        <member name="M:NxCloth.setForceFieldMaterial(System.UInt16)">
	\brief Sets the actor's force field material index, default index is 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxCloth.getForceFieldMaterial">
	\brief Retrieves the actor's force field material index, default index is 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxCloth.getPPUTime">
	\brief Get the PPU simulation time.

	This method returns the time taken to simulate the fluid on the PPU in units
	which are proportional to time but whose units are otherwise unspecified.

	\return the simulation time
	<b>Platform:</b>
	\li PC SW: No
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: No


</member>
        <member name="M:NxCloth.getCompartment">
	\brief Retrieves the cloth's simulation compartment, as specified by the user at creation time.
	\return NULL if the cloth is not simulated in a compartment or if it was specified to run in 
	the default cloth compartment, otherwise the simulation compartment.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCompartment

</member>
        <member name="M:NxCloth.getName">
	\brief Retrieves the name string set with setName().

	\return Name string associated with object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setName()

</member>
        <member name="M:NxCloth.getScene">
	\brief Retrieves the scene which this cloth belongs to.

	\return Owner Scene.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxScene

</member>
        <member name="M:NxCloth.overlapAABBTriangles(NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Finds triangles touching the input bounds.

	\warning This method returns a pointer to an internal structure using the indices member. Hence the
	user should use or copy the indices before calling any other API function.

	\param[in] bounds Bounds to test against in world space. <b>Range:</b> See #NxBounds3
	\param[out] nb Retrieves the number of triangle indices touching the AABB.
	\param[out] indices Returns an array of touching triangle indices. 
	The triangle indices correspond to the triangles referenced to by NxClothDesc.meshdata (#NxMeshData).
	Triangle i has the vertices 3i, 3i+1 and 3i+2 in the array NxMeshData.indicesBegin.
	\return True if there is an overlap.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBounds3 NxClothDesc NxMeshData

</member>
        <member name="M:NxCloth.addDirectedForceAtPos(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,NxForceMode)">
	\brief Applies a directed force (or impulse) at a particular position. All vertices
	within radius will be affected with a quadratic drop-off. 

	Because forces are reset at the end of every timestep, 
	you can maintain a total external force on an object by calling this once every frame.

    ::NxForceMode determines if the force is to be conventional or impulsive.

	\param[in] position Position to apply force at.
	\param[in] force Force to apply.
	\param[in] radius The sphere radius in which particles will be affected. <b>Range:</b> position vector
	\param[in] mode The mode to use when applying the force/impulse 
	(see #NxForceMode, supported modes are NX_FORCE, NX_IMPULSE, NX_ACCELERATION, NX_VELOCITY_CHANGE).

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxForceMode 

</member>
        <member name="M:NxCloth.addForceAtPos(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single,NxForceMode)">
	\brief Applies a radial force (or impulse) at a particular position. All vertices
	within radius will be affected with a quadratic drop-off. 

	Because forces are reset at the end of every timestep, 
	you can maintain a total external force on an object by calling this once every frame.

    ::NxForceMode determines if the force is to be conventional or impulsive.

	\param[in] position Position to apply force at.
	\param[in] magnitude Magnitude of the force/impulse to apply.
	\param[in] radius The sphere radius in which particles will be affected. <b>Range:</b> position vector
	\param[in] mode The mode to use when applying the force/impulse 
	(see #NxForceMode, supported modes are NX_FORCE, NX_IMPULSE, NX_ACCELERATION, NX_VELOCITY_CHANGE).

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxForceMode 

</member>
        <member name="M:NxCloth.addForceAtVertex(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,NxForceMode)">
	\brief Applies a force (or impulse) defined in the global coordinate frame, to a particular 
	vertex of the cloth. 

	Because forces are reset at the end of every timestep, 
	you can maintain a total external force on an object by calling this once every frame.

    ::NxForceMode determines if the force is to be conventional or impulsive.

	\param[in] force Force/impulse to add, defined in the global frame. <b>Range:</b> force vector
	\param[in] vertexId Number of the vertex to add the force at. <b>Range:</b> position vector
	\param[in] mode The mode to use when applying the force/impulse 
	(see #NxForceMode, supported modes are NX_FORCE, NX_IMPULSE, NX_ACCELERATION, NX_VELOCITY_CHANGE)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxForceMode 

</member>
        <member name="M:NxCloth.setName(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
	\brief Sets a name string for the object that can be retrieved with getName().
	
	This is for debugging and is not used by the SDK. The string is not copied by 
	the SDK, only the pointer is stored.

	\param[in] name String to set the objects name to.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getName()

</member>
        <member name="M:NxCloth.getFlags">
	\brief Retrieves the flags.

	\return The cloth flags.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.flags NxClothFlag setFlags()

</member>
        <member name="M:NxCloth.setFlags(System.UInt32)">
	\brief Sets the flags, a combination of the bits defined by the enum ::NxClothFlag.

	\param[in] flags #NxClothFlag combination.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.flags NxClothFlag getFlags()

</member>
        <member name="M:NxCloth.putToSleep">
	\brief Forces the cloth to sleep. 
	
	The cloth will fall asleep.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see isSleeping() getSleepLinearVelocity() wakeUp()

</member>
        <member name="M:NxCloth.wakeUp(System.Single)">
	\brief Wakes up the cloth if it is sleeping.  

	The wakeCounterValue determines how long until the cloth is put to sleep, a value of zero means 
	that the cloth is sleeping. wakeUp(0) is equivalent to NxCloth::putToSleep().

	\param[in] wakeCounterValue New sleep counter value. <b>Range:</b> [0,inf]
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see isSleeping() getSleepLinearVelocity() putToSleep()

</member>
        <member name="M:NxCloth.setSleepLinearVelocity(System.Single)">
	\brief Sets the linear velocity below which a cloth may go to sleep.
	
	A cloth whose linear velocity is above this threshold will not be put to sleep.
	
	If the threshold value is negative,	the velocity threshold is set using the NxPhysicsSDK's 
	NX_DEFAULT_SLEEP_LIN_VEL_SQUARED parameter.
    
	\param[in] threshold Linear velocity below which a cloth may sleep. <b>Range:</b> (0,inf]

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see isSleeping() getSleepLinearVelocity() wakeUp() putToSleep()

</member>
        <member name="M:NxCloth.getSleepLinearVelocity">
	\brief Returns the linear velocity below which a cloth may go to sleep.
	
	A cloth whose linear velocity is above this threshold will not be put to sleep.
    
    @see isSleeping

	\return The threshold linear velocity for sleeping.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see isSleeping() getSleepLinearVelocity() wakeUp() putToSleep() setSleepLinearVelocity()

</member>
        <member name="M:NxCloth.isSleeping">
	\brief Returns true if this cloth is sleeping.

	When a cloth does not move for a period of time, it is no longer simulated in order to save time. This state
	is called sleeping. However, because the object automatically wakes up when it is either touched by an awake object,
	or one of its properties is changed by the user, the entire sleep mechanism should be transparent to the user.
	
	If a cloth is asleep after the call to NxScene::fetchResults() returns, it is guaranteed that the position of the cloth 
	vertices was not changed. You can use this information to avoid updating dependent objects.
	
	\return True if the cloth is sleeping.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see isSleeping() getSleepLinearVelocity() wakeUp() putToSleep()

</member>
        <member name="M:NxCloth.getWindAcceleration">
	\brief Retrieves the acceleration acting normal to the cloth surface at each vertex.

	\return The acceleration vector (unit length / s^2)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.windAcceleration setWindAcceleration()

</member>
        <member name="M:NxCloth.setWindAcceleration(NxVec3)">
	\brief Sets an acceleration acting normal to the cloth surface at each vertex.

	\param[in] acceleration The acceleration vector (unit length / s^2)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.windAcceleration getWindAcceleration()

</member>
        <member name="M:NxCloth.getMinAdhereVelocity">
	\brief If the NX_CLF_ADHERE flag is set the cloth moves partially in the frame 
	of the attached actor. 

	This feature is useful when the cloth is attached to a fast moving character.
	In that case the cloth adheres to the shape it is attached to while only 
	velocities below the parameter minAdhereVelocity are used for secondary effects.

	\return Returns the minimal velocity for cloth to adhere (unit length / s)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.minAdhereVelocity setMinAdhereVelocity()

</member>
        <member name="M:NxCloth.setMinAdhereVelocity(System.Single)">
	\brief If the NX_CLF_ADHERE flag is set the cloth moves partially in the frame 
	of the attached actor. 

	This feature is useful when the cloth is attached to a fast moving character.
	In that case the cloth adheres to the shape it is attached to while only 
	velocities below the parameter minAdhereVelocity are used for secondary effects.

	\param[in] velocity The minimal velocity for cloth to adhere (unit length / s)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.minAdhereVelocity getMinAdhereVelocity()

</member>
        <member name="M:NxCloth.getExternalAcceleration">
	\brief Retrieves the external acceleration which affects all non attached particles of the cloth

	\return The acceleration vector (unit length / s^2)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.externalAcceleration setExternalAcceleration()

</member>
        <member name="M:NxCloth.setExternalAcceleration(NxVec3)">
	\brief Sets an external acceleration which affects all non attached particles of the cloth

	\param[in] acceleration The acceleration vector (unit length / s^2)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.externalAcceleration getExternalAcceleration()

</member>
        <member name="M:NxCloth.getToFluidResponseCoefficient">
	\brief Retrieves response coefficient for collisions from this cloth to fluids

	\return The response coefficient.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.toFluidResponseCoefficient setToFluidResponseCoefficient()

</member>
        <member name="M:NxCloth.setToFluidResponseCoefficient(System.Single)">
	\brief Sets the response coefficient for collisions from this cloth to fluids

	\param[in] coefficient The response coefficient 

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.toFluidResponseCoefficient getToFluidResponseCoefficient()

</member>
        <member name="M:NxCloth.getFromFluidResponseCoefficient">
	\brief Retrieves response coefficient for collisions from fluids to this cloth

	\return The response coefficient.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.fromFluidResponseCoefficient setFromFluidResponseCoefficient()

</member>
        <member name="M:NxCloth.setFromFluidResponseCoefficient(System.Single)">
	\brief Sets the response coefficient for collisions from fluids to this cloth

	\param[in] coefficient The response coefficient 

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.fromFluidResponseCoefficient getFromFluidResponseCoefficient()

</member>
        <member name="M:NxCloth.getAttachmentResponseCoefficient">
	\brief Retrieves the attachment response coefficient

	\return The attachment response coefficient.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.attachmentResponseCoefficient setAttachmentResponseCoefficient()

</member>
        <member name="M:NxCloth.setAttachmentResponseCoefficient(System.Single)">
	\brief Sets the attachment response coefficient

	\param[in] coefficient The attachment response coefficient in the range from 0 to 1.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.attachmentResponseCoefficient getAttachmentResponseCoefficient()

</member>
        <member name="M:NxCloth.getCollisionResponseCoefficient">
	\brief Retrieves the collision response coefficient.

	\return The collision response coefficient.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.collisionResponseCoefficient setCollisionResponseCoefficient()

</member>
        <member name="M:NxCloth.setCollisionResponseCoefficient(System.Single)">
	\brief Sets the collision response coefficient.

	\param[in] coefficient The collision response coefficient (0 or greater).
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.collisionResponseCoefficient getCollisionResponseCoefficient()

</member>
        <member name="M:NxCloth.loadStateFromStream(NxStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Loads the current cloth state from a stream. 
	
	setShapePointers must be called prior to this function if attachments and collisions are to be loaded. 
	Tearable and metal cloths are currently not supported.
	A saved state contains platform specific data and can thus only be loaded on back on the same platform.

	\param[in] stream The user supplied stream that holds the cloth state.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see saveStateToStream() queryShapePointers() getShapePointers() setShapePointers() 

</member>
        <member name="M:NxCloth.saveStateToStream(NxStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
	\brief Saves the current cloth state to a stream. 
	
	queryShapePointers must be called prior to this function in order for attachments and collisions to be saved. 
	Tearable and metal cloths are currently not supported.
	A saved state contains platform specific data and can thus only be loaded on back on the same platform.

	\param[in] stream The user supplied stream to hold the cloth state.
	\param[in] permute If true, the order of the vertices output will correspond to that of the associated
	NxClothMesh's saveToDesc mehod; if false (the default), it will correspond to the original NxClothMesh descriptor
	used to create the mesh. These may differ due to cooking.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see loadStateFromStream() queryShapePointers() getShapePointers() setShapePointers() 

</member>
        <member name="M:NxCloth.setShapePointers(NxShape**,System.UInt32)">
	\brief Loads pointers to the currently interacting shapes from memory.

	\param[in] shapePointers The user supplied array that holds the shape pointers. Must be in the exact same order as the shapes were retrieved by getShapePointers.
	\param[in] numShapes The size of the supplied array.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see queryShapePointers() getShapePointers() saveStateToStream() loadStateFromStream()

</member>
        <member name="M:NxCloth.getShapePointers(NxShape**,System.UInt32*)">
	\brief Saves pointers to the currently interacting shapes to memory

	\param[in] shapePointers The user supplied array to hold the shape pointers.
	\param[in] flags         The optional user supplied array to hold the cloth attachment flags for each attached shape

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see queryShapePointers() setShapePointers() saveStateToStream() loadStateFromStream()

</member>
        <member name="M:NxCloth.getStateByteSize">
	\brief Gets the byte size of the current cloth state.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getNumberOfParticles()

</member>
        <member name="M:NxCloth.queryShapePointers">
	\brief Queries the cloth for the currently interacting shapes. Must be called prior to saveStateToStream in order for attachments and collisons to be saved.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getShapePointers() setShapePointers() saveStateToStream() loadStateFromStream()

</member>
        <member name="M:NxCloth.getNumberOfParticles">
	\brief Gets the number of cloth particles.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setVelocities() getVelocities() setPositions() getPositions() 

</member>
        <member name="M:NxCloth.getVelocities(System.Void*,System.UInt32)">
	\brief Gets the velocities of the cloth.

	The user must supply a buffer large enough to hold all velocities (i.e same number of elements as number of particles).

	\param[in] buffer The user supplied buffer to hold all velocities of the cloth.
	\param[in] byteStride The stride in bytes between the velocity vectors in the buffer. Default is size of NxVec3.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setVelocities() setPositions() getPositions() getNumberOfParticles()

</member>
        <member name="M:NxCloth.getVelocity(System.UInt32)">
	\brief Gets the velocity of a particular vertex of the cloth.

	\param[in] vertexId Index of the vertex.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setPosition() getPosition() setVelocity() setVelocities() getVelocities()  getNumberOfParticles()

</member>
        <member name="M:NxCloth.setVelocities(System.Void*,System.UInt32)">
	\brief Sets the velocities of the cloth.

	The user must supply a buffer containing all velocities (i.e same number of elements as number of particles).

	\param[in] buffer The user supplied buffer containing all velocities for the cloth.
	\param[in] byteStride The stride in bytes between the velocity vectors in the buffer. Default is size of NxVec3.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getVelocities() setPositions() getPositions() getNumberOfParticles()

</member>
        <member name="M:NxCloth.setVelocity(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
	\brief Sets the velocity of a particular vertex of the cloth.

	\param[in] position New velocity of the vertex.
	\param[in] vertexId Index of the vertex.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setPosition() getPosition() getVelocity() setVelocities() getVelocities()  getNumberOfParticles()

</member>
        <member name="M:NxCloth.getPositions(System.Void*,System.UInt32)">
	\brief Gets the positions of the cloth.

	The user must supply a buffer large enough to hold all positions (i.e same number of elements as number of particles).

	\param[in] buffer The user supplied buffer to hold all positions of the cloth.
	\param[in] byteStride The stride in bytes between the position vectors in the buffer. Default is size of NxVec3.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setPositions() setVelocities() getVelocities() getNumberOfParticles()

</member>
        <member name="M:NxCloth.getPosition(System.UInt32)">
	\brief Gets the position of a particular vertex of the cloth.

	\param[in] vertexId Index of the vertex.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setPosition() setPositions() getPositions() setVelocity() getVelocity() getNumberOfParticles()

</member>
        <member name="M:NxCloth.setPositions(System.Void*,System.UInt32)">
	\brief Sets the positions of the cloth.

	The user must supply a buffer containing all positions (i.e same number of elements as number of particles).

	\param[in] buffer The user supplied buffer containing all positions for the cloth.
	\param[in] byteStride The stride in bytes between the position vectors in the buffer. Default is size of NxVec3.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getPositions() setVelocities() getVelocities() getNumberOfParticles()

</member>
        <member name="M:NxCloth.setPosition(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
	\brief Sets the position of a particular vertex of the cloth.

	\param[in] position New position of the vertex.
	\param[in] vertexId Index of the vertex.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getPosition() setPositions() getPositions() setVelocity() getVelocity() getNumberOfParticles()

</member>
        <member name="M:NxCloth.getValidBounds(NxBounds3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Returns the valid bounds of the cloth in world space.

	\param[out] validBounds The valid bounds.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.validBounds setValidBounds() NxBounds3

</member>
        <member name="M:NxCloth.setValidBounds(NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the valid bounds of the cloth in world space.

	If the flag NX_CLF_VALIDBOUNDS is set, these bounds defines the volume
	outside of which cloth particle are automatically removed from the simulation. 

	\param[in] validBounds The valid bounds.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.validBounds getValidBounds() NxBounds3

</member>
        <member name="M:NxCloth.getMeshData">
	\brief Returns a copy of the user buffer wrapper for the cloth mesh.
	
	\return User buffer wrapper.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxMeshData setMeshData() NxClothDesc.meshData

</member>
        <member name="M:NxCloth.setMeshData(NxMeshData*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the user buffer wrapper for the cloth mesh.

	\param[in,out] meshData User buffer wrapper.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxMeshData NxClothDesc.meshData

</member>
        <member name="M:NxCloth.getGroupsMask">
	\brief Sets 128-bit mask used for collision filtering.

	\return The group mask for the cloth.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setGroupsMask() NxGroupsMask

</member>
        <member name="M:NxCloth.setGroupsMask(NxGroupsMask!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets 128-bit mask used for collision filtering.

	\param[in] groupsMask The group mask to set for the cloth.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getGroupsMask() NxGroupsMask

</member>
        <member name="M:NxCloth.getGroup">
	\brief Retrieves the value set with #setGroup().

	\return The collision group this cloth belongs to.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCollisionGroup

</member>
        <member name="M:NxCloth.setGroup(System.UInt16)">
	\brief Sets which collision group this cloth is part of.

	\param[in] collisionGroup The collision group for this cloth.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCollisionGroup

</member>
        <member name="M:NxCloth.raycast(NxRay!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Executes a raycast against the cloth.

	\param[in] worldRay The ray in world space.
	\param[out] hit The hit position.
	\param[out] vertexId Index to the nearest vertex hit by the raycast.

	\return true if the ray hits the cloth.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxCloth.tearVertex(System.UInt32!System.Runtime.CompilerServices.IsConst,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Tears the cloth at a given vertex. 
	
	First the vertex is duplicated. The triangles on one side of the split plane keep 
	the original vertex. For all triangles on the opposite side the original vertex is 
	replaced by the new one. The split plane is defined by the world location of the 
	vertex and the normal provided by the user.

	Note: TearVertex performs a user defined vertex split in contrast to an automatic split
	that is performed when the flag NX_CLF_TEARABLE is set. Therefore, tearVertex works 
	even if NX_CLF_TEARABLE is not set in NxClothDesc.flags.

	Note: For tearVertex to work, the clothMesh has to be cooked with the flag
	NX_CLOTH_MESH_TEARABLE set in NxClothMeshDesc.flags.

	\param[in] vertexId Index of the vertex to tear.
	\param[in] normal The normal of the split plane.
	\return true if the split had an effect (i.e. there were triangles on both sides of the split plane)

	@see NxClothFlag, NxClothMeshFlags, NxClothDesc.flags NxSimpleTriangleMesh.flags

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxCloth.attachToCore(NxActor*,System.Single,System.Single,System.Single)">
	\brief Attaches the cloth to an actor. 
	
	\note Call this function only once right after the cloth is created.
	Turning cloth into metal and vice versa during the simulation is not recommended.

	\note This feature is well suited for volumetric objects like barrels. 
	It cannot handle two dimensional flat pieces well.
	
	After this call, the cloth is infinitely stiff between collisions and simply 
	moves with the actor. At impacts with an impact impulse greater than impulseThreshold, 
	the cloth is plastically deformed. Thus, a cloth with a core behaves like a piece of metal.

	The core actor's geometry is adjusted automatically. Its size also depends on the 
	cloth thickness. Thus, it is recommended to choose small values for the thickness.
	At impacts, colliding objects are moved closer to the cloth by the value provided in 
	penetrationDepth which causes a more dramatic collision result.

	The core actor must have at least one shape, and currently supported shapes are 
	spheres, capsules, boxes and compounds of spheres.
	It is recommended to specify the density rather than the mass of the core body. 
	This way the mass and inertia tensor are updated when the core deforms.

	The maximal deviation of cloth particles from their initial positions
	(modulo the global rigid body transforms translation and rotation) can be
	specified via the parameter maxDeformationDistance. Setting this parameter to
	zero means that the deformation is not limited.  

	\param actor The core actor to attach the cloth to.
	\param impulseThreshold Threshold for when deformation is allowed.
	\param penetrationDepth Amount by which colliding objects are brought closer to the cloth.
	\param maxDeformationDistance Maximum deviation of cloth particles from initial position.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes


</member>
        <member name="M:NxCloth.getVertexAttachmentPosition(System.UInt32)">
	\brief Returns the attachment position of the given vertex.

	If the vertex is attached to shape, the position local to the shape's pose is returned.
	If the vertex is not attached, the return value is undefined.

	\param[in] vertexId Index of the vertex.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getVertexAttachmentStatus() getVertexAttachmentShape()

</member>
        <member name="M:NxCloth.getVertexAttachmentShape(System.UInt32)">
	\brief Returns the pointer to an attached shape pointer of the given vertex.

	If the vertex is not attached or attached to a global position, NULL is returned.

	\param[in] vertexId Index of the vertex.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getVertexAttachmentStatus() getVertexAttachmentPosition()

</member>
        <member name="M:NxCloth.getVertexAttachmentStatus(System.UInt32)">
	\brief Return the attachment status of the given vertex.

	\param[in] vertexId Index of the vertex.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getVertexAttachmentShape() getVertexAttachmentPosition()

</member>
        <member name="M:NxCloth.freeVertex(System.UInt32!System.Runtime.CompilerServices.IsConst)">
	\brief Frees a previously attached cloth point.

	\param[in] vertexId Index of the vertex to free.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see attachVertexToGlobalPosition() attachVertexToShape() detachFromShape()

</member>
        <member name="M:NxCloth.attachVertexToGlobalPosition(System.UInt32!System.Runtime.CompilerServices.IsConst,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Attaches a cloth vertex to a position in world space.

	\param[in] vertexId Index of the vertex to attach.
	\param[in] pos The position in world space.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothAttachmentFlag NxClothDesc.attachmentTearFactor NxClothDesc.attachmentResponseCoefficient freeVertex() attachToShape()

</member>
        <member name="M:NxCloth.attachVertexToShape(System.UInt32,NxShape!System.Runtime.CompilerServices.IsConst*,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
	\brief Attaches a cloth vertex to a local position within a shape.

	\param[in] vertexId Index of the vertex to attach.
	\param[in] shape Shape to attach the vertex to.
	\param[in] localPos The position relative to the pose of the shape.
	\param[in] attachmentFlags One or two way interaction, tearable or non-tearable

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShape freeVertex() NxClothAttachmentFlag attachToShape()

</member>
        <member name="M:NxCloth.detachFromShape(NxShape!System.Runtime.CompilerServices.IsConst*)">
	\brief Detaches the cloth from a shape it has been attached to before. 

	If the cloth has not been attached to the shape before, the call has no effect.

	\param[in] shape Shape from which the cloth should be detached.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothAttachmentFlag NxClothDesc.attachmentTearFactor NxClothDesc.attachmentResponseCoefficient freeVertex() attachToShape()

</member>
        <member name="M:NxCloth.attachToCollidingShapes(System.UInt32)">
	\brief Attaches the cloth to all shapes, currently colliding. 

	\note This method only works with primitive and convex shapes. Since the inside of a general 
	triangle mesh is not clearly defined.

	\param[in] attachmentFlags One or two way interaction, tearable or non-tearable

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothAttachmentFlag NxClothDesc.attachmentTearFactor NxClothDesc.attachmentResponseCoefficient freeVertex()

</member>
        <member name="M:NxCloth.attachToShape(NxShape!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
	\brief Attaches the cloth to a shape. All cloth points currently inside the shape are attached.

	\note This method only works with primitive and convex shapes. Since the inside of a general 
	triangle mesh is not clearly defined.

	\param[in] shape Shape to which the cloth should be attached to.
	\param[in] attachmentFlags One or two way interaction, tearable or non-tearable
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothAttachmentFlag freeVertex() attachToCollidingShapes()

</member>
        <member name="M:NxCloth.getWorldBounds(NxBounds3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Returns a world space AABB enclosing all cloth points.

	\param[out] bounds Retrieves the world space bounds.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBounds3

</member>
        <member name="M:NxCloth.setSolverIterations(System.UInt32)">
	\brief Sets the cloth solver iterations.

	\param[in] iterations The new solver iteration count for the cloth.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.solverIterations getSolverIterations()

</member>
        <member name="M:NxCloth.getSolverIterations">
	\brief Retrieves the cloth solver iterations.

	\return solver iterations of cloth.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.solverIterations setSolverIterations()

</member>
        <member name="M:NxCloth.getRelativeGridSpacing">
	\brief Gets the relative grid spacing for the broad phase.
	The cloth is represented by a set of world aligned cubical cells in broad phase.
	The size of these cells is determined by multiplying the length of the diagonal
	of the AABB of the initial cloth size with this constant.

	\return relative grid spacing.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.relativeGridSpacing

</member>
        <member name="M:NxCloth.getDensity">
	\brief Gets the cloth density.

	\return density of cloth.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.density

</member>
        <member name="M:NxCloth.getThickness">
	\brief Gets the cloth thickness.

	\return thickness of cloth.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.thickness setThickness()

</member>
        <member name="M:NxCloth.setThickness(System.Single)">
	\brief Sets the cloth thickness (must be positive).

	\param[in] thickness The thickness of the cloth.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.thickness getThickness()

</member>
        <member name="M:NxCloth.getAttachmentTearFactor">
	\brief Retrieves the attachment cloth tear factor.

	\return tear attachment factor of cloth.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.attachmentTearFactor setAttachmentTearFactor()

</member>
        <member name="M:NxCloth.setAttachmentTearFactor(System.Single)">
	\brief Sets the cloth attachment tear factor (must be larger than one).

	\param[in] factor The attachment tear factor for the cloth

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.attachmentTearFactor getAttachmentTearFactor()

</member>
        <member name="M:NxCloth.getTearFactor">
	\brief Retrieves the cloth tear factor.

	\return tear factor of cloth.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.tearFactor setTearFactor()

</member>
        <member name="M:NxCloth.setTearFactor(System.Single)">
	\brief Sets the cloth tear factor (must be larger than one).

	\param[in] factor The tear factor for the cloth

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.tearFactor getTearFactor()

</member>
        <member name="M:NxCloth.getPressure">
	\brief Retrieves the cloth pressure coefficient.

	\return Pressure of cloth.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.pressure setPressure()

</member>
        <member name="M:NxCloth.setPressure(System.Single)">
	\brief Sets the cloth pressure coefficient (must be non negative).

	\param[in] pressure The pressure applied to the cloth.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.pressure getPressure()

</member>
        <member name="M:NxCloth.getFriction">
	\brief Retrieves the cloth friction coefficient.

	\return Friction coefficient of cloth.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes
	
	@see NxClothDesc.friction setFriction()

</member>
        <member name="M:NxCloth.setFriction(System.Single)">
	\brief Sets the cloth friction coefficient in the range from 0 to 1.

	\param[in] friction The friction of the cloth.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.friction getFriction()

</member>
        <member name="M:NxCloth.getDampingCoefficient">
	\brief Retrieves the damping coefficient.

	\return damping coefficient of cloth.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes
	
	@see NxClothDesc.dampingCoefficient setDampingCoefficient()

</member>
        <member name="M:NxCloth.setDampingCoefficient(System.Single)">
	\brief Sets the damping coefficient in the range from 0 to 1.

	\param[in] dampingCoefficient damping coefficient of cloth.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.dampingCoefficient getDampingCoefficient()

</member>
        <member name="M:NxCloth.getStretchingStiffness">
	\brief Retrieves the cloth stretching stiffness.

	\return stretching stiffness of cloth.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.stretchingStiffness setStretchingStiffness()

</member>
        <member name="M:NxCloth.setStretchingStiffness(System.Single)">
	\brief Sets the cloth stretching stiffness in the range from 0 to 1.

	Note: The stretching stiffness must be larger than 0.

	\param[in] stiffness Stiffness of cloth.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.stretchingStiffness getStretchingStiffness()

</member>
        <member name="M:NxCloth.getBendingStiffness">
	\brief Retrieves the cloth bending stiffness.

	\return Bending stiffness of cloth.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.bendingStiffness setBendingStiffness()

</member>
        <member name="M:NxCloth.setBendingStiffness(System.Single)">
	\brief Sets the cloth bending stiffness in the range from 0 to 1.
 
	\param[in] stiffness The stiffness of this cloth.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.bendingStiffness getBendingStiffness()

</member>
        <member name="M:NxCloth.getClothMesh">
	\brief Returns a pointer to the corresponding cloth mesh.

	\return The cloth mesh associated with this cloth.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.clothMesh

</member>
        <member name="M:NxCloth.saveToDesc(NxClothDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Saves the cloth descriptor.

	\param[out] desc The descriptor used to retrieve the state of the object.
	\return True on success.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc

</member>
        <member name="M:NxClothDesc.isValid">
\brief Returns true if the current settings are valid

</member>
        <member name="M:NxClothDesc.setToDefault">
\brief (Re)sets the structure to the default.	

</member>
        <member name="M:NxClothDesc.#ctor">
\brief Constructor sets to default.

</member>
        <member name="F:NxClothDesc.compartment">
	\brief The compartment to place the cloth in. Must be either a pointer to an NxCompartment of type NX_SCT_CLOTH, or NULL.
	A NULL compartment means creating NX_CLF_HARDWARE cloth in the first available cloth compartment (a default cloth compartment is created if none exists).
	Software cloth with a NULL compartment is created in the scene proper.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	<b>Default:</b> NULL

</member>
        <member name="F:NxClothDesc.name">
	\brief Possible debug name. The string is not copied by the SDK, only the pointer is stored.

	<b>Default:</b> NULL

	@see NxCloth.setName() NxCloth.getName()

</member>
        <member name="F:NxClothDesc.userData">
	\brief Will be copied to NxCloth::userData

	<b>Default:</b> NULL

	@see NxCloth.userData

</member>
        <member name="F:NxClothDesc.flags">
	\brief Flag bits.

	<b>Default:</b> NX_CLF_GRAVITY

	@see NxClothFlag NxCloth.setFlags()

</member>
        <member name="F:NxClothDesc.validBounds">
	\brief If the flag NX_CLF_VALIDBOUNDS is set, this variable defines the volume
	outside of which cloth particle are automatically removed from the simulation. 

	@see NX_CLF_VALIDBOUNDS NxCloth.setValidBounds()

</member>
        <member name="F:NxClothDesc.forceFieldMaterial">
	\brief Force Field Material Index, index != 0 has to be created.

	<b>Default:</b> 0

</member>
        <member name="F:NxClothDesc.groupsMask">
	\brief Sets the 128-bit mask used for collision filtering.

	<b>Default:</b> 0

	@see NxGroupsMask NxCloth.setGroupsMask() NxCloth.getGroupsMask()

</member>
        <member name="F:NxClothDesc.collisionGroup">
	\brief Sets which collision group this cloth is part of.

	<b>Range:</b> [0, 31]
	<b>Default:</b> 0

	NxCloth.setCollisionGroup()

</member>
        <member name="F:NxClothDesc.meshData">
	\brief The buffers in meshData are used to communicate the dynamic data of the cloth back to the user.
	
	For example vertex positions, normals, connectivity (triangles) and parent index information. The internal order
	of the contents of meshData's buffers will remain the same as that in the initial mesh data used to create the mesh.

	<b>Default:</b> See #NxMeshData

	@see NxMeshData NxCloth.setMeshData()

</member>
        <member name="F:NxClothDesc.windAcceleration">
	\brief Acceleration which acts normal to the cloth surface at each vertex.

	<b>Default:</b> (0,0,0)

	@see NxCloth.setWindAcceleration()

</member>
        <member name="F:NxClothDesc.externalAcceleration">
	\brief External acceleration which affects all non attached particles of the cloth. 

	<b>Default:</b> (0,0,0)

	@see NxCloth.setExternalAcceleration()

</member>
        <member name="F:NxClothDesc.solverIterations">
	\brief Number of solver iterations. 

	Note: Small numbers make the simulation faster while the cloth gets less stiff.

	<b>Default:</b> 5
	<b>Range:</b> [1,inf)

	@see NxCloth.setSolverIterations()

</member>
        <member name="F:NxClothDesc.minAdhereVelocity">
	\brief If the NX_CLF_ADHERE flag is set the cloth moves partially in the frame 
	of the attached actor. 

	This feature is useful when the cloth is attached to a fast moving character.
	In that case the cloth adheres to the shape it is attached to while only 
	velocities below the parameter minAdhereVelocity are used for secondary effects.

	<b>Default:</b> 1.0
	<b>Range:</b> [0,inf)

	@see NX_CLF_ADHERE

</member>
        <member name="F:NxClothDesc.globalPose">
	\brief The global pose of the cloth in the world.

	<b>Default:</b> Identity Transform

</member>
        <member name="F:NxClothDesc.clothMesh">
	\brief The cooked cloth mesh.

	<b>Default:</b> NULL

	@see NxClothMesh NxClothMeshDesc NxCloth.getClothMesh()

</member>
        <member name="T:NxClothDesc">
\brief Descriptor class for #NxCloth.

@see NxCloth NxCloth.saveToDesc()

</member>
        <member name="T:NxClothVertexAttachmentStatus">
\brief Set of attachment states a vertex can be in.

</member>
        <member name="F:NX_CLOTH_VERTEX_ATTACHMENT_SHAPE">
\brief The vertex is attached to a shape

</member>
        <member name="F:NX_CLOTH_VERTEX_ATTACHMENT_GLOBAL">
\brief The vertex is attached to a global position

</member>
        <member name="F:NX_CLOTH_VERTEX_ATTACHMENT_NONE">
\brief The vertex is not attached

</member>
        <member name="T:NxClothAttachmentFlag">
\brief Cloth attachment flags.

@see NxCloth.attachToShape() NxCloth.attachToCollidingShapes() NxCloth.attachVertexToShape()

</member>
        <member name="F:NX_CLOTH_ATTACHMENT_TEARABLE">
	\brief When this flag is set, the attachment is tearable.

	\note If the cloth is attached to a dynamic shape using two way interaction
	half way torn attachments can generate unexpected impluses on the shape.
	To prevent this, only attach one row of cloth vertices to the shape.
	@see NxClothDesc.attachmentTearFactor

</member>
        <member name="F:NX_CLOTH_ATTACHMENT_TWOWAY">
	\brief The default is only object-&gt;cloth interaction (one way).

	With this flag set, cloth-&gt;object interaction is turned on as well.

</member>
        <member name="T:NxClothFlag">
\brief Collection of flags describing the behavior of a cloth object.

@see NxCloth NxClothMesh NxClothMeshDesc

</member>
        <member name="F:NX_CLF_ADHERE">
	\brief Moves cloth partially in the frame of the attached actor. 

	This feature is useful when the cloth is attached to a fast moving character.
	In that case the cloth adheres to the shape it is attached to while only 
	velocities below the parameter minAdhereVelocity are used for secondary effects.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.minAdhereVelocity

</member>
        <member name="F:NX_CLF_DISABLE_DYNAMIC_CCD">
	\brief Disable continuous collision detection with dynamic actors. 
	Dynamic actors are handled as static ones.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NX_CLF_FLUID_COLLISION">
	\brief Enable/disable collision handling between this cloth and fluids.

	Note: With the current implementation, do not switch on fluid collision for
	many cloths. Create scenes with a few large pieces because the memory usage
	increases linearly with the number of cloths.
	The performance of the collision detection is dependent on both, the thickness
	and the particle radius of the fluid so tuning these parameters might improve
	the performance significantly.

	Note: The current implementation does not obey the NxScene::setGroupCollisionFlag
	settings. If NX_CLF_FLUID_COLLISION is set, collisions will take place even if
	collisions between the groups that the corresponding cloth and fluid belong to are
	disabled.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.toFluidResponseCoefficient NxClothDesc.fromFluidResponseCoefficient

</member>
        <member name="F:NX_CLF_VALIDBOUNDS">
	\brief If the flag NX_CLF_VALIDBOUNDS is set, cloth particles outside the volume
	defined by NxClothDesc.validBounds are automatically removed from the simulation. 

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.validBounds

</member>
        <member name="F:NX_CLF_COMDAMPING">
	\brief Enable/disable center of mass damping of internal velocities.

	This flag only has an effect if the flag NX_CLF_DAMPING is set. If set, 
	the global rigid body modes (translation and rotation) are extracted from damping. 
	This way, the cloth can freely move and rotate even under high damping. 
	Use NxClothDesc.dampingCoefficient to control damping. 

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.dampingCoefficient

</member>
        <member name="F:NX_CLF_HARDWARE">
\brief Defines whether this cloth is simulated on the PPU.

To simulate a piece of cloth on the PPU
set this flag and create the cloth in a regular software scene.
Note: only use this flag during creation, do not change it using NxCloth.setFlags().

</member>
        <member name="F:NX_CLF_TEARABLE">
	\brief Defines whether the cloth is tearable. 
	
	Note: Make sure meshData.maxVertices and the corresponding buffers
	in meshData are substantially larger (e.g. 2x) then the number 
	of original vertices since tearing will generate new vertices.
	When the buffer cannot hold the new vertices anymore, tearing stops.

	Note: For tearing, make sure you cook the mesh with	the flag
	NX_CLOTH_MESH_TEARABLE set in the NxClothMeshDesc.flags.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.tearFactor NxClothDesc.meshData NxClothMeshDesc.flags

</member>
        <member name="F:NX_CLF_TRIANGLE_COLLISION">
	Not supported in current release.
	\brief Enable/disable collision detection of cloth triangles against the scene.
	If NX_CLF_TRIANGLE_COLLISION is not set, only collisions of cloth particles are detected.
	If NX_CLF_TRIANGLE_COLLISION is set, collisions of cloth triangles are detected as well.

	<b>Platform:</b>
	\li PC SW: No
	\li PPU  : No
	\li PS3  : No
	\li XB360: No

</member>
        <member name="F:NX_CLF_COLLISION_TWOWAY">
	\brief Enable/disable two way collision of cloth with the rigid body scene.
	
	In either case, cloth is influenced by colliding rigid bodies.
	If NX_CLF_COLLISION_TWOWAY is not set, rigid bodies are not influenced by 
	colliding pieces of cloth. Use NxClothDesc.collisionResponseCoefficient to
	control the strength of the feedback force on rigid bodies.

	When using two way interaction care should be taken when setting the density of the attached objects.
	For example if an object with a very low or high density is attached to a cloth then the simulation 
	may behave poorly. This is because impulses are only transfered between the cloth and rigid body solver
	outside the solvers.

	Two way interaction works best when NX_SF_SEQUENTIAL_PRIMARY is set in the primary scene. If not set,
	collision and attachment artifacts may happen.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.collisionResponseCoefficient

</member>
        <member name="F:NX_CLF_DAMPING">
	\brief Enable/disable damping of internal velocities. Use NxClothDesc.dampingCoefficient
	to control damping.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.dampingCoefficient

</member>
        <member name="F:NX_CLF_BENDING_ORTHO">
	\brief Enable/disable orthogonal bending resistance. This flag has an effect only if
	NX_CLF_BENDING is set. If NX_CLF_BENDING_ORTHO is not set, bending is modeled via an
	additional distance constraint. This mode is fast but not independent of stretching
	resistance. If NX_CLF_BENDING_ORTHO is set, bending is modeled via an angular spring
	between adjacent triangles. This mode is slower but independent of stretching resistance.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.bendingStiffness NX_CLF_BENDING

</member>
        <member name="F:NX_CLF_BENDING">
	\brief Enable/disable bending resistance. Select the bending resistance through 
	NxClothDesc.bendingStiffness. Two bending modes can be selected via the NX_CLF_BENDING_ORTHO flag.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.bendingStiffness NX_CLF_BENDING_ORTHO

</member>
        <member name="F:NX_CLF_GRAVITY">
	\brief Enable/disable gravity. If off, the cloth is not subject to the gravitational force
	of the rigid body scene.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NX_CLF_VISUALIZATION">
	\brief Enable/disable debug visualization. 

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NX_CLF_SELFCOLLISION">
	\brief Enable/disable self-collision handling within a single piece of cloth.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NX_CLF_TRIANGLE_COLLISION

</member>
        <member name="F:NX_CLF_DISABLE_COLLISION">
	\brief Disable collision handling with the rigid body scene. 

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.collisionResponseCoefficient

</member>
        <member name="F:NX_CLF_STATIC">
	\brief Makes the cloth static. 

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NX_CLF_PRESSURE">
	\brief Enable/disable pressure simulation. 
	Note: Pressure simulation only produces meaningful results for closed meshes.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxClothDesc.pressure

</member>
        <member name="T:NxClothMesh">
\addtogroup cloth
  @{

\addtogroup cloth
  @{

</member>
        <member name="T:NxUserFluidContactReport">
@} 
</member>
        <member name="M:NxFluid.saveEmittersToFluidDesc(NxFluidDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Helper function to save fluidEmitters to a fluidDescriptor.

	\param[out] desc Descriptor to save to.
	\return True if the resulting fluid descriptor is valid. 

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxFluid.setForceFieldMaterial(System.UInt16)">
	\brief Sets the actor's force field material index, default index is 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxFluid.getForceFieldMaterial">
	\brief Retrieves the actor's force field material index, default index is 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes [SW fallback]
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxFluid.getCompartment">
	\brief Retrieves the fluid's simulation compartment, as specified by the user at creation time.
	\return NULL if the fluid is not simulated in a compartment or if it was specified to run in 
	the default fluid compartment, otherwise the simulation compartment.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCompartment

</member>
        <member name="M:NxFluid.getName">
	\brief Returns the name string set with setName().

	\return The current name.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxFluid.setName(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
	\brief Sets a name string for the object that can be retrieved with getName().
	
	This is for debugging and is not used by the SDK.  The string is not copied by the
	SDK, only the pointer is stored.

	\param name The new name.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxFluid.getPPUTime">
	\brief Get the PPU simulation time.

	This method returns the time taken to simulate the fluid on the PPU in units
	which are proportional to time but whose units are otherwise unspecified.

	\return the simulation time
	<b>Platform:</b>
	\li SW   : No
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: No


</member>
        <member name="M:NxFluid.loadFromDesc(NxFluidDescBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Fluid Descriptor Operations

	\brief Loads the fluid descriptor.

	\param[in] desc The descriptor used to restore the state of the object.
	\return True on success.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidDesc

</member>
        <member name="M:NxFluid.getWorldBounds(NxBounds3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Returns the minimal (exact) world space axis aligned bounding box (AABB)
	including all simulated particles.

	\param dest Used to store the world bounds.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxFluid.getGroupsMask">
	\brief Sets 128-bit mask used for collision filtering.

	\return The group mask for the fluid.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see setGroupsMask() NxGroupsMask

</member>
        <member name="M:NxFluid.setGroupsMask(NxGroupsMask!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets 128-bit mask used for collision filtering.

	\param[in] groupsMask The group mask to set for the fluid.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getGroupsMask() NxGroupsMask

</member>
        <member name="M:NxFluid.getGroup">
	\brief Retrieves the value set with #setGroup().

	\return The collision group this fluid belongs to.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCollisionGroup

</member>
        <member name="M:NxFluid.setGroup(System.UInt16)">
	\brief Sets which collision group this fluid is part of.

	\param[in] collisionGroup The collision group for this fluid.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCollisionGroup

</member>
        <member name="M:NxFluid.getParticleMass">
	\brief Returns the mass of a particle. This value is dependent on the rest inter-particle
	distance and the rest density of the fluid.

	\return Particle mass.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getRestParticleDistance()
	@see getRestDensity()

</member>
        <member name="M:NxFluid.getRestParticleDistance">
	\brief Returns the inter-particle distance in the relaxed state of the fluid.

	This is the reciprocal of the value given by getRestParticlesPerMeter()

	\return Rest particle distance.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxFluid.getRestDensity">
	\brief Returns the density in the relaxed state of the fluid.

	\return Rest density.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidDesc.restDensity

</member>
        <member name="M:NxFluid.getRestParticlesPerMeter">
	\brief Returns the number of particles per meter in the relaxed state of the fluid.

	\return Rest particles per meter.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidDesc.restParticlesPerMeter

</member>
        <member name="M:NxFluid.getPacketSizeMultiplier">
	\brief Returns the fluid packet size used for parallelization of the fluid computations.

	\return The packet size multiplier.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxFluid.getCollisionDistanceMultiplier">
	\brief Returns the distance between particles and collision geometry, which is maintained during simulation.

	( distance = getCollisionDistanceMultiplier()/getRestParticlesPerMeter() ).

	\return collision distance multiplier.
	@see getRestParticleDistance()

</member>
        <member name="M:NxFluid.getMotionLimitMultiplier">
	\brief Returns the motion limit multiplier (the particle can move the maximal distance of 
	getRestParticleDistance() * getMotionLimitMultiplier() during one timestep).

	\return motion limit multiplier.

	@see getRestParticleDistance()

</member>
        <member name="M:NxFluid.getKernelRadiusMultiplier">
	\brief Returns the kernel radius multiplier (the particle interact within a radius of
	getRestParticleDistance() * getKernelRadiusMultiplier() ).

	\return The kernel radius multiplier.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidDesc.kernelRadiusMultiplier

</member>
        <member name="M:NxFluid.getMaxParticles">
@name Fluid Property Read Back

	\brief Returns the maximum number of particles for this fluid.

	\return Max number of particles for this fluid.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidDesc.maxParticles

</member>
        <member name="M:NxFluid.getScene">
	\brief Retrieves the scene which this fluid belongs to.

	\return Owner Scene.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: No

	@see NxScene

</member>
        <member name="M:NxFluid.getFlag(NxFluidFlag)">
	\brief Returns actor flags.

	\param flag Member of #NxFluidFlag.
	\return The current flag value.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidDesc.flags

</member>
        <member name="M:NxFluid.setFlag(NxFluidFlag,System.Boolean)">
	\brief Sets actor flags.

	\param flag Member of #NxFluidFlag.
	\param val New flag value.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidDesc.flags

</member>
        <member name="M:NxFluid.getCollisionResponseCoefficient">
	\brief Retrieves the collision response coefficient.

	\return The collision response coefficient.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidDesc.collisionResponseCoefficient setCollisionResponseCoefficient()

</member>
        <member name="M:NxFluid.setCollisionResponseCoefficient(System.Single)">
	\brief Sets the collision response coefficient.

	\param[in] coefficient The collision response coefficient (0 or greater).

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidDesc.collisionResponseCoefficient getCollisionResponseCoefficient()

</member>
        <member name="M:NxFluid.setAttractionForDynamicShapes(System.Single)">
	\brief Sets the attraction used for collision with dynamic actors.
	
	This feature is currently unimplemented! 


</member>
        <member name="M:NxFluid.getAttractionForDynamicShapes">
	\brief Returns the attraction used for collision with dynamic actors.

	This feature is currently unimplemented! 
	

</member>
        <member name="M:NxFluid.setStaticFrictionForDynamicShapes(System.Single)">
	\brief Sets the static friction used for collision with dynamic shapes.
	
	This feature is currently unimplemented! 


</member>
        <member name="M:NxFluid.getStaticFrictionForDynamicShapes">
	\brief Returns the static friction used for collision with dynamic shapes.

	This feature is currently unimplemented! 


</member>
        <member name="M:NxFluid.setDynamicFrictionForDynamicShapes(System.Single)">
	\brief Sets the dynamic friction used for collision with dynamic shapes.
	
	Must be between 0 and 1.
	
	\param friction The new dynamic friciton used for dynamic shapes.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidDesc.dynamicFrictionForDynamicShapes

</member>
        <member name="M:NxFluid.getDynamicFrictionForDynamicShapes">
	\brief Returns the dynamic friction used for collision with dynamic shapes.

	\return The dynamic friction used for dynamic shapes.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidDesc.dynamicFrictionForDynamicShapes

</member>
        <member name="M:NxFluid.setRestitutionForDynamicShapes(System.Single)">
	\brief Sets the restitution used for collision with dynamic actors.
	
	Must be between 0 and 1.

	\param rest The new collision restitution for dynamic shapes.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidDesc.restitutionForDynamicShapes

</member>
        <member name="M:NxFluid.getRestitutionForDynamicShapes">
	\brief Returns the restitution used for collision with dynamic actors.

	\return The collision resitution for dynamic shapes.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidDesc.restitutionForDynamicShapes

</member>
        <member name="M:NxFluid.setAttractionForStaticShapes(System.Single)">
	\brief Sets the attraction used for collision with static actors.
	
	This feature is currently unimplemented! 


</member>
        <member name="M:NxFluid.getAttractionForStaticShapes">
	\brief Returns the attraction used for collision with static actors.

	This feature is currently unimplemented! 
	

</member>
        <member name="M:NxFluid.setStaticFrictionForStaticShapes(System.Single)">
	\brief Sets the static friction used for collision with static actors.
	
	This feature is currently unimplemented! 


</member>
        <member name="M:NxFluid.getStaticFrictionForStaticShapes">
	\brief Returns the static friction used for collision with static shapes.

	This feature is currently unimplemented! 


</member>
        <member name="M:NxFluid.setDynamicFrictionForStaticShapes(System.Single)">
	\brief Sets the dynamic friction used for collision with static actors.
	
	Must be between 0 and 1.

	\param adhesion The new dynamic friction used for static shapes

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidDesc.dynamicFrictionForStaticShapes

</member>
        <member name="M:NxFluid.getDynamicFrictionForStaticShapes">
	\brief Returns the dynamic friction used for collision with static shapes.

	\return The dynamic friction used for static shapes.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidDesc.dynamicFrictionForStaticShapes

</member>
        <member name="M:NxFluid.setRestitutionForStaticShapes(System.Single)">
	\brief Sets the restitution used for collision with static shapes.
	
	Must be between 0 and 1.

	\param rest The new restitution for static shapes.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidDesc.restitutionForStaticShapes

</member>
        <member name="M:NxFluid.getRestitutionForStaticShapes">
	\brief Returns the restitution used for collision with static shapes.

	\return The static collision restitution.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidDesc.restitutionForStaticShapes

</member>
        <member name="M:NxFluid.setCollisionMethod(System.UInt32)">
	\brief Sets the collision method of the fluid.

	Can be set to a combination of NX_F_STATIC and NX_F_DYNAMIC.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidCollisionMethod

</member>
        <member name="M:NxFluid.getCollisionMethod">
@name Collisions

	\brief Returns the collision method of the fluid.

	\return The collision method.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidCollisionMethod

</member>
        <member name="M:NxFluid.setProjectionPlane(NxPlane!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the plane the fluid particles are projected to.

	\param plane Particle projection plane.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NX_FF_PROJECT_TO_PLANE NxFluidDesc.projectionPlane

</member>
        <member name="M:NxFluid.getProjectionPlane">
	\brief Returns the plane the fluid particles are projected to.

	\return The particle projection plane.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NX_FF_PROJECT_TO_PLANE NxFluidDesc.projectionPlane

</member>
        <member name="M:NxFluid.setExternalAcceleration(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the external acceleration applied to each particle at each time step.

	\param acceleration External acceleration to apply to particles.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidDesc.externalAcceleration getExternalAcceleration()

</member>
        <member name="M:NxFluid.getExternalAcceleration">
	\brief Returns the external acceleration applied to each particle at each time step.

	\return The external acceleration applied to particles.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidDesc.externalAcceleration

</member>
        <member name="M:NxFluid.setFadeInTime(System.Single)">
	\brief Sets the fluid fadeInTime (must be nonnegative).

	\param fadeIn The new fadeInTime.

	<b>Platform:</b>
	\li PC SW: No
	\li PPU  : No
	\li PS3  : No
	\li XB360: No

	Experimental feature.

	@see NxFluidDesc.fadeInTime

</member>
        <member name="M:NxFluid.getFadeInTime">
	\brief Returns the fluid fadeInTime.

	\return The fluid fadeInTime.

	<b>Platform:</b>
	\li PC SW: No
	\li PPU  : No
	\li PS3  : No
	\li XB360: No

	Experimental feature.

	@see NxFluidDesc.fadeInTime

</member>
        <member name="M:NxFluid.setDamping(System.Single)">
	\brief Sets the fluid damping (must be nonnegative).

	\param damp The new fluid damping.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidDesc.damping

</member>
        <member name="M:NxFluid.getDamping">
	\brief Returns the fluid damping.

	\return The fluid damping.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidDesc.damping

</member>
        <member name="M:NxFluid.setSurfaceTension(System.Single)">
	\brief Sets the fluid surfaceTension (must be nonnegative).

	\param surfaceTension The new surfaceTension of the fluid.

	<b>Platform:</b>
	\li PC SW: No
	\li PPU  : No
	\li PS3  : No
	\li XB360: No

	@see NxFluidDesc.surfaceTension

</member>
        <member name="M:NxFluid.getSurfaceTension">
	\brief Returns the fluid surfaceTension.

	\return The surfaceTension  of the fluid.

	<b>Platform:</b>
	\li PC SW: No
	\li PPU  : No
	\li PS3  : No
	\li XB360: No

	@see NxFluidDesc.surfaceTension

</member>
        <member name="M:NxFluid.setViscosity(System.Single)">
	\brief Sets the fluid viscosity (must be positive).

	\param visc The new viscosity of the fluid.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidDesc.viscosity

</member>
        <member name="M:NxFluid.getViscosity">
	\brief Returns the fluid viscosity.

	\return The viscosity  of the fluid.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidDesc.viscosity

</member>
        <member name="M:NxFluid.setStiffness(System.Single)">
	\brief Sets the fluid stiffness (must be positive).

	\param stiff The new fluid stiffness.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidDesc.stiffness

</member>
        <member name="M:NxFluid.getStiffness">
	\brief Returns the fluid stiffness.

	\return The fluid stiffness.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidDesc.stiffness

</member>
        <member name="M:NxFluid.setSimulationMethod(System.UInt32)">
	\brief Sets the simulation method of the fluid.

	Can either be set to NX_F_SPH, NX_F_NO_PARTICLE_INTERACTION or NX_F_MIXED_MODE.
	Note that depending on the spatial arrangement of the particles, switching from 
	NX_F_NO_PARTICLE_INTERACTION or NX_F_MIXED_MODE to NX_F_SPH might lead to an 
	unstable simulation state.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidSimulationMethod

</member>
        <member name="M:NxFluid.getSimulationMethod">
@name Fluid Parameters

	\brief Returns the simulation method of the fluid.


	\return The simulation method.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidSimulationMethod

</member>
        <member name="M:NxFluid.getFluidPacketData">
	\brief Returns a copy of the wrapper which was set by setFluidPacketData().

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidPacketData

</member>
        <member name="M:NxFluid.setFluidPacketData(NxFluidPacketData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the wrapper for user buffers, which configure where fluid packet data is written to.

	\param pData The descriptor for the buffers to write the fluid packet data to.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidPacketData

</member>
        <member name="M:NxFluid.updateParticles(NxParticleUpdateData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Updates particles for one simulation frame.

@see NxParticleUpdateData

</member>
        <member name="M:NxFluid.setCurrentParticleLimit(System.UInt32)">
	\brief Sets a bound on the maximum number of particles in the fluid.

	The value defaults to maxParticles, which is its maximum legal value. If it is lowered below
	the number of particles currently in the fluid, the oldest particles will be deleted to bring down 
	the number. This attribute is only effective if the NX_FF_PRIORITY_MODE flag is set on the fluid.


</member>
        <member name="M:NxFluid.getCurrentParticleLimit">
\brief Gets the bound on the maximum number of particles currently allowed in the fluid. 
  
@see setCurrentParticleLimit

</member>
        <member name="M:NxFluid.setNumReserveParticles(System.UInt32)">
	\brief Sets the number of particles which are reserved for creation at runtime.

	@see NxFluidDesc.numReserveParticles

</member>
        <member name="M:NxFluid.getNumReserveParticles">
	\brief Gets the number of particles which are reserved for creation at runtime.

	@see NxFluidDesc.numReserveParticles

</member>
        <member name="M:NxFluid.getParticleCreationIdWriteData">
	\brief Returns a copy of the wrapper which was set by setParticleCreationIdWriteData().

	\return The particle ID write data.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxParticleIdData  The descriptor for the buffers to write the particle IDs to.

</member>
        <member name="M:NxFluid.setParticleCreationIdWriteData(NxParticleIdData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the wrapper for user ID buffers, which configure where IDs of created particles are written to.

	\param iData The descriptor for the buffers to write the particle IDs to.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxParticleIdData

</member>
        <member name="M:NxFluid.getParticleDeletionIdWriteData">
	\brief Returns a copy of the wrapper which was set by setParticleDeletionIdWriteData().

	\return The particle ID write data.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxParticleIdData  The descriptor for the buffers to write the particle IDs to.

</member>
        <member name="M:NxFluid.setParticleDeletionIdWriteData(NxParticleIdData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the wrapper for user ID buffers, which configure where IDs of deleted particles are written to.

	\param iData The descriptor for the buffers to write the particle IDs to.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxParticleIdData

</member>
        <member name="M:NxFluid.getParticlesWriteData">
	\brief Returns a copy of the wrapper which was set by setParticlesWriteData().

	\return The particle write data.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxParticleData  The descriptor for the buffers to write the particle data to.

</member>
        <member name="M:NxFluid.setParticlesWriteData(NxParticleData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the wrapper for user buffers, which configure where particle data is written to.

	\param pData The descriptor for the buffers to write the particle data to.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxParticleData

</member>
        <member name="M:NxFluid.removeAllParticles">
	\brief Removes all particles from the simulation.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxFluid.getEmitters">
	\brief Returns an array of emitter pointers with size getNbEmitters().

	\return An array of fluid emitter pointers.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxFluid.getNbEmitters">
	\brief Returns the number of emitters.

	\return The number of emitters.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxFluid.releaseEmitter(NxFluidEmitter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Deletes the specified emitter.
	
	The emitter must belong to this fluid. Do not keep a reference to the deleted instance.
	Avoid release calls while the scene is simulating (in between simulate() and fetchResults() calls).

	\param emitter The emitter to release.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxFluid.createEmitter(NxFluidEmitterDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Emitters

	\brief Creates an emitter for this fluid.
	
	NxFluidEmitterDesc::isValid() must return true.

	\param desc The fluid emitter desciptor. See #NxFluidEmitterDesc.
	\return The new fluid.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitter

</member>
        <member name="M:NxFluidDesc.isValid">
	\brief Returns true if the current settings are valid


</member>
        <member name="M:NxFluidDesc.setToDefault">
	\brief (Re)sets the structure to the default.	


</member>
        <member name="M:NxFluidDesc.#ctor">
\brief constructor sets to default.

</member>
        <member name="F:NxFluidDesc.emitters">
	\brief Array of emitter descriptors that describe emitters which emit fluid into this
	fluid actor.

	A fluid actor can have any number of emitters.

	@see NxFluidEmitter

</member>
        <member name="M:NxFluidDescBase.getType">
	\brief Retrieve the fluid desc type.

	\return The fluid desc type. See #NxFluidDescType

</member>
        <member name="M:NxFluidDescBase.isValid">
	\brief Returns true if the current settings are valid


</member>
        <member name="M:NxFluidDescBase.setToDefault">
	\brief (Re)sets the structure to the default.	


</member>
        <member name="M:NxFluidDescBase.#ctor">
	\brief Constructor sets to default.


</member>
        <member name="F:NxFluidDescBase.compartment">
	\brief The compartment to place the fluid in. Must be either a pointer to an NxCompartment of type NX_SCT_FLUID, or NULL.
	A NULL compartment means creating the fluid in the first available fluid compartment (a default fluid compartment is created if none exists).

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	<b>Default:</b> NULL

</member>
        <member name="F:NxFluidDescBase.flags">
	\brief Flags defining certain properties of the fluid.

	@see NxFluidFlag

</member>
        <member name="F:NxFluidDescBase.fluidPacketData">
	\brief Defines the user data buffer which is used to store fluid packets.

	@see NxFluidPacketData

</member>
        <member name="F:NxFluidDescBase.particleCreationIdWriteData">
	\brief Defines the user data buffer which is used to store IDs of created particles.

	@see NxParticleIdData

</member>
        <member name="F:NxFluidDescBase.particleDeletionIdWriteData">
	\brief Defines the user data buffer which is used to store IDs of deleted particles.

	@see NxParticleIdData

</member>
        <member name="F:NxFluidDescBase.particlesWriteData">
	\brief Defines the user data buffers which are used to store particle data, which can be used for rendering.

	@see NxParticleData

</member>
        <member name="F:NxFluidDescBase.forceFieldMaterial">
	\brief Force Field Material Index, index != 0 has to be created.

	<b>Default:</b> 0

</member>
        <member name="F:NxFluidDescBase.groupsMask">
	\brief Sets the 128-bit mask used for collision filtering.

	<b>Default:</b> 0

	@see NxGroupsMask NxFluid.setGroupsMask() NxFluid.getGroupsMask()

</member>
        <member name="F:NxFluidDescBase.collisionGroup">
	\brief Sets which collision group this fluid is part of.

	<b>Default:</b> 0

	NxFluid.setCollisionGroup()

</member>
        <member name="F:NxFluidDescBase.collisionMethod">
\brief NxFluidCollisionMethod flags. Selects whether static collision and/or dynamic collision 
with the environment is performed.

@see NxFluidCollisionMethod

</member>
        <member name="F:NxFluidDescBase.simulationMethod">
	\brief NxFluidSimulationMethod flags. Defines whether or not particle interactions are considered 
	in the simulation.

	@see NxFluidSimulationMethod

</member>
        <member name="F:NxFluidDescBase.attractionForDynamicShapes">
	\brief Defines the strength of attraction between the particles and the dynamic rigid bodies on collision. 

	This feature is currently unimplemented! 


</member>
        <member name="F:NxFluidDescBase.staticFrictionForDynamicShapes">
	\brief Defines the static friction of the fluid regarding the surface of a dynamic shape.

	This feature is currently unimplemented! 


</member>
        <member name="F:NxFluidDescBase.dynamicFrictionForDynamicShapes">
	\brief Defines the dynamic friction of the fluid regarding the surface of a dynamic shape.

	Must be between 0 and 1.

	@see dynamicFrictionForStaticShapes

</member>
        <member name="F:NxFluidDescBase.restitutionForDynamicShapes">
	\brief Defines the restitution coefficient used for collisions of the fluid particles with dynamic shapes.
	
	Must be between 0 and 1.

	(Caution: values near 1 may have a negative impact on stability)

	@see restitutionForStaticShapes

</member>
        <member name="F:NxFluidDescBase.attractionForStaticShapes">
	\brief Defines the strength of attraction between the particles and static rigid bodies on collision. 

	This feature is currently unimplemented! 


</member>
        <member name="F:NxFluidDescBase.staticFrictionForStaticShapes">
	\brief Defines the static friction of the fluid regarding the surface of a static shape.

	This feature is currently unimplemented! 


</member>
        <member name="F:NxFluidDescBase.dynamicFrictionForStaticShapes">
	\brief Defines the dynamic friction of the fluid regarding the surface of a static shape.

	Must be between 0 and 1.
	
	A value of 1 will cause the particle to lose its velocity tangential to
	the surface normal of the shape at the collision location; i.e. it will not slide
	along the surface.
	
	A value of 0 will preserve the particle's velocity in the tangential surface
	direction; i.e. it will slide without resistance on the surface.


</member>
        <member name="F:NxFluidDescBase.restitutionForStaticShapes">
	\brief Defines the restitution coefficient used for collisions of the fluid particles with static shapes.

	Must be between 0 and 1.
	
	A value of 0 causes the colliding particle to get a zero velocity component in the
	direction of the surface normal of the static shape at the collision location; i.e.
	it will not bounce.
	
	A value of 1 causes a particle's velocity component in the direction of the surface normal to invert;
	i.e. the particle bounces off the surface with the same velocity magnitude as it had before collision. 
	(Caution: values near 1 may have a negative impact on stability)


</member>
        <member name="F:NxFluidDescBase.projectionPlane">
	\brief Defines the plane the fluid particles are projected to. This parameter is only used if
	NX_FF_PROJECT_TO_PLANE is set.

	<b>Default:</b> XY plane

	@see NX_FF_PROJECT_TO_PLANE NxFluid.getProjectionPlane() NxFluid.setProjectionPlane()

</member>
        <member name="F:NxFluidDescBase.externalAcceleration">
	\brief Acceleration (m/s^2) applied to all particles at all time steps.

	Useful to simulate smoke or fire.
	This acceleration is additive to the scene gravity. The scene gravity can be turned off 
	for the fluid, using the flag NX_FF_DISABLE_GRAVITY.

	@see NxFluid.getExternalAcceleration() NxFluid.setExternalAcceleration()

</member>
        <member name="F:NxFluidDescBase.damping">
	\brief Velocity damping constant, which is globally applied to each particle.
	
	It generally reduces the velocity of the particles. Setting the damping to 0 will leave the 
	particles unaffected.

	Must be nonnegative.


</member>
        <member name="F:NxFluidDescBase.surfaceTension">
	\brief 	The surfaceTension of the fluid defines an attractive force between particles
	
	Higher values will result in smoother surfaces.
	Must be nonnegative.


</member>
        <member name="F:NxFluidDescBase.viscosity">
	\brief 	The viscosity of the fluid defines its viscous behavior.
	
	Higher values will result in a honey-like behavior.  Viscosity is an effect which depends on the 
	relative velocity of neighboring particles; it reduces the magnitude of the relative velocity.
	
	Must be positive.


</member>
        <member name="F:NxFluidDescBase.stiffness">
	\brief The stiffness of the particle interaction related to the pressure.
	
	This factor linearly scales the force which acts on particles which are closer to each other than 
	the rest spacing.
	
	Setting	this parameter appropriately is crucial for the simulation.  The right value depends on many factors
	such as viscosity, damping, and kernelRadiusMultiplier.  Values which are too high will result in an
	unstable simulation, whereas too low values will make the fluid appear "springy" (the fluid
	acts more compressible).

	Must be positive.


</member>
        <member name="F:NxFluidDescBase.packetSizeMultiplier">
	\brief This parameter controls the parallelization of the fluid.
	
	The spatial domain is divided into so called packets, equal sized cubes, aligned in a grid.
	
	The parameter given defines the edge length of such a packet. This parameter is relative to the interaction 
	radius of the particles, given as kernelRadiusMultiplier/restParticlesPerMeter.

	It has to be a power of two, no less than 4.


</member>
        <member name="F:NxFluidDescBase.collisionDistanceMultiplier">
	\brief Defines the distance between particles and collision geometry, which is maintained during simulation.

	For the actual distance, this parameter is divided by the rest spacing of the particles, which is defined by the parameter
	restParticlesPerMeter:

	( distance = collisionDistanceMultiplier/restParticlesPerMeter ).

	It has to be positive and not higher than packetSizeMultiplier*kernelRadiusMultiplier.
	Default value is 0.12 (i.e., 0.1 * kernelRadiusMultiplier).

	@see restParticlesPerMeter, kernelRadiusMultiplier

</member>
        <member name="F:NxFluidDescBase.motionLimitMultiplier">
	\brief Maximal distance a particle is allowed to travel within one timestep.

	This parameter is relative to the rest spacing of the particles, which is defined by the parameter
	restParticlesPerMeter:

	( maximal travel distance = motionLimitMultiplier/restParticlesPerMeter ).

	Default value is 3.6 (i.e., 3.0 * kernelRadiusMultiplier).

	The value must not be higher than the product of packetSizeMultiplier and kernelRadiusMultiplier.

	@see restParticlesPerMeter

</member>
        <member name="F:NxFluidDescBase.kernelRadiusMultiplier">
	\brief Radius of sphere of influence for particle interaction.
	
	This parameter is relative to the rest spacing of the particles, which is defined by the parameter
	restParticlesPerMeter
	
	( radius = kernelRadiusMultiplier/restParticlesPerMeter ).

	This parameter should be set around 2.0 and definitely below 2.5 for optimal performance and simulation quality.

	@see restParticlesPerMeter

</member>
        <member name="F:NxFluidDescBase.restDensity">
	\brief Target density for the fluid (water is about 1000).
	
	Even if the particle system is simulated without particle interactions, this parameter defines 
	indirectly in combination with restParticlesPerMeter the mass of one particle 
	( mass = restDensity/(restParticlesPerMeter^3) ).
	
	The particle mass has an impact on the repulsion effect on emitters and actors.


</member>
        <member name="F:NxFluidDescBase.restParticlesPerMeter">
	\brief The particle resolution given as particles per linear meter measured when the fluid is
	in its rest state (relaxed).
	
	Even if the particle system is simulated without particle interactions, this parameter defines the 
	emission density of the emitters.


</member>
        <member name="F:NxFluidDescBase.numReserveParticles">
	\brief Defines the number of particles which are reserved for creation at runtime.
    	
	If NxFluidDesc.flags.NX_FF_PRIORITY_MODE is set the oldest particles are removed until 
	there are no more than (maxParticles - numReserveParticles) particles left. This removal
	is carried out for each simulation step, on particles which have a finite life time 
	(i.e. &gt; 0.0). The deletion guarantees a reserve of numReserveParticles particles which 
	can be added for each simulaiton step. Note that particles which have equal lifetime can 
	get deleted at the same time. In order to avoid this, the particle lifetimes 
	can be varied randomly.

	This parameter must be smaller than NxFluidDesc.maxParticles.

</member>
        <member name="F:NxFluidDescBase.maxParticles">
	\brief Sets the maximal number of particles for the fluid used in the simulation.
	
	If more particles are added directly, or more particles are emitted into the
	fluid after this limit is reached, they are simply ignored.


</member>
        <member name="F:NxFluidDescBase.initialParticleData">
	\brief 	Describes the particles which are added to the fluid initially.

	The pointers to the buffers are invalidated after the initial particles are generated.

	@see NxParticleData

</member>
        <member name="T:NxFluidDescBase">
\brief Describes an NxFluid.

</member>
        <member name="T:NxFluidFlag">
\brief Fluid flags

</member>
        <member name="F:NX_FF_FORCE_STRICT_COOKING_FORMAT">
	\brief Forces fluid static mesh cooking format to parameters given by the fluid descriptor.

	Currently not implemented!

</member>
        <member name="F:NX_FF_PROJECT_TO_PLANE">
	\brief Defines whether the particles of this fluid should be projected to a plane.
	This can be used to build 2D fluid applications, for instance. The projection
	plane is defined by the parameter NxFluidDesc.projectionPlane.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidDesc.projectionPlane

</member>
        <member name="F:NX_FF_PRIORITY_MODE">
	\brief Enable/disable particle priority mode. 
	If enabled, the oldest particles are deleted to keep a certain budget for 
	new particles. Note that particles which have equal lifetime can get deleted 
	at the same time. In order to avoid this, the particle lifetimes 
	can be varied randomly.

	@see NxFluidDesc.numReserveParticles

</member>
        <member name="F:NX_FF_HARDWARE">
\brief Defines whether this fluid is simulated on the PPU.

</member>
        <member name="F:NX_FF_ENABLED">
	\brief Enable/disable execution of fluid simulation.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NX_FF_COLLISION_TWOWAY">
	\brief Enable/disable two way collision of fluid with the rigid body scene.
	In either case, fluid is influenced by colliding rigid bodies.
	If NX_FF_COLLISION_TWOWAY is not set, rigid bodies are not influenced by 
	colliding pieces of fluid. Use NxFluidDesc.collisionResponseCoefficient to
	control the strength of the feedback force on rigid bodies.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluieDesc.collisionResponseCoefficient

</member>
        <member name="F:NX_FF_DISABLE_GRAVITY">
\brief Disables scene gravity for the NxFluid.

</member>
        <member name="F:NX_FF_VISUALIZATION">
\brief Enables debug visualization for the NxFluid.

</member>
        <member name="T:NxFluidCollisionMethod">
\brief The fluid collision method

The NxFluid instance can be selected for collision with both static and dynamic shapes.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : No
\li XB360: No

</member>
        <member name="T:NxFluidSimulationMethod">
\brief Describes the particle simulation method

Particles can be treated in two ways: either they are simulated considering
interparticular forces (SPH), or they are simulated independently.
In the latter case (with the simulation method set to NX_F_NO_PARTICLE_INTERACTION),
you still get collision between particles and static/dynamic shapes, damping,
acceleration due to gravity, and the user force.

</member>
        <member name="F:NX_F_MIXED_MODE">
\brief Alternate between SPH and simple particles

</member>
        <member name="F:NX_F_NO_PARTICLE_INTERACTION">
\brief Do not simulate inter particle forces.

</member>
        <member name="F:NX_F_SPH">
\brief Enable simulation of inter particle forces.

</member>
        <member name="T:NxCompartment">
@} 

\brief A scene compartment is a portion of the scene that can
be simulated on a different hardware device than other parts of the scene.

Note: You cannot release scene compartments explicitly, they are automatically released when the scene is released.
To create a compartment, call NxScene::createCompartment()


@} 
</member>
        <member name="M:NxFluidEmitterDesc.#ctor">
\brief Constructor sets to default.

</member>
        <member name="M:NxFluidEmitterDesc.isValid">
\brief Returns true if the current settings are valid

</member>
        <member name="M:NxFluidEmitterDesc.setToDefault">
\brief (Re)sets the structure to the default.	

</member>
        <member name="F:NxFluidEmitterDesc.flags">
	\brief A combination of NxFluidEmitterFlags.

	@see NxFluidEmitterFlag

</member>
        <member name="F:NxFluidEmitterDesc.particleLifetime">
	\brief This specifies the time in seconds an emitted particle lives.

	If set to 0, each particle will live until it collides with a drain.

</member>
        <member name="F:NxFluidEmitterDesc.rate">
	\brief The rate specifies how many particles are emitted per second.
	
	The rate is only considered in the simulation if the type is set to NX_FE_CONSTANT_FLOW_RATE.

	@see NxEmitterType

</member>
        <member name="F:NxFluidEmitterDesc.fluidVelocityMagnitude">
	\brief The velocity magnitude of the emitted fluid particles.


</member>
        <member name="F:NxFluidEmitterDesc.randomAngle">
	\brief Random angle deviation from emission direction.
	
	The emission direction is specified by the third orientation axis of relPose.
	
	<b>Unit:</b> Radians


</member>
        <member name="F:NxFluidEmitterDesc.randomPos">
	\brief Random vector with values for each axis direction of the emitter orientation.
	
	The values have to be positive and describe the maximal random particle displacement in each dimension.
	
	The z value describes the randomization in emission direction. The emission direction 
	is specified by the third orientation axis of relPose.


</member>
        <member name="F:NxFluidEmitterDesc.dimensionX">
	\brief The sizes of the emitter in the directions of the first and the second axis of its orientation 
	frame (relPose).

	The dimensions are actually the radii of the size.


</member>
        <member name="F:NxFluidEmitterDesc.shape">
	\brief The emitter's shape can either be rectangular or elliptical.

	@see NxEmitterShape

</member>
        <member name="F:NxFluidEmitterDesc.maxParticles">
\brief The maximum number of particles which are emitted from this emitter.

If the total number of particles in the fluid already hit the maxParticles parameter of the fluid, 
this maximal values can't be reached.

If set to 0, the number of emitted particles is unrestricted.

</member>
        <member name="F:NxFluidEmitterDesc.type">
	\brief The emitter's mode of operation.

	Either the simulation enforces constant pressure or constant flow rate at the emission site, 
	given the velocity of emitted particles.

	@see NxEmitterType

</member>
        <member name="F:NxFluidEmitterDesc.frameShape">
\brief A pointer to the NxShape to which the emitter is attached to.

If this pointer is set to NULL, the emitter is attached to the world frame. The shape 
must be in the same scene as the emitter. 

</member>
        <member name="F:NxFluidEmitterDesc.relPose">
	\brief The emitter's pose relative to the frameShape.

	relPose is relative to the shape's frame. If frameShape is NULL then relPose is relative to the world frame.

	The direction of the flow is the direction of the third (z) axis of the emitter frame.

</member>
        <member name="T:NxFluidEmitterDesc">
@} 
\brief Descriptor for NxFluidEmitter class.  Used for saving and loading the emitter state.


@} 
</member>
        <member name="M:NxFluidEmitter.getName">
	\brief Retrieves the name string set with setName().

	\return The current name.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxFluidEmitter.setName(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
	\brief Sets a name string for the object that can be retrieved with getName().
	
	This is for debugging and is not used by the SDK.  The string is not copied by the SDK; 
	only the pointer is stored.

	\param[in] name The new name.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxFluidEmitter.saveToDesc(NxFluidEmitterDesc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Saves the FluidEmitter descriptor.

	\param[out] desc The descriptor used to retrieve the state of the object.
	\return True on success.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterDesc

</member>
        <member name="M:NxFluidEmitter.loadFromDesc(NxFluidEmitterDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name FluidEmitter Descriptor Operations

	\brief Loads the FluidEmitter descriptor.

	\param[in] desc The descriptor used to restore the state of the object.
	\return True on success.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterDesc

</member>
        <member name="M:NxFluidEmitter.getType(NxEmitterType)">
	\brief Get the emitter type.

	\param[in] type Member of #NxEmitterType
	\return True if it is of type type.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxEmitterType

</member>
        <member name="M:NxFluidEmitter.getShape(NxEmitterShape)">
	\brief Get the emitter shape.

	\param[in] shape Member of #NxEmitterShape.
	\return True if it is of type shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterDesc.shape

</member>
        <member name="M:NxFluidEmitter.getFlag(NxFluidEmitterFlag)">
	\brief Returns the emitter flags.

	\param[in] flag Member of #NxFluidEmitterFlag.
	\return The current flag value.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterFlag

</member>
        <member name="M:NxFluidEmitter.setFlag(NxFluidEmitterFlag,System.Boolean)">
	\brief Sets the emitter flags. 

	\param[in] flag Member of #NxFluidEmitterFlag.
	\param[in] val New flag value.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterFlag

</member>
        <member name="M:NxFluidEmitter.getNbParticlesEmitted">
	\brief Returns the number of particles that have been emitted already. 

	\return number of particles already emitted.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxFluidEmitter.getMaxParticles">
	\brief Returns the maximal particle number to be emitted. 

	\return max particles.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterDesc.maxParticles

</member>
        <member name="M:NxFluidEmitter.resetEmission(System.UInt32)">
	\brief Resets the particle reservoir. 

	\param[in] new maxParticles value.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterDesc.maxParticles

</member>
        <member name="M:NxFluidEmitter.getRepulsionCoefficient">
	\brief Retrieves the repulsion coefficient.

	\return The repulsion coefficient.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterDesc.repulsionCoefficient setRepulsionCoefficient()

</member>
        <member name="M:NxFluidEmitter.setRepulsionCoefficient(System.Single)">
	\brief Sets the repulsion coefficient.

	\param[in] coefficient The repulsion coefficient in the range from 0 to inf.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterDesc.repulsionCoefficient getRepulsionCoefficient()

</member>
        <member name="M:NxFluidEmitter.getParticleLifetime">
	\brief Returns the particle lifetime.

	\return Lifetime of emitted particles.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterDesc.particleLifetime

</member>
        <member name="M:NxFluidEmitter.setParticleLifetime(System.Single)">
	\brief Sets the particle lifetime.

	\param[in] life Lifetime of emitted particles.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterDesc.particleLifetime

</member>
        <member name="M:NxFluidEmitter.getRate">
	\brief Returns the emission rate.

	\return Emission rate.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterDesc.rate

</member>
        <member name="M:NxFluidEmitter.setRate(System.Single)">
	\brief Sets the emission rate (particles/second).
	
	Only used if the NxEmitterType is NX_FE_CONSTANT_FLOW_RATE.

	\param[in] rate New emission rate.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterDesc.rate

</member>
        <member name="M:NxFluidEmitter.getFluidVelocityMagnitude">
	\brief Returns the velocity magnitude of the emitted particles.

	\return Velocity magnitude of emitted particles.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterDesc.fluidVelocityMagnitude

</member>
        <member name="M:NxFluidEmitter.setFluidVelocityMagnitude(System.Single)">
	\brief Sets the velocity magnitude of the emitted particles. 

	\param[in] vel New velocity magnitude of emitted particles.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterDesc.fluidVelocityMagnitude

</member>
        <member name="M:NxFluidEmitter.getRandomAngle">
	\brief Returns the maximal random angle offset (in radians). 

	<b>Unit:</b> Radians

	\return Maximum random angle for emitted particles.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterDesc.randomAngle

</member>
        <member name="M:NxFluidEmitter.setRandomAngle(System.Single)">
	\brief Sets the maximal random angle offset (in radians). 

	<b>Unit:</b> Radians

	\param[in] angle Maximum random angle for emitted particles.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterDesc.randomAngle

</member>
        <member name="M:NxFluidEmitter.getRandomPos">
	\brief Returns the maximal random displacement in every dimension.

	\return The maximal random displacment of particles.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterDesc.randomPos

</member>
        <member name="M:NxFluidEmitter.setRandomPos(NxVec3)">
	\brief Sets the maximal random displacement in every dimension.

	\param[in] disp The maximal random displacment of particles.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterDesc.randomPos

</member>
        <member name="M:NxFluidEmitter.getDimensionY">
	\brief Returns the radius of the emitter along the y axis.

	\return Radius of emitter along the Y axis.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterDesc.dimensionY

</member>
        <member name="M:NxFluidEmitter.getDimensionX">
	\brief Returns the radius of the emitter along the x axis.

	\return Radius of emitter along the X axis.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterDesc.dimensionX

</member>
        <member name="M:NxFluidEmitter.getFrameShape">
	\brief Returns the frame shape. May be NULL.

	\return The frame shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterDesc.frameShape

</member>
        <member name="M:NxFluidEmitter.setFrameShape(NxShape*)">
	\brief Sets the frame shape. Can be set to NULL.

	\param[in] shape The frame shape.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterDesc.frameShape

</member>
        <member name="M:NxFluidEmitter.getLocalOrientation">
	\brief Returns the orientation of the emitter relative to the frameShape. 

	The pose is relative to the shape frame.

	If the frameShape is NULL, world space is used.

	\return The local orientation of the emitter.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterDesc.relPose

</member>
        <member name="M:NxFluidEmitter.getLocalPosition">
	\brief Returns the position of the emitter relative to the frameShape. 

	The pose is relative to the shape frame.

	If the frameShape is NULL, world space is used.

	\return The local position of the emitter.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterDesc.relPose

</member>
        <member name="M:NxFluidEmitter.getLocalPose">
\endcond 
	\brief Returns the pose of the emitter relative to the frameShape. 

	The pose is relative to the shape frame.

	If the frameShape is NULL, world space is used.

	\return The local pose of the emitter.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterDesc.relPose

</member>
        <member name="M:NxFluidEmitter.getLocalPoseVal">
\cond 
	\brief 	The get*Val() methods work just like the get*() methods, except they return the 
	desired values instead of copying them to the destination variables.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxFluidEmitter.setLocalOrientation(NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the orientation of the emitter relative to the frameShape. 

	The pose is relative to the shape frame.

	If the frameShape is NULL, world space is used.

	\param[in] mat The new local orientation of the emitter.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterDesc.relPose

</member>
        <member name="M:NxFluidEmitter.setLocalPosition(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the position of the emitter relative to the frameShape. 

	The pose is relative to the shape frame.

	If the frameShape is NULL, world space is used.

	\param[in] vec The new local position of the emitter.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterDesc.relPose

</member>
        <member name="M:NxFluidEmitter.setLocalPose(NxMat34!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the pose of the emitter relative to the frameShape. 

	The pose is set relative to the shape frame.

	If the frameShape is NULL, world space is used.

	\param[in] mat The new local pose of the emitter.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxFluidEmitterDesc.relPose

</member>
        <member name="M:NxFluidEmitter.getGlobalOrientation">
	\brief Returns the orientation of the emitter in world space.

	\return The world space orientation.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxFluidEmitter.getGlobalPosition">
	\brief Returns the position of the emitter in world space.

	\return The world space position.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxFluidEmitter.getGlobalPose">
\endcond 
	\brief Returns the pose of the emitter in world space.

	\return The global pose.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxFluidEmitter.getGlobalPoseVal">
\cond 
	\brief The get*Val() methods work just like the get*() methods, except they return the 
	desired values instead of copying them to destination variables.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxFluidEmitter.setGlobalOrientation(NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the orientation of the emitter in world space.

	\param[in] mat New orientation in world space.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxFluidEmitter.setGlobalPosition(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the position of the emitter in world space.

	\param[in] vec New positon in world space.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxFluidEmitter.setGlobalPose(NxMat34!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets the pose of the emitter in world space.

	\param[in] mat New pose of the emitter in world space.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxFluidEmitter.getFluid">
	\brief Returns the owner fluid.

	\return The fluid this emitter is associated with.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxPhysicsSDK.getFoundationSDK">
	\brief Retrieves the FoundationSDK instance.
	\return A reference to the Foundation SDK object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxPhysicsSDK.getNbPPUs">
	\brief Reports the number of PPUs installed in the host system

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="M:NxPhysicsSDK.getHWVersion">
	\brief Reports the available revision of the PhysX Hardware

	\return 0 if there is no hardware present in the machine, 1 for the PhysX Athena revision 1.0 card. 

</member>
        <member name="M:NxPhysicsSDK.getInternalVersion(System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Reports the internal API version number of the SDK

	\return The internal API version information.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes


</member>
        <member name="M:NxPhysicsSDK.getSoftBodyMeshes">
	\brief Retrieve an array of soft body meshes.

	\return an array of soft body mesh pointers with size getNbSoftBodyMeshes().

</member>
        <member name="M:NxPhysicsSDK.getNbSoftBodyMeshes">
\brief Number of soft body meshes.

\return the number of soft body meshes.

</member>
        <member name="M:NxPhysicsSDK.releaseSoftBodyMesh(NxSoftBodyMesh*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Deletes the specified soft body mesh. The soft body mesh must be in this scene.

	Do not keep a reference to the deleted instance.
	Avoid release calls while the scene is simulating (in between simulate() and fetchResults() calls).

	\param softBodyMesh Soft body mesh to release.

</member>
        <member name="M:NxPhysicsSDK.createSoftBodyMesh(NxStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Creates a soft body mesh from a cooked soft body mesh stored in a stream.

	Stream has to be created with NxCookSoftBodyMesh(). 

	\return The new soft body mesh.

</member>
        <member name="M:NxPhysicsSDK.getClothMeshes">
	\brief Retrieve an array of cloth meshes.

	\return an array of cloth mesh pointers with size getNbClothMeshes().

</member>
        <member name="M:NxPhysicsSDK.getNbClothMeshes">
\brief Number of cloth meshes.

\return the number of cloth meshes.

</member>
        <member name="M:NxPhysicsSDK.releaseClothMesh(NxClothMesh*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Deletes the specified cloth mesh. The cloth mesh must be in this scene.

	Do not keep a reference to the deleted instance.
	Avoid release calls while the scene is simulating (in between simulate() and fetchResults() calls).

	\param cloth Cloth to release.

</member>
        <member name="M:NxPhysicsSDK.createClothMesh(NxStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Creates a cloth mesh from a cooked cloth mesh stored in a stream.

	Stream has to be created with NxCookClothMesh(). 

	\return The new cloth mesh.

</member>
        <member name="M:NxPhysicsSDK.getNbConvexMeshes">
\brief Number of convex meshes.

\return the number of convex meshes.

</member>
        <member name="M:NxPhysicsSDK.releaseConvexMesh(NxConvexMesh*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Destroys the instance passed.

	Be sure	to not keep a reference to this object after calling release.
	Do not release the convex mesh before all its instances are released first!
	Avoid release calls while the scene is simulating (in between simulate() and fetchResults() calls).

	\param[in] mesh The convex mesh to release.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see createConvexMesh() NxConvexMesh NxConvexShape

</member>
        <member name="M:NxPhysicsSDK.createConvexMesh(NxStream!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Creates a convex mesh object.
	
	This can then be instanced into #NxConvexShape objects.

	\param[in] mesh The stream to load the convex mesh from.
	\return The new convex mesh.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback for &gt; 32 vertices or faces)
	\li PS3  : Yes
	\li XB360: Yes

	@see releaseConvexMesh() NxConvexMesh NxStream createTriangleMesh() NxConvexShape

</member>
        <member name="M:NxPhysicsSDK.getNbCCDSkeletons">
\brief Number of CCD skeletons.

\return the number of CCD skeletons.

</member>
        <member name="M:NxPhysicsSDK.releaseCCDSkeleton(NxCCDSkeleton*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Destroys the instance passed.

	Be sure	to not keep a reference to this object after calling release.
	Do not release the object before all its users are released first!
	Avoid release calls while the scene is simulating (in between simulate() and fetchResults() calls).

	\param[in] skel The CCD Skeleton to release.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see createCCDSkeleton() NxShape.setCCDSkeleton()

</member>
        <member name="M:NxPhysicsSDK.createCCDSkeleton(System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
	\brief Creates a CCD Skeleton mesh object.  

	Same as createCCDSkeleton(NxSimpleTriangleMesh), but it creates from a memory buffer that was previously created
	with NxCCDSkeleton::save().


	\param[in] memoryBuffer the buffer to read from.
	\param[in] bufferSize size of the buffer.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see createCCDSkeleton()

</member>
        <member name="M:NxPhysicsSDK.createCCDSkeleton(NxSimpleTriangleMesh!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Creates a CCD Skeleton mesh object.  

	CCD is performed with a skeleton(mesh) embedded within the object, this can be simpler than the geometry 
	used for discrete collision detection. 

	NxShape::setCCDSkeleton() should be used to associate a CCD skeleton with shapes.

	\note that stray vertices are permitted (in other words, vertices not referenced by any triangles), 
	but degenerate triangles (triangles that have a triangle index 2 or 3 times) are not. Stray vertices 
	are supported so that you can use a single vertex to do a raycast style CCD test. 

	\note The CCD skeleton should be scaled so that it is smaller than the geometry it is embedded within.
	This allows regular discrete collision detection to handle resting contact. Making the CCD skeleton too
	large in comparison to the shape it is embedded within can cause erratic behavior.
	
	\note CCDSkeletons currently must contain at most 64 vertices!

	<b>Limitations</b><p>
	\li 64 vertex limit on CCD Skeletons (restriction probably lifted in a future version)
	\li Doesn't work when the static shape is a NxSphereShape, NxCapsuleShape, NxPlaneShape,NxBoxShape.
	</p><h3>Visualizations:</h3>
	\li #NX_VISUALIZE_COLLISION_CCD
	\li #NX_VISUALIZE_COLLISION_SKELETONS

	\param[in] mesh The triangle mesh from which to create the CCD skeleton.
	\return The new CCD skeleton.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSimpleTriangleMesh releaseCCDSkeleton() NxShape.setCCDSkeleton()

</member>
        <member name="M:NxPhysicsSDK.getNbHeightFields">
\brief Number of heightfields.

\return the number of heightfields.

</member>
        <member name="M:NxPhysicsSDK.releaseHeightField(NxHeightField*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Destroys the instance passed.
	
	Be sure to not keep a reference to this object after calling release.
	Do not release the height field before all its shape instances are released first!
	Avoid release calls while the scene is simulating (in between simulate() and fetchResults() calls).
	
	\param[in] heightField The height field to release.
	
	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see createHeightField() NxHeightField NxHeightFieldDesc NxHeightFieldShape

</member>
        <member name="M:NxPhysicsSDK.createHeightField(NxHeightFieldDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Creates a NxHeightField object.
	
	This can then be instanced into #NxHeightFieldShape objects.
	
	\param[in] desc The descriptor to load the object from.
	\return The new height field object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (Software fallback)
	\li PS3  : Yes
	\li XB360: Yes

	@see releaseHeightField() NxHeightField NxHeightFieldDesc NxHeightFieldShape

</member>
        <member name="M:NxPhysicsSDK.getNbTriangleMeshes">
\brief Number of triangle meshes.

\return the number of triangle meshes.

</member>
        <member name="M:NxPhysicsSDK.releaseTriangleMesh(NxTriangleMesh*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Destroys the instance passed.

	Be sure	to not keep a reference to this object after calling release.
	Do not release the triangle mesh before all its instances are released first!
	Avoid release calls while the scene is simulating (in between simulate() and fetchResults() calls).

	\param[in] mesh Triangle mesh to release.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see createTriangleMesh NxTriangleMesh

</member>
        <member name="M:NxPhysicsSDK.createTriangleMesh(NxStream!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Creates a triangle mesh object.
	
	This can then be instanced into #NxTriangleMeshShape objects.

	\param[in] stream The triangle mesh stream.
	\return The new triangle mesh.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxTriangleMesh NxStream releaseTriangleMesh() createConvexMesh()

</member>
        <member name="M:NxPhysicsSDK.getScene(System.UInt32)">
	\brief Retrieves pointer to created scenes.

	\param[in] i The index for the scene.
	\return The scene at index i.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getNbScenes() NxScene

</member>
        <member name="M:NxPhysicsSDK.getNbScenes">
	\brief Gets number of created scenes.

	\return The number of scenes created.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see getScene()

</member>
        <member name="M:NxPhysicsSDK.releaseScene(NxScene*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Deletes the instance passed.

	Also releases any actors, sweep caches, fluids, fluid surfaces, cloths, joints, effectors and materials created in this scene
	(if the user hasn't already done so), but not meshes or other items created via the SDK itself.

	Be sure	to not keep a reference to this object after calling release.
	Avoid release calls while the scene is simulating (in between simulate() and fetchResults() calls).
	
	Make sure to call #NxScene::shutdownWorkerThreads before releasing the scene, if you have user
	threads that poll for work (see #NxScene::pollForWork).

	\param[in] scene The scene to release.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxScene createScene() shutdownWorkerThreads()

</member>
        <member name="M:NxPhysicsSDK.createScene(NxSceneDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Creates a scene.

	The scene can then create its contained entities.

	See #NxSceneDesc::simType to choose if to create a hardware or software scene.

	\param[in] sceneDesc Scene descriptor. See #NxSceneDesc
	\return The new scene object.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	<b>Limitations:</b>

	The number of scenes that can be created is limited by the amount of memory available, and since this 
	amount varies dynamically as memory is allocated and deallocated by the PhysX SDK and by other software 
	components there is in general no way to statically determine the maximum number of scenes which can be 
	created at a given point in the simulation.

	However, scenes are built from lower-level objects called contexts. There is a limit of 64 contexts; a scene will 
	take 1 or 2 contexts depending on flags upon creation. A software scene (NX_SIMULATION_SW) will always take 1 context, 
	a hardware scene will take 1 context if NX_SF_RESTRICTED_SCENE is set, otherwise 2 contexts. This places an
	absolute limit on the maximum number of scenes regardless of the memory available.

	@see NxScene NxSceneDesc releaseScene()

</member>
        <member name="M:NxPhysicsSDK.getParameter(NxParameter)">
	\brief Function that lets you query global simulation parameters.

	See #NxParameter for a description of parameters support by hardware.

	\param[in] paramEnum The Parameter to retrieve.
	\return The value of the parameter.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Partial
	\li PS3  : Yes
	\li XB360: Yes

	@see setParameter NxParameter

</member>
        <member name="M:NxPhysicsSDK.setParameter(NxParameter,System.Single)">
	\brief Function that lets you set global simulation parameters.

	Returns false if the value passed is out of range for usage specified by the enum.

	<b>Sleeping:</b> Does <b>NOT</b> wake any actors which may be affected.

	See #NxParameter for a description of parameters support by hardware.

	\param[in] paramEnum Parameter to set. See #NxParameter
	\param[in] paramValue The value to set, see #NxParameter for allowable values.
	\return False if the parameter is out of range.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Partial
	\li PS3  : Yes
	\li XB360: Yes

	@see NxParameter getParameter

</member>
        <member name="M:NxPhysicsSDK.release">
	\brief Destroys the instance it is called on.

	Use this release method to destroy an instance of this class. Be sure
	to not keep a reference to this object after calling release.
	Avoid release calls while a scene is simulating (in between simulate() and fetchResults() calls).

	Releasing an SDK will also release any scenes, triangle meshes, convex meshes, heightfields, CCD skeletons, and cloth
	meshes created through it, provided the user hasn't already done so.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxCreatePhysicsSDK()

</member>
        <member name="T:NxPhysicsSDK">
	\brief Abstract singleton factory class used for instancing objects in the Physics SDK.

	In addition you can use NxPhysicsSDK to set global parameters which will effect all scenes,
	create triangle meshes and CCD skeletons.
	
	You can get an instance of this class by calling NxCreatePhysicsSDK().

	@see NxCreatePhysicsSDK() NxScene NxParameter NxTriangleMesh NxConvexMesh NxPhysicsSDK.createCCDSkeleton()

</member>
        <member name="M:NxPhysicsSDKDesc.isValid">
	\brief Returns true if the descriptor is valid.

	\return return true if the current settings are valid

</member>
        <member name="M:NxPhysicsSDKDesc.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="F:NxPhysicsSDKDesc.flags">
	\brief SDK creation flags.

	@see NxSDKCreationFlag

</member>
        <member name="T:NxPhysicsSDKDesc">
\brief Descriptor class for NxPhysicsSDK, primarily used for defining PhysX hardware limits
       for data shared between scenes.

</member>
        <member name="M:NxGetValue(NxCookingValue)">
\brief Reads an internal value (cooking format version).

\param[in] cookValue See #NxCookingValue

</member>
        <member name="T:NxSDKCreationFlag">
\brief SDK creation flags

</member>
        <member name="F:NX_SDKF_NO_HARDWARE">
	\brief Disallows the use of the hardware for the application.
	
	A good example of when this flag is useful is when a client and server app must be run on the same
	machine. Under normal circumstances the SDK will lock the use of the hardware to the first application
	which attempts to use it. In the case of a client and server it is desirable to have the server run in 
	software mode and allow the client to use the hardware.

	<b>Platform:</b>
	\li PC SW: No
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: No

	@see NxPhysicsSDKDesc

</member>
        <member name="F:NX_COOKING_CONVEX_VERSION_PC">
	Version numbers follow this format:

		Version = 16bit|16bit

	The high part is increased each time the format changes so much that
	pre-cooked files become incompatible with the system (and hence must
	be re-cooked)

	The low part is increased each time the format changes but the code
	can still read old files. You don't need to re-cook the data in that
	case, unless you want to make sure cooked files are optimal.

</member>
        <member name="T:NxInterfaceType">
\addtogroup fluids
  @{

\addtogroup physics
  @{

</member>
        <member name="T:NxEmitterType">
\brief Flags to specify the emitter's type of operation.
Exactly one flag should be set at any time.

@see NxFluidEmitter

</member>
        <member name="T:NxEmitterShape">
\brief Flags to specify the shape of the area of emission.

Exactly one flag should be set at any time.


</member>
        <member name="T:NxFluidEmitterFlag">
@} 
\addtogroup fluids
  @{

\brief Flags which control the behavior of fluid emitters.

@see NxFluidEmitter

</member>
        <member name="F:NX_FEF_ENABLED">
\brief Flag to start and stop the emission. On default the emission is enabled.

</member>
        <member name="F:NX_FEF_ADD_BODY_VELOCITY">
\brief If set, the velocity of the shapes body is added to the emitted particle velocity.

This is the default behaviour.

</member>
        <member name="F:NX_FEF_FORCE_ON_BODY">
\brief This flag specifies whether the emission should cause a force on 
the shapes body that the emitter is attached to.

</member>
        <member name="F:NX_FEF_VISUALIZATION">
\brief Flags whether the emitter should be visualized for debugging or not.

</member>
        <member name="M:NxFluidPacketData.#ctor">
\brief Constructor sets to default.

</member>
        <member name="M:NxFluidPacketData.isValid">
\brief Returns true if the current settings are valid

</member>
        <member name="M:NxFluidPacketData.setToDefault">
\brief (Re)sets the structure to the default.	

</member>
        <member name="F:NxFluidPacketData.numFluidPacketsPtr">
\brief Points to the user-allocated memory holding the number of packets stored in the buffers.

</member>
        <member name="F:NxFluidPacketData.bufferFluidPackets">
\brief The pointer to the user-allocated buffer for fluid packets.

</member>
        <member name="T:NxFluidPacketData">
\brief Data structure to receive AABBs per fluid packet.

Important: The array lengths need to be equivalent to the maxPacket parameter of the NxFluid 
this is applied to.


</member>
        <member name="F:NxFluidPacket.packetID">
\brief The packet's Identifier.

</member>
        <member name="F:NxFluidPacket.numParticles">
\brief Number of particles inside the packet.

</member>
        <member name="F:NxFluidPacket.firstParticleIndex">
	\brief Index of first particle for a given packet.  This index can be used to index into each of the buffers in NxParticleData.

	@see NxParticleData

</member>
        <member name="F:NxFluidPacket.aabb">
\brief AABB of all particles which are inside the same packet.

</member>
        <member name="T:NxFluidPacket">
@} 
\addtogroup fluids
  @{

\brief Data structure to represent a bounding box and its associated particle data of a fluid packet.

</member>
        <member name="M:NxParticleUpdateData.#ctor">
\brief Constructor sets to default.

</member>
        <member name="M:NxParticleUpdateData.isValid">
\brief Returns true if the current settings are valid

</member>
        <member name="M:NxParticleUpdateData.setToDefault">
\brief (Re)sets the structure to the default.	

</member>
        <member name="F:NxParticleUpdateData.bufferIdByteStride">
	\brief The separation (in bytes) between consecutive particle ids.

	The id of the first particle is found at location <tt>bufferId</tt>;
	the second is at <tt>bufferId + bufferIdByteStride</tt>;
	and so on.

</member>
        <member name="F:NxParticleUpdateData.bufferFlagByteStride">
	\brief The separation (in bytes) between consecutive particle update flags.

	The update flags of the first particle is found at location <tt>bufferFlag</tt>;
	the second is at <tt>bufferFlag + bufferFlagByteStride</tt>;
	and so on.

</member>
        <member name="F:NxParticleUpdateData.bufferForceByteStride">
	\brief The separation (in bytes) between consecutive particle forces.

	The force of the first particle is found at location <tt>bufferForce</tt>;
	the second is at <tt>bufferForce + bufferForceByteStride</tt>;
	and so on.

</member>
        <member name="F:NxParticleUpdateData.bufferId">
	\brief The pointer to the user-allocated buffer for id based updates.

	Particle ids are represented as a 32-bit unsigned integer. If set the NULL, NxFluid::updateParticles(...) 
	will assume an index based update on all particles.

</member>
        <member name="F:NxParticleUpdateData.bufferFlag">
	\brief The pointer to the user-allocated buffer for particle update flags.

	Particle update flags are represented as a 32-bit unsigned integer. If set the NULL, flags are not read from.
	Use NxParticleDataFlag to set the information.

</member>
        <member name="F:NxParticleUpdateData.bufferForce">
\brief The pointer to the user-allocated buffer for particle forces.

A force consists of three consecutive 32-bit floats. If set to NULL, forces are not read.

</member>
        <member name="F:NxParticleUpdateData.numUpdates">
\brief Number of elements stored in the update buffers. 

When passing id based updates to the SDK, the number is used to determine 
how many ids and update forces or flags need to be read from the buffers. If passing particle order based 
updates this parameter is ignored. 

</member>
        <member name="F:NxParticleUpdateData.forceMode">
	\brief Defines how the "force" buffer is interpreted.

	Supported:
		NX_FORCE,                   
		NX_IMPULSE,                 
		NX_VELOCITY_CHANGE,			
		NX_ACCELERATION		

	@see NxForceMode

</member>
        <member name="T:NxParticleDataFlag">
@} 
\addtogroup fluids
  @{

Particle update flags are used specify flags which can be updated on the particles.

</member>
        <member name="M:NxParticleIdData.#ctor">
\brief Constructor sets to default.

</member>
        <member name="M:NxParticleIdData.isValid">
\brief Returns true if the current settings are valid

</member>
        <member name="M:NxParticleIdData.setToDefault">
\brief (Re)sets the structure to the default.	

</member>
        <member name="F:NxParticleIdData.bufferIdByteStride">
	\brief The separation (in bytes) between consecutive particle IDs.

	The ID of the first particle is found at location <tt>bufferId</tt>;
	the second is at <tt>bufferId + bufferIdByteStride</tt>;
	and so on.

</member>
        <member name="F:NxParticleIdData.bufferId">
	\brief The pointer to the user-allocated buffer for particle IDs.

	A particle ID is represented with a 32-bit unsigned integer. If set to NULL, IDs are not written to.

</member>
        <member name="F:NxParticleIdData.numIdsPtr">
\brief Points to the user-allocated memory holding the number of IDs stored in the buffer. 

If the SDK writes to a given ID buffer, it also sets the numbers of IDs written. If 
this is set to NULL, the SDK can't write to the ID buffer.

</member>
        <member name="T:NxParticleIdData">
@} 
\addtogroup fluids
  @{

\brief Descriptor-like user-side class describing a set of fluid particle IDs.

NxParticleIdData is used to retrieve information about a selection of particles in the simulation. 

Each particle is created with an ID. This ID is unique within the current set of particles. Also, each ID
is guaranteed to be in the interval [0,NxFluidDesc::maxParticles). The user can use the particle IDs to
manage per particle user data.


</member>
        <member name="M:NxParticleData.#ctor">
\brief Constructor sets to default.

</member>
        <member name="M:NxParticleData.isValid">
\brief Returns true if the current settings are valid

</member>
        <member name="M:NxParticleData.setToDefault">
\brief (Re)sets the structure to the default.	

</member>
        <member name="F:NxParticleData.bufferCollisionNormalByteStride">
	\brief The separation (in bytes) between consecutive particle collision normals.

	The normal of the first particle is found at location <tt>bufferCollisionNormal</tt>;
	the second is at <tt>bufferCollisionNormal + bufferCollisionNormalByteStride</tt>;
	and so on.

</member>
        <member name="F:NxParticleData.bufferFlagByteStride">
	\brief The separation (in bytes) between consecutive particle flags.

	The flags of the first particle is found at location <tt>bufferFlag</tt>;
	the second is at <tt>bufferFlag + bufferFlagByteStride</tt>;
	and so on.

</member>
        <member name="F:NxParticleData.bufferIdByteStride">
	\brief The separation (in bytes) between consecutive particle IDs.

	The ID of the first particle is found at location <tt>bufferId</tt>;
	the second is at <tt>bufferId + bufferIdByteStride</tt>;
	and so on.

</member>
        <member name="F:NxParticleData.bufferDensityByteStride">
	\brief The separation (in bytes) between consecutive particle densities.

	The density of the first particle is found at location <tt>bufferDensity</tt>;
	the second is at <tt>bufferDensity + bufferDensityByteStride</tt>;
	and so on.

</member>
        <member name="F:NxParticleData.bufferLifeByteStride">
	\brief The separation (in bytes) between consecutive particle lifetimes.

	The lifetime of the first particle is found at location <tt>bufferLife</tt>;
	the second is at <tt>bufferLife + bufferLifeByteStride</tt>;
	and so on.

</member>
        <member name="F:NxParticleData.bufferVelByteStride">
	\brief The separation (in bytes) between consecutive particle velocities.

	The velocity of the first particle is found at location <tt>bufferVel</tt>;
	the second is at <tt>bufferVel + bufferVelByteStride</tt>;
	and so on.

</member>
        <member name="F:NxParticleData.bufferPosByteStride">
	\brief The separation (in bytes) between consecutive particle positions.

	The position of the first particle is found at location <tt>bufferPos</tt>;
	the second is at <tt>bufferPos + bufferPosByteStride</tt>;
	and so on.

</member>
        <member name="F:NxParticleData.bufferCollisionNormal">
	\brief The pointer to the user-allocated buffer for particle collision normals.

	A collision normal consists of three consecutive 32-bit 
	floats. If set to NULL, normals are not read or written to.
	
	Limitation: Collision normals can only be received if 
	NxFluidDesc.flags.NX_FF_COLLISION_TWOWAY is NOT set.

</member>
        <member name="F:NxParticleData.bufferFlag">
	\brief The pointer to the user-allocated buffer for particle flags.

	A particle flags are represented as a 32-bit unsigned integer. If set to NULL, flags are not written to.
	Flags are never read from the user, they are always defined by the SDK. 
	Use NxParticleFlag to interpret this data.

</member>
        <member name="F:NxParticleData.bufferId">
	\brief The pointer to the user-allocated buffer for particle IDs.

	A particle id is represented as a 32-bit unsigned integer. If set to NULL, IDs are not written to.
	IDs are never read from the user, they are always defined by the SDK.

</member>
        <member name="F:NxParticleData.bufferDensity">
	\brief The pointer to the user-allocated buffer for particle densities.

	A particle density consists of one 32-bit float. If set to NULL, densities are not written to.
	Densities are never read from the user, they are always defined by the fluid simulation.

</member>
        <member name="F:NxParticleData.bufferLife">
	\brief The pointer to the user-allocated buffer for particle lifetimes.

	A particle lifetime consists of one 32-bit 
	float. If set to NULL, lifetimes are not read or written to.

</member>
        <member name="F:NxParticleData.bufferVel">
	\brief The pointer to the user-allocated buffer for particle velocities.

	A velocity consists of three consecutive 32-bit 
	floats. If set to NULL, velocities are not read or written to.

</member>
        <member name="F:NxParticleData.bufferPos">
	\brief The pointer to the user-allocated buffer for particle positions.

	A position consists of three consecutive 32-bit floats. If set to NULL, positions are not read or written to.

</member>
        <member name="F:NxParticleData.numParticlesPtr">
\brief Points to the user-allocated memory holding the number of elements stored in the buffers. 

If the SDK writes to a given particle buffer, it also sets the numbers of elements written. If 
numParticlesPtr is set to NULL, the SDK can't write to the given buffer. 
When passing particles to the SDK, the number stored at the location is used to determine 
how many particles need to be read from the buffer. Therefore it is critical to set the value
numParticlesPtr is pointing to, to the correct number of particles which are prepared to be added 
to the simulation. Otherwise erroneous data gets processed which has undefined results.

</member>
        <member name="T:NxParticleData">
\brief Descriptor-like user-side class describing a set of fluid particles.

NxParticleData is used to submit particles to the simulation and
to retrieve information about particles in the simulation. 

Each particle is described by its position, velocity, lifetime, density, and a set of (NxParticleFlag) flags.
The memory for the particle data is allocated by the application,
making this class a "user buffer wrapper".

</member>
        <member name="T:NxParticleFlag">
@} 
\addtogroup fluids
  @{

Particle flags are used to give some additional information about the particles.

</member>
        <member name="M:NxMeshData.#ctor">
\brief Constructor sets to default.

</member>
        <member name="M:NxMeshData.isValid">
\brief Returns true if the current settings are valid

</member>
        <member name="M:NxMeshData.setToDefault">
\brief (Re)sets the structure to the default.	

</member>
        <member name="F:NxMeshData.flags">
\brief Flags of type #NxMeshDataFlags

</member>
        <member name="F:NxMeshData.dirtyBufferFlagsPtr">
	\brief Must point to the user allocated memory holding the dirty buffer flags

	If the SDK changes the content of a given buffer, it also sets the corresponding flag of
	type #NxMeshDataDirtyBufferFlags. This functionality is only supported in conjunction with
	cloth yet. The returned value for other features is undefined.

</member>
        <member name="F:NxMeshData.numParentIndicesPtr">
\brief Must point to the user allocated memory holding the number of vertex parent indices

If the SDK writes to a given vertex parent index buffer, it also sets the number of
parent indices written. 

</member>
        <member name="F:NxMeshData.maxParentIndices">
\brief The maximal number of parent indices which can be stored in the user parent index buffer.

</member>
        <member name="F:NxMeshData.parentIndicesByteStride">
\brief Specifies the distance of two vertex parent indices start addresses in bytes.

</member>
        <member name="F:NxMeshData.parentIndicesBegin">
	\brief The pointer to the user specified buffer for vertex parent indices. 
	
	An index consist of one 32 or 16 bit integers, depending on whether NX_MDF_16_BIT_INDICES has been set.

	Parent indices are provided when vertices are duplicated by the SDK (e.g. cloth tearing).
	The parent index of an original vertex is its position in the verticesPos buffer. The
	parent index of a vertex generated by duplication is the index of the vertex it was copied from.
	
	If the pointer is not initialized (NULL), no data is returned.

</member>
        <member name="F:NxMeshData.numIndicesPtr">
\brief Must point to the user allocated memory holding the number of vertex triplets used to define 
triangles.

If the SDK writes to a given triangle index buffer, it also sets the number of
triangles written.

</member>
        <member name="F:NxMeshData.maxIndices">
\brief The maximal number of indices which can be stored in the user index buffer.

</member>
        <member name="F:NxMeshData.indicesByteStride">
\brief Specifies the distance of two vertex indices start addresses in bytes.

</member>
        <member name="F:NxMeshData.indicesBegin">
\brief The pointer to the user specified buffer for vertex indices.

An index consist of one 32 or 16 bit integers, depending on whether NX_MDF_16_BIT_INDICES has been set.

If the pointer is not initialized (NULL), no data is returned.

</member>
        <member name="F:NxMeshData.numVerticesPtr">
\brief Must point to the user allocated memory holding the number of vertices stored in the user vertex 
buffers.

If the SDK writes to a given vertex buffer, it also sets the numbers of elements written.

</member>
        <member name="F:NxMeshData.maxVertices">
\brief The maximal number of vertices which can be stored in the user vertex buffers.

</member>
        <member name="F:NxMeshData.verticesNormalByteStride">
\brief Specifies the distance of two vertex normal start addresses in bytes.

</member>
        <member name="F:NxMeshData.verticesPosByteStride">
\brief Specifies the distance of two vertex position start addresses in bytes.

</member>
        <member name="F:NxMeshData.verticesNormalBegin">
	\brief 	The pointer to the user specified buffer for vertex normals. 

	A vertex normal consists of three consecutive 32 bit floats.
	If the pointer is not initialized (NULL), no data is returned.

</member>
        <member name="F:NxMeshData.verticesPosBegin">
	\brief 	The pointer to the user specified buffer for vertex positions.

	A vertex position consists of three consecutive 32 bit floats.
	If the pointer is not initialized (NULL), no data is returned.

</member>
        <member name="T:NxMeshData">
\brief Descriptor-like user-side class for describing mesh data.

This data type is used for specifying how the SDK is supposed to pass generated mesh data. This is used 
to pass simulated cloth meshes back to the user.

This class is very similar to NxSimpleTriangleMesh, with the difference that this user buffer 
wrapper is used to let the SDK write to user buffers instead of reading from them.

</member>
        <member name="T:NxMeshDataDirtyBufferFlags">
\brief Enum with flag values to be used in NxMeshData::dirtyBufferFlagsPtr.

</member>
        <member name="F:NX_MDF_PARENT_INDICES_DIRTY">
\brief Denotes a change in the parent index buffer.

</member>
        <member name="F:NX_MDF_INDICES_DIRTY">
\brief Denotes a change in the index buffer.

</member>
        <member name="F:NX_MDF_VERTICES_NORMAL_DIRTY">
\brief Denotes a change in the vertex normal buffer.

</member>
        <member name="F:NX_MDF_VERTICES_POS_DIRTY">
\brief Denotes a change in the vertex position buffer.

</member>
        <member name="T:NxMeshDataFlags">
@} 
\addtogroup fluids
  @{

\addtogroup fluids
  @{

\addtogroup cloth
  @{

\brief Very similar to #NxMeshFlags used for the #NxSimpleTriangleMesh type.

</member>
        <member name="F:NX_MDF_16_BIT_INDICES">
\brief Denotes the use of 16-bit vertex indices.

</member>
        <member name="T:NxProfilerData">
\brief Array of profiling data. 

 profileZones points to an array of numZones profile zones.  Zones are sorted such that the parent zones always come before their children.  
 Some zones have multiple parents (code called from multiple places) in which case only the relationship to the first parent is displayed.
 returned by NxScene::readProfileData().

</member>
        <member name="T:NxProfileZone">
@} 
\addtogroup foundation
  @{

\brief A profiling zone. 

A profiling zone is a named piece of code whose performance characteristics have been measured.

</member>
        <member name="F:NxSceneStats2.stats">
\brief Array of #NxSceneStatistic structures.

</member>
        <member name="F:NxSceneStats2.numStats">
\brief The number of #NxSceneStatistic structures stored.

</member>
        <member name="T:NxSceneStats2">
\brief Class used to retrieve statistics for a scene.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

@see NxScene::getStats2()

</member>
        <member name="F:NxSceneStatistic.parent">
\brief The index into the array of NxSceneStatistics (see #NxSceneStats2) of the parent of the statistic; if no parent exists, the value is 0xFFFFFFFF).

</member>
        <member name="F:NxSceneStatistic.name">
\brief Pointer to the name of the statistic

</member>
        <member name="F:NxSceneStatistic.maxValue">
\brief Maximum value of the statistic over the entire lifetime of the scene

</member>
        <member name="F:NxSceneStatistic.curValue">
\brief Current value of the statistic

</member>
        <member name="T:NxSceneStatistic">
@} 
\addtogroup physics
  @{

\brief Scene statistic counters

</member>
        <member name="M:NxSceneStats.reset">
\brief Zeros all members.

</member>
        <member name="F:NxSceneStats.maxJoints">
\brief Max number of joints in the scene since it was created.

</member>
        <member name="F:NxSceneStats.numJoints">
\brief Number of joints in the scene. Note that this number also includes all "dead joints"
in the scene (see NxScene.releaseActor).

</member>
        <member name="F:NxSceneStats.maxDynamicShapes">
\brief Max number of dynamic actors present in the scene, since it was created.

</member>
        <member name="F:NxSceneStats.numDynamicShapes">
\brief Number of dynamic shapes present in the scene for the current simulation step.

</member>
        <member name="F:NxSceneStats.maxStaticShapes">
\brief Max number of static shapes present in the scene since it was created.

</member>
        <member name="F:NxSceneStats.numStaticShapes">
\brief Number of static shapes present in the scene.

</member>
        <member name="F:NxSceneStats.maxDynamicActors">
\brief Max number of dynamic actors present in the scene since it was created.

</member>
        <member name="F:NxSceneStats.numDynamicActors">
\brief Number of dynamic actors present in the scene for the current simulation step.

</member>
        <member name="F:NxSceneStats.maxActors">
\brief Max number of actors(static+dynamic) present in the scene since the scene was created.

</member>
        <member name="F:NxSceneStats.numActors">
\brief Number of actors(static+dynamic) present in the scene for the current simulation step.

</member>
        <member name="F:NxSceneStats.maxSolverBodies">
\brief Max number of solver bodies present in the scene since creation. Not supported in 2.6.

</member>
        <member name="F:NxSceneStats.numSolverBodies">
\brief Number of solver bodies present in the current step(i.e. the number of bodies subject to constraints). Not supported in 2.6.

</member>
        <member name="F:NxSceneStats.maxAxisConstraints">
\brief The maximum number of constraints(joints+contacts) present in the scene since creation. Not supported in 2.6.

</member>
        <member name="F:NxSceneStats.numAxisConstraints">
\brief The number of constraints(joints+contact) present in the current simulation step. Not supported in 2.6.

</member>
        <member name="F:NxSceneStats.maxDynamicActorsInAwakeGroups">
\brief Maximum number of actors which have been present in a non sleeping island since the scene was created.

</member>
        <member name="F:NxSceneStats.numDynamicActorsInAwakeGroups">
\brief Number of dynamic actors which are not part of a sleeping group(island)

</member>
        <member name="F:NxSceneStats.maxPairs">
\brief Maximum number of shape pairs present in the scene since the scene was created.

</member>
        <member name="F:NxSceneStats.numPairs">
\brief Number of shape pairs present in the scene for the current simulation step.

</member>
        <member name="F:NxSceneStats.maxContacts">
\brief Maximum number of contacts present in the scene since the scene was created. Not supported in 2.6.

</member>
        <member name="F:NxSceneStats.numContacts">
\brief Number of contacts present in the scene for the current simulation step. Not supported in 2.6.

</member>
        <member name="T:NxSceneStats">
@} 
\addtogroup physics
  @{

\brief Class used to retrieve statistics for a scene.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Partial (Actors, dynamic actors, joints)
\li PS3  : Yes
\li XB360: Yes

@see NxScene::getStats()

</member>
        <member name="M:NxSceneDesc.isValid">
\brief Returns true if the descriptor is valid.
\return true if the current settings are valid (returns always true).

</member>
        <member name="M:NxSceneDesc.setToDefault">
\brief (re)sets the structure to the default (no gravity, no ground plane, collision detection on).	

</member>
        <member name="M:NxSceneDesc.#ctor">
\brief constructor sets to default (no gravity, no ground plane, collision detection on).

</member>
        <member name="F:NxSceneDesc.solverBatchSize">
	\brief Defines the number of actors required to spawn a separate rigid body solver thread.

	\note Internal multi threading must be enabled (see #NX_SF_ENABLE_MULTITHREAD) for this member to have
	any effect.

	<b>Default:</b> 32

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Not applicable
	\li PS3  : Not applicable
	\li XB360: Yes

	@see NxScene.setSolverBatchSize() NxScene.getSolverBatchSize()

</member>
        <member name="F:NxSceneDesc.nbGridCellsY">
	\brief Defines the number of broadphase cells along the grid y-axis.

	\note Must be power of two. Max is 8 at the moment. The broadphase type must be set to NX_BP_TYPE_SAP_MULTI 
	for this parameter to have an effect.

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : No
	\li PS3  : No
	\li XB360: Yes

	@see NxSceneDesc.bpType

</member>
        <member name="F:NxSceneDesc.nbGridCellsX">
	\brief Defines the number of broadphase cells along the grid x-axis.

	\note Must be power of two. Max is 8 at the moment. The broadphase type must be set to NX_BP_TYPE_SAP_MULTI 
	for this parameter to have an effect.

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : No
	\li PS3  : No
	\li XB360: Yes

	@see NxSceneDesc.bpType

</member>
        <member name="F:NxSceneDesc.bpType">
	\brief Defines which type of broadphase to use.

	<b>Default:</b> NX_BP_TYPE_SAP_SINGLE

	@see NxBroadPhaseType

</member>
        <member name="F:NxSceneDesc.userData">
	\brief Will be copied to NxScene::userData

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxSceneDesc.dynamicStructure">
\brief Defines the structure used to store dynamic objects.

</member>
        <member name="F:NxSceneDesc.staticStructure">
	\brief Defines the structure used to store static objects.

	\note Only NX_PRUNING_STATIC_AABB_TREE and NX_PRUNING_DYNAMIC_AABB_TREE are allowed here.

</member>
        <member name="F:NxSceneDesc.subdivisionLevel">
	\brief Defines the subdivision level for acceleration structures used for scene queries.

	\note WARNING: this is only used when maxBounds are defined.

</member>
        <member name="F:NxSceneDesc.upAxis">
	\brief Defines the up axis for your world. This is used to accelerate scene queries like
	raycasting or sweep tests. Internally, a 2D structure is used instead of a 3D one whenever
	an up axis is defined. This saves memory and is usually faster.

	Use 1 for Y = up, 2 for Z = up, or 0 to disable this feature.
	It is not possible to use X = up.

	\note WARNING: this is only used when maxBounds are defined.

</member>
        <member name="F:NxSceneDesc.backgroundThreadMask">
	\brief Allows the user to specify which (logical) processor to allocate SDK background threads.

	The SDK Will allocate internal threads to processors corresponding to bits which are set. Starting from
	the least significant bit.

	This flag is ignored for platforms which do not associate threads exclusively to specific processors.

	\note The XBox 360 associates threads with specific processors.
	\note The special value of 0 lets the SDK determine the thread affinity.

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: Yes

</member>
        <member name="F:NxSceneDesc.backgroundThreadPriority">
	\brief Sets the thread priority of the SDK created background threads

	The default is normal priority.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: No

</member>
        <member name="F:NxSceneDesc.backgroundThreadCount">
	\brief Sets the number of SDK managed threads which will be processing background tasks.

	For example scene queries can run on these threads or the SDK may need to preprocess data to be sent to the 
	PhysX card.

	This member must be set to 0 if the application takes over control of the work allocation with a custom scheduler.

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: Yes

	@see customScheduler

</member>
        <member name="F:NxSceneDesc.threadMask">
	\brief Allows the user to specify which (logical) processor to allocate SDK internal worker threads to.

	The SDK Will allocate internal threads to processors corresponding to bits which are set. Starting from
	the least significant bit.

	This flag is ignored for platforms which do not associate threads exclusively to specific processors.

	\note The XBox 360 associates threads with specific processors.
	\note This is poorly named; should be renamed workerThreadMask for consistency.
	\note The special value of 0 lets the SDK determine the thread affinity.
	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: Yes

</member>
        <member name="F:NxSceneDesc.workerThreadPriority">
	\brief Sets the thread priority of the SDK created worker threads

	The default is normal priority.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: No

</member>
        <member name="F:NxSceneDesc.workerThreadStackSize">
	\brief Allows the user to specify the stack size for the worker threads created by the SDK.

	The value is specified in bytes and rounded to an appropriate size by the operating system.

	NOTE: If you increase the stack size for all threads that call the SDK, you may want to call
	#NxFoundationSDK::setAllocaThreshold to prevent unnecessary heap allocations.

	Specifying a value of zero will cause the SDK to choose a platform specific default value.

	
	\li PC SW - OS default
	\li PPU - OS default
	\li XBox 360 - OS default

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: Yes

</member>
        <member name="F:NxSceneDesc.internalThreadCount">
	\brief Sets the number of SDK managed worker threads used when running the simulation in parallel.

	When internal multi threading is enabled(see #NX_SF_ENABLE_MULTITHREAD) the SDK creates a number of
	threads to run the simulation. This member controls the number of threads.

	This member is ignored if the application takes over control of the work allocation with a custom scheduler.

	\note This is poorly named; should be renamed workerThreadCount for consistency.

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: Yes

	@see customScheduler

</member>
        <member name="F:NxSceneDesc.simThreadMask">
	\brief Allows the user to specify which (logical) processor to allocate the simulation thread to.

	The sim thread will be allocated to processors corresponding to bits which are set. Starting from
	the least significant bit.

	This flag is ignored for platforms which do not associate threads exclusively to specific processors.

	\note The XBox 360 associates threads with specific processors.
	\note The special value of 0 lets the SDK determine the thread affinity.

	<b>Default:</b> 0

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: Yes

</member>
        <member name="F:NxSceneDesc.simThreadPriority">
	\brief Sets the thread priority of the main simulation thread.

	The default is normal priority.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: No

</member>
        <member name="F:NxSceneDesc.simThreadStackSize">
	\brief Allows the user to specify the stack size for the main simulation thread.

	The value is specified in bytes and rounded to an appropriate size by the operating system.

	NOTE: If you increase the stack size for all threads that call the SDK, you may want to call
	#NxFoundationSDK::setAllocaThreshold to prevent unnecessary heap allocations.

	Specifying a value of zero will cause the SDK to choose a platform specific default value:

	\li PC SW - OS default
	\li PPU - OS default
	\li PS3 - 256k
	\li XBox 360 - OS default

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NxSceneDesc.customScheduler">
	\brief Defines a custom scheduler.

	The application can define a custom scheduler to completely take over the allocation of work items among threads.

	An alternative is for the application to use the built in scheduler. See #internalThreadCount

	<b>Default:</b> NULL (disabled)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: Yes

	@see NxScheduler NX_SF_ENABLE_MULTITHREAD internalThreadCount

</member>
        <member name="F:NxSceneDesc.flags">
	\brief Flags used to select scene options.

	<b>Default:</b> NX_SF_SIMULATE_SEPARATE_THREAD | NX_SF_DISABLE_SCENE_MUTEX

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Partial
	\li PS3  : Yes (however, default value is NX_SF_SIMULATE_SEPARATE_THREAD)
	\li XB360: Yes

	@see NxSceneFlags

</member>
        <member name="F:NxSceneDesc.boundsPlanes">
	\brief Enable/disable 6 planes around maxBounds (if available)

	<b>Default:</b> false

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see maxBounds

</member>
        <member name="F:NxSceneDesc.groundPlane">
	\brief Enable/disable default ground plane

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	<b>Default:</b> false

</member>
        <member name="F:NxSceneDesc.simType">
	\brief Used to specify if the scene is a master hardware or software scene.

	<b>Default:</b> NX_SIMULATION_SW

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSimulationType

</member>
        <member name="F:NxSceneDesc.limits">
	\brief Expected scene limits (or NULL)

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxSceneLimits

</member>
        <member name="F:NxSceneDesc.timeStepMethod">
	\brief Integration method.

	<b>Default:</b> NX_TIMESTEP_FIXED

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxTimeStepMethod NxScene.setTiming() maxTimestep maxIter

</member>
        <member name="F:NxSceneDesc.maxIter">
	\brief Maximum number of substeps to take

	<b>Default:</b> 8

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxScene.setTiming() maxTimestep

</member>
        <member name="F:NxSceneDesc.userActorPairFiltering">
\brief Internal. Do not use!

</member>
        <member name="F:NxSceneDesc.userContactReport">
	\brief Possible contact callback

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxUserContactReport NxScene.setUserContactReport() NxScene.getUserContactReport()

</member>
        <member name="F:NxSceneDesc.userTriggerReport">
	\brief Possible trigger callback

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxUserTriggerReport NxScene.setUserTriggerReport() NxScene.getUserTriggerReport()

</member>
        <member name="F:NxSceneDesc.userContactModify">
	\brief Possible asynchronous callback for contact modification

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxUserContactModify NxScene.setUserContactModify() NxScene.getUserContactModify()

</member>
        <member name="F:NxSceneDesc.softBodyUserNotify">
	\brief Possible notification callback for softBodys

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: No
	\li PPU  : No
	\li PS3  : No
	\li XB360: No

	@see NxSoftBodyUserNotify NxScene.setSoftBodyUserNotify() NxScene.getSoftBodyUserNotify()

</member>
        <member name="F:NxSceneDesc.clothUserNotify">
	\brief Possible notification callback for cloths

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: No
	\li PPU  : No
	\li PS3  : No
	\li XB360: No

	@see NxClothUserNotify NxScene.setClothUserNotify() NxScene.getClothUserNotify()

</member>
        <member name="F:NxSceneDesc.fluidUserNotify">
	\brief Possible notification callback for fluids

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: No
	\li PPU  : No
	\li PS3  : No
	\li XB360: No

	@see NxFluidUserNotify NxScene.setFluidUserNotify() NxScene.getFluidUserNotify()

</member>
        <member name="F:NxSceneDesc.userNotify">
	\brief Possible notification callback

	<b>Default:</b> NULL

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxUserNotify NxScene.setUserNotify() NxScene.getUserNotify()

</member>
        <member name="T:NxSceneDesc">
\brief Descriptor class for scenes. See #NxScene.

@see NxScene NxPhysicsSDK.createScene maxBounds

</member>
        <member name="T:NxSceneLimits">
\brief Class used to retrieve limits(e.g. max number of bodies) for a scene. The limits
are used as a hint to the size of the scene, not as a hard limit (i.e. it will be possible
to create more objects than specified in the scene limits).

<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NX_SF_FLUID_PERFORMANCE_HINT">
	\brief Enables faster but less accurate fluid collision with static geometry.

	If the flag is set static geometry is considered one simulation step late, which 
	can cause particles to leak through static geometry. In order to prevent this, 
	NxFluidDesc.collisionDistanceMultiplier can be increased.
	
	<b>Default:</b> False

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NX_SF_SEQUENTIAL_PRIMARY">
	\brief When set to 1, the compartments are all executed before the primary scene is executed.  This may lower performance
	but it improves interaction quality between compartments and the primary scene.

	<b>Default:</b> False

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: No

</member>
        <member name="F:NX_SF_FORCE_CONE_FRICTION">
	\brief Force the friction model to cone friction

	This ensures that all contacts in the scene will use cone friction, rather than the default
	simplified scheme. This will however have a negative impact on performance in software scenes. Use this
	flag if sliding objects show an affinity for moving along the world axes.

	\note Only applies to software scenes; hardware scenes always force cone friction.
	
	Cone friction may also be activated on an actor-by-actor basis using the NX_AF_FORCE_CONE_FRICTION flag, see #NxActorFlag.

	<b>Default:</b> False

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes (always active)
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NX_SF_DISABLE_SCENE_MUTEX">
	\brief Disable the mutex which serializes scene execution

	Under normal circumstances scene execution is serialized by a mutex. This flag
	can be used to disable this serialization.

	\warning This flag is _experimental_ and in future versions is likely be removed. In favour of 
	completely removing	the mutex.

	If this flag is used the recommended scenario is for use with a software scene and hardware fluid/cloth scene.

	<b>Default:</b> True (change from earlier beta versions)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NX_SF_RESTRICTED_SCENE">
	\brief Enable Restricted Scene.

	\note Only applies to hardware scenes.

	This flag creates a restricted scene, running the broadphase collision detection on hardware, 
	while limiting the number of actors (see "AGEIA PhysX Hardware Scenes" in the Guide).

	<b>Default:</b> False

	<b>Platform:</b>
	\li PC SW: No
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: No

</member>
        <member name="F:NX_SF_ENABLE_ACTIVETRANSFORMS">
	\brief Enable Active Transform Notification.

	This flag enables the the Active Transform Notification feature for a scene.  This
	feature defaults to disabled.  When disabled, the function
	NxScene::getActiveTransforms() will always return a NULL list.

	\note There may be a performance penalty for enabling the Active Transform Notification, hence this flag should
	only be enabled if the application intends to use the feature.

	<b>Default:</b> False

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="F:NX_SF_ENABLE_MULTITHREAD">
	\brief Enable internal multi threading.

	This flag enables the multi threading code within the SDK which allows the simulation to
	be divided into tasks for execution on an arbitrary number of threads. 
	
	This is an orthogonal feature to running the simulation in a separate thread, see #NX_SF_SIMULATE_SEPARATE_THREAD.

	\note There may be a small performance penalty for enabling the multi threading code, hence this flag should
	only be enabled if the application intends to use the feature.

	<b>Default:</b> False

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : No
	\li XB360: Yes

	@see NxSceneDesc NX_SF_SIMULATE_SEPARATE_THREAD

</member>
        <member name="F:NX_SF_SIMULATE_SEPARATE_THREAD">
	\brief Perform the simulation in a separate thread.

	By default the SDK runs the physics on a separate thread to the user thread(i.e. the thread which
	calls the API).

	However if this flag is disabled, then the simulation is run in the thread which calls #NxScene::simulate()

	<b>Default:</b> True

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : No
	\li PS3  : Yes
	\li XB360: Yes

	@see NxScene.simulate()

</member>
        <member name="F:NX_SF_DISABLE_COLLISIONS">
	\brief Disable all collisions in a scene. Use the flags NX_AF_DISABLE_COLLISION and NX_SF_DISABLE_COLLISION for disabling collisions between specific actors and shapes.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NX_AF_DISABLE_COLLISION, NX_SF_DISABLE_COLLISION

</member>
        <member name="F:NX_SF_DISABLE_SSE">
	\brief Used to disable use of SSE in the solver.

	SSE is detected at runtime(on appropriate platforms) and used if present by default.

	However use of SSE can be disabled, even if present, using this flag.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : N/A
	\li PS3  : N/A
	\li XB360: N/A

</member>
        <member name="T:NxBroadPhaseType">
\brief Selects a broadphase type.

</member>
        <member name="F:NX_BP_TYPE_SAP_MULTI">
	\brief A multi sweep-and-prune algorithm to find pairs of potentially colliding shapes.
	
	Uses a configurable 2D grid to divide the scene space into cells. The potentially overlapping 
	shape pairs are detected in each cell and the information is merged together. This approach
	is usually faster than NX_BP_TYPE_SAP_SINGLE in scenarios with many shapes and a high creation/deletion
	rate of shapes. However, the amount of memory required is considerably higher depending on the
	number of grid cells used.

	\note The following extra parameters need to be defined:
	\li NxSceneDesc.maxBounds
	\li NxSceneDesc.upAxis
	\li NxSceneDesc.nbGridCellsX
	\li NxSceneDesc.nbGridCellsY

	\n

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : No
	\li PS3  : No
	\li XB360: Yes

	@see NxSceneDesc.bpType

</member>
        <member name="F:NX_BP_TYPE_SAP_SINGLE">
	\brief A sweep-and-prune (SAP) algorithm to find pairs of potentially colliding shapes.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="T:NxPruningStructure">
\brief Pruning structure used to accelerate scene queries (raycast, sweep tests, etc)

	NX_PRUNING_NONE can be used without defining extra parameters. It typically doesn't provide
	fast scene queries, but on the other hand it doesn't consume much memory. It is useful when
	you don't use the SDK's scene queries at all.

	NX_PRUNING_OCTREE usually provides fast queries and cheap per-object updates. You need
	to define "maxBounds" and "subdivisionLevel" to use this structure.

	NX_PRUNING_QUADTREE is the 2D version of NX_PRUNING_OCTREE. It is usually a better choice
	when your world is mostly flat. It is sometimes a better choice for non-flat worlds as well.
	You need to define "maxBounds", "subdivisionLevel" and "upAxis" to use this structure.

	NX_PRUNING_DYNAMIC_AABB_TREE usually provides the fastest queries. However there is a
	constant per-frame management cost associated with this structure. You have the option to
	give a hint on how much work should be done per frame by setting the parameter
	#NxSceneDesc::dynamicTreeRebuildRateHint.

	NX_PRUNING_STATIC_AABB_TREE is typically used for static objects. It is the same as the
	dynamic AABB tree, without the per-frame overhead. This is the default choice for static
	objects. However, if you are streaming parts of the world in and out, you may want to use
	the dynamic version even for static objects.

</member>
        <member name="T:NxSimulationType">
\brief Used to choose between a hardware and software master scene.

This enum is used with the NxSceneDesc::simType member.

\note The master scene is a rigid body scene (which can also contain cloth); compartments are used for fluid.
Compartments can run in hardware even if the master scene is a software scene.

@see NxSceneDesc

</member>
        <member name="T:NxTimeStepMethod">
@} 
\addtogroup physics
  @{

\brief Used to specify the timestepping behavior.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

@see NxSceneDesc

</member>
        <member name="M:NxSceneQuery.linearCapsuleSweep(NxCapsule!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,NxGroupsMask!System.Runtime.CompilerServices.IsConst*,System.Void*)">
	\brief Perform a linear capsule sweep.
	
	This function returns 0 and	calls the query report callback when the batched queries are executed.

	See #NxScene::linearCapsuleSweep() for more details.

</member>
        <member name="M:NxSceneQuery.linearOBBSweep(NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,NxGroupsMask!System.Runtime.CompilerServices.IsConst*,System.Void*)">
	\brief Perform a linear OBB sweep.
	
	This function returns 0 and calls the query report callback when the batched queries are executed.

	See #NxScene::linearOBBSweep() for more details.

</member>
        <member name="M:NxSceneQuery.cullShapes(System.UInt32,NxPlane!System.Runtime.CompilerServices.IsConst*,NxShapesType,System.UInt32,NxGroupsMask!System.Runtime.CompilerServices.IsConst*,System.Void*)">
	\brief Find the set of shapes which are in the negative half space of a number of planes.

	This function returns 0 and	calls the query report callback when the batched queries are executed.

	See #NxScene::cullShapes() for more details.

</member>
        <member name="M:NxSceneQuery.overlapCapsuleShapes(NxCapsule!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShapesType,System.UInt32,NxGroupsMask!System.Runtime.CompilerServices.IsConst*,System.Void*)">
	\brief Find all shapes which overlap a capsule.

	This function returns 0 and calls the query report callback when the batched queries are executed.
	
	See #NxScene::overlapCapsuleShapes() for more details.

</member>
        <member name="M:NxSceneQuery.overlapOBBShapes(NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShapesType,System.UInt32,NxGroupsMask!System.Runtime.CompilerServices.IsConst*,System.Void*)">
	\brief Find all shapes which overlap an OBB.

	This function returns 0 and calls the query report callback when the batched queries are executed.


	See #NxScene::overlapOBBShapes() for more details.

</member>
        <member name="M:NxSceneQuery.overlapAABBShapes(NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShapesType,System.UInt32,NxGroupsMask!System.Runtime.CompilerServices.IsConst*,System.Void*)">
	\brief Find all shapes which overlap an AABB.
	
	This function returns 0 and	calls the query report callback when the batched queries are executed.

	See #NxScene::overlapAABBShapes() for more details.

</member>
        <member name="M:NxSceneQuery.overlapSphereShapes(NxSphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShapesType,System.UInt32,NxGroupsMask!System.Runtime.CompilerServices.IsConst*,System.Void*)">
	\brief Find all shapes which overlap a sphere.

	This function returns 0 and	calls the query report callback when the batched queries are executed.

	See #NxScene::overlapSphereShapes() for more details.

</member>
        <member name="M:NxSceneQuery.raycastAllShapes(NxRay!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShapesType,System.UInt32,System.Single,System.UInt32,NxGroupsMask!System.Runtime.CompilerServices.IsConst*,System.Void*)">
	\brief Find all the shapes which a ray intersects.

	This function returns 0 and	calls the query report callback when the batched queries are executed.

	See #NxScene::raycastAllShapes() for more details.

</member>
        <member name="M:NxSceneQuery.raycastClosestShape(NxRay!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShapesType,NxRaycastHit*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.Single,System.UInt32,NxGroupsMask!System.Runtime.CompilerServices.IsConst*,NxShape**,System.Void*)">
	\brief Find the closest ray/shape intersection.

	This function returns NULL and calls the query report callback when the batched queries are executed.

	See #NxScene::raycastClosestShape() for more details.

</member>
        <member name="M:NxSceneQuery.checkOverlapCapsule(NxCapsule!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShapesType,System.UInt32,NxGroupsMask!System.Runtime.CompilerServices.IsConst*,System.Void*)">
	\brief Check if a capsule overlaps shapes.
	
	This function returns false and calls the query report callback when the batched queries are executed.

	See #NxScene::checkOverlapCapsule() for more details.

</member>
        <member name="M:NxSceneQuery.checkOverlapOBB(NxBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShapesType,System.UInt32,NxGroupsMask!System.Runtime.CompilerServices.IsConst*,System.Void*)">
	\brief Check if an OBB overlaps shapes.
	
	This function returns false and calls the query report callback when the batched queries are executed.

	See #NxScene::checkOverlapOBB() for more details.

</member>
        <member name="M:NxSceneQuery.checkOverlapAABB(NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShapesType,System.UInt32,NxGroupsMask!System.Runtime.CompilerServices.IsConst*,System.Void*)">
	\brief Check if a AABB overlaps shapes.

	This function returns false and calls the query report callback when the batched queries are executed.

	See #NxScene::checkOverlapAABB() for more details.

</member>
        <member name="M:NxSceneQuery.checkOverlapSphere(NxSphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShapesType,System.UInt32,NxGroupsMask!System.Runtime.CompilerServices.IsConst*,System.Void*)">
	\brief Check if a sphere overlaps shapes.

	This function returns false and calls the query report callback when the batched queries are executed.

	See #NxScene::checkOverlapSphere() for more details.

</member>
        <member name="M:NxSceneQuery.raycastAnyShape(NxRay!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxShapesType,System.UInt32,System.Single,NxGroupsMask!System.Runtime.CompilerServices.IsConst*,NxShape**,System.Void*)">
	\brief Check if a ray intersects any shape.

	This function returns false and calls the query report callback when the batched queries are executed.

	See #NxScene::raycastAnyShape() for more details.

</member>
        <member name="M:NxSceneQuery.finish(System.Boolean)">
	\brief Used to determine if an execute call has completed.
	
	You should not call this without calling the execute function.
	
	When calling this method with the block parameter set to true, the method will not return until 
	all batched queries have been executed.

	\param[in] block Specifies if this function should wait until queries are complete.
	\return true when all queries have executed.

	@see execute()

</member>
        <member name="M:NxSceneQuery.execute">
	\brief Executes batched queries.

	In the synchronous mode the batched queries are executed immediately. In the asynchronous mode
	they can be executed at any point between calling execute() and finish() returning true.

	WARNING: NxSceneDesc::backgroundThreadCount must be at least 1 for the asynchronous mode to work,
	         else the queries will be processed in synchronous mode.

	@see finish()

</member>
        <member name="M:NxSceneQuery.getExecuteMode">
	\brief Gets the execution mode

	\return The execution mode for this query object.

	@see NxSceneQueryExecuteMode

</member>
        <member name="M:NxSceneQuery.getQueryReport">
	\brief Gets report object

	\return The query report callback associated with this object.

	@see NxSceneQueryReport

</member>
        <member name="T:NxSceneQuery">
\brief Batched queries object. This is used to perform several queries at the same time. The queries are the same as the
previously available scene queries in #NxScene.

@see NxSceneQueryReport NxSceneQueryExecuteMode

</member>
        <member name="F:NxSceneQueryDesc.executeMode">
	\brief The method used to execute the queries. ie synchronous or asynchronous.

	WARNING: NxSceneDesc::backgroundThreadCount must be at least 1 for the asynchronous mode to work,
	         else the queries will be processed in synchronous mode.

	@see NxSceneQueryExecuteMode NxSceneQuery

</member>
        <member name="F:NxSceneQueryDesc.report">
	\brief The callback class used to return results from the batched queries.

	@see NxSceneQueryReport NxSceneQuery

</member>
        <member name="T:NxSceneQueryDesc">
\brief Descriptor class for #NxSceneQuery.

@see NxSceneQuery NxSceneQueryReport NxSceneQueryExecuteMode

</member>
        <member name="M:NxSceneQueryReport.onSweepQuery(System.Void*,System.UInt32,NxSweepQueryHit*)">
	\brief Callback function used to return sweep query results.

	This function reports results from the following functions:
	
	\li #NxSceneQuery::linearOBBSweep()
	\li #NxSceneQuery::linearCapsuleSweep()

	\param[in] userData User data pointer passed to the query function.
	\param[in] nbHits Number of sweep hits.
	\param[in] hits Array of sweep hits (size nbHits)
	\return Specifies the action the SDK should take, eg continue or abort the query.

	@see NxQueryReportResult

</member>
        <member name="M:NxSceneQueryReport.onShapeQuery(System.Void*,System.UInt32,NxShape**)">
	\brief Callback function used to return shape query results.

	This function reports results from the following functions:
	
	\li #NxSceneQuery::overlapSphereShapes()
	\li #NxSceneQuery::overlapAABBShapes()
	\li #NxSceneQuery::overlapOBBShapes()
	\li #NxSceneQuery::overlapCapsuleShapes()
	\li #NxSceneQuery::cullShapes()

	\param[in] userData User data pointer passed to the query function.
	\param[in] nbHits Number of hits returned.
	\param[in] hits Array of shape pointers.
	\return Specifies the action the SDK should take, e.g. continue or abort the query.

	@see NxQueryReportResult

</member>
        <member name="M:NxSceneQueryReport.onRaycastQuery(System.Void*,System.UInt32,NxRaycastHit!System.Runtime.CompilerServices.IsConst*)">
	\brief Callback function used to return raycast query results.

	This function reports results from the following functions:
	
	\li #NxSceneQuery::raycastClosestShape()
	\li #NxSceneQuery::raycastAllShapes()

	\param[in] userData User data pointer passed to the query function.
	\param[in] nbHits Number of hit shapes
	\param[in] hits Array of hit descriptors (size nbHits)
	\return Specifies the action the SDK should take, eg continue or abort the query.

	@see NxQueryReportResult

</member>
        <member name="M:NxSceneQueryReport.onBooleanQuery(System.Void*,System.Boolean)">
	\brief Callback function used to return boolean query results.

	This function reports results from the following functions:
	
	\li #NxSceneQuery::raycastAnyShape()
	\li #NxSceneQuery::checkOverlapSphere()
	\li #NxSceneQuery::checkOverlapAABB()
	\li #NxSceneQuery::checkOverlapOBB()
	\li #NxSceneQuery::checkOverlapCapsule()

	\param[in] userData User data pointer passed to the query function.
	\param[in] result True if there is an intersection/overlap
	\return Specifies the action the SDK should take, eg continue or abort the query.

	@see NxQueryReportResult

</member>
        <member name="T:NxSceneQueryReport">
\brief User-defined object needed to get back query results from NxSceneQuery objects.

@see NxSceneQuery NxQueryReportResult

</member>
        <member name="T:NxQueryReportResult">
\brief Specifies the behaviour after a query result.

@see NxSceneQueryReport NxSceneQuery

</member>
        <member name="T:NxSceneQueryExecuteMode">
\brief Specifies the nature of the query object.

In synchronous mode, a call to NxSceneQuery::execute() will block and batched queries are executed
immediately.

In asynchronous mode, a call to NxSceneQuery::execute() will not block and batched queries are executed
at any point between calling NxSceneQuery::execute() and NxSceneQuery::finish() returning true.

Note: This is a new feature in 2.7.0, and there are still some issues that will be fixed in a future version:
* cullShapes() does not work in asynchronous mode
* the return value from overlapXShapes() might not be correct in synchronous mode
* linearOBBSweep() and linearCapsuleSweep() always returns 0 when NX_SF_ALL_HITS is used.

@see NxSceneQueryDesc NxSceneQuery

</member>
        <member name="T:NxSweepQueryHit">
@} 
\addtogroup physics
  @{


 \brief Struct used with the Sweep API.
 Related methods: NxScene::linearOBBSweep(), NxScene::linearCapsuleSweep(), 
 NxActor::linearSweep().

 @see NxScene, NxActor

</member>
        <member name="M:NxUserRaycastReport.onHit(NxRaycastHit!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief This method is called for each shape hit by the raycast.
	
	If onHit returns true, it may be called again with the next shape that was stabbed.
	If it returns false, no further shapes are returned, and the raycast is concluded.

	\note SDK state should not be modified from within onHit(). In particular objects should not
	be created or destroyed. If state modification is needed then the changes should be stored to a buffer
	and performed after the raycast.

	\param[in] hits The data corresponding to the ray intersection. See #NxRaycastHit.
	\return True to continue the raycast. False to abort.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : No
	\li PS3  : Yes
	\li XB360: Yes
	}{

	@see NxScene.raycastAllBounds
    @see NxScene.raycastAllShapes

</member>
        <member name="T:NxUserRaycastReport">
\brief The user needs to pass an instance of this class to several of the ray casting routines in
NxScene.

Its onHit method will be called for each shape that the ray intersects.

Example:

\include NxUserRaycastReport_Usage.cpp

@see NxScene.raycastAllBounds
@see NxScene.raycastAllShapes

</member>
        <member name="F:NxRaycastHit.flags">
	Combination of ::NxRaycastBit, when a corresponding flag is set, then the member is valid.

	::NxRaycastBit flags can be passed to raycasting functions, as an optimization, to cause the SDK to
	only generate specific members of this structure.

</member>
        <member name="F:NxRaycastHit.materialIndex">
	Index of touched material (associated flags: NX_RAYCAST_MATERIAL)

	@see flags

</member>
        <member name="F:NxRaycastHit.u">
	Impact barycentric coordinates (associated flags: NX_RAYCAST_UV)

	@see flags

</member>
        <member name="F:NxRaycastHit.distance">
	Distance from ray start to impact point (associated flags: NX_RAYCAST_DISTANCE)

	@see flags

</member>
        <member name="F:NxRaycastHit.faceID">
	Index of touched face (associated flags: NX_RAYCAST_FACE_INDEX)

	The face index is for the mesh <b>before</b> cooking. During the cooking process faces are moved 
	around which changes there index. However the SDK stores a table which is used to map the index to the original
	mesh before it is returned for a raycast hit.

	@see flags

</member>
        <member name="F:NxRaycastHit.worldNormal">
	Impact normal in world space (associated flags: NX_RAYCAST_NORMAL / NX_RAYCAST_FACE_NORMAL)

	For #NxConvexShape and #NxTriangleMeshShape NX_RAYCAST_NORMAL generates a smooth normal. If a true
	face normal is required use NX_RAYCAST_FACE_NORMAL instead when specifying hint flags to a raycast method.

	@see flags

</member>
        <member name="F:NxRaycastHit.worldImpact">
	Impact point in world space (associated flags: NX_RAYCAST_IMPACT)

	@see flags

</member>
        <member name="F:NxRaycastHit.shape">
	Touched shape (associated flags: NX_RAYCAST_SHAPE)

	@see flags

</member>
        <member name="T:NxRaycastHit">
\brief This structure captures results for a single raycast query.

All members of the NxRaycastHit structure are not always available. For example when the ray hits a sphere,
the faceID member is not computed. Also, when raycasting against bounds (AABBs) instead of actual shapes,
some members are not available either. 

Some members like barycentric coordinates are currently only computed for triangle meshes and convexes, but next versions
might provide them in other cases. The client code should check #flags to make sure returned values are
relevant.

When used as hint flags in raycasting queries, those bits control what the user would like to see computed
in the NxRaycastHit structure. For example, you might tell the SDK to compute impact normals using the
NX_RAYCAST_NORMAL hint flag. It's usually faster to let the SDK do it, instead of fetching relevant data
again in the client app. However all users may not need this information. In this case, just omit this flag
and corresponding member of ::NxRaycastHit will not be computed internally - saving processing time. 

Note that NX_RAYCAST_NORMAL computes a smoothed normal, while NX_RAYCAST_FACE_NORMAL only returns the usual
normal of a triangle (i.e. the normalized cross product of two edges).

See #NxScene and #NxShape for raycasting methods.

 <b>Threading:</b> It is not necessary to make this class thread safe as it will only be called in the context of the
 user thread.


@see NxScene.raycastAllBounds
@see NxScene.raycastAllShapes
@see NxScene.raycastClosestBounds
@see NxScene.raycastClosestShape

</member>
        <member name="T:NxRaycastBit">

Specifies which members of #NxRaycastHit which should be generated(when used as hint flags for raycasting methods)
or which members have been generated when checking the flags member of #NxRaycastHit.

@see NxRaycastHit

</member>
        <member name="T:NxShapesType">
Used to specify which types(static or dynamic) of shape to test against when used with raycasting and 
overlap test methods in #NxScene.

@see NxScene NxScene.raycastAllBounds() NxScene.raycastAllShapes() NxScene.raycastClosestBounds()
NxScene.raycastClosestShape() NxScene.raycastAnyBounds() NxScene.raycastAnyShape() NxScene.overlapSphereShapes()
NxScene.overlapAABBShapes()

</member>
        <member name="T:NxShape">
@} 
\addtogroup physics
  @{


\brief Abstract base class for the various collision shapes.

An instance of a subclass can be created by calling the createShape() method of the NxActor class,
or by adding the shape descriptors into the NxActorDesc class before creating the actor.

Note: in order to avoid a naming conflict, downcast operators are isTYPE(), while up casts are getTYPE().

<h3>Visualizations</h3>
\li NX_VISUALIZE_COLLISION_AABBS
\li NX_VISUALIZE_COLLISION_SHAPES
\li NX_VISUALIZE_COLLISION_AXES

The AGEIA PhysX SDK users guide describes which shapes that can collide with each other (direct link: <a href="PhysXDocumentation.chm::/Guide/collision_Interactions.html">users guide</a>)

@see NxActor.createShape() NxSphereShape NxPlaneShape NxConvexShape NxTriangleMeshShape NxCapsuleShape NxBoxShape


@} 
\addtogroup physics
  @{


@} 
\addtogroup physics
  @{

</member>
        <member name="T:NxHeightFieldFlags">
\brief Enum with flag values to be used in NxHeightFieldDesc.flags.

</member>
        <member name="F:NX_HF_NO_BOUNDARY_EDGES">
		\brief Disable collisions with height field with boundary edges.
		
		Raise this flag if several terrain patches are going to be placed adjacent to each other, 
		to avoid a bump when sliding across.

		This flag is ignored in contact generation with sphere and capsule shapes.

		<b>Platform:</b>
		\li PC SW: Yes
		\li PPU  : Yes (Software fallback)
		\li PS3  : Yes
		\li XB360: Yes

		@see NxHeightFieldDesc.flags

</member>
        <member name="T:NxHeightFieldTessFlag">
\brief Determines the tessellation of height field cells.
@see NxHeightFieldDesc.format NxHeightFieldDesc.samples

</member>
        <member name="F:NX_HF_0TH_VERTEX_SHARED">
		\brief This flag determines which way each quad cell is subdivided.

		The flag lowered indicates subdivision like this: (the 0th vertex is referenced by only one triangle)
		
		\image html heightfieldTriMat2.PNG

		<pre>
		+--+--+--+---&gt; column
		| /| /| /|
		|/ |/ |/ |
		+--+--+--+
		| /| /| /|
		|/ |/ |/ |
		+--+--+--+
		|
		|
		V row
		</pre>
		
		The flag raised indicates subdivision like this: (the 0th vertex is shared by two triangles)
		
		\image html heightfieldTriMat1.PNG

		<pre>
		+--+--+--+---&gt; column
		|\ |\ |\ |
		| \| \| \|
		+--+--+--+
		|\ |\ |\ |
		| \| \| \|
		+--+--+--+
		|
		|
		V row
		</pre><b>Platform:</b>
		\li PC SW: Yes
		\li PPU  : Yes (Software fallback)
		\li PS3  : Yes
		\li XB360: Yes

		@see NxHeightFieldDesc.format NxHeightFieldDesc.samples

</member>
        <member name="T:NxHeightFieldFormat">
\brief Describes the format of height field samples.
@see NxHeightFieldDesc.format NxHeightFieldDesc.samples

</member>
        <member name="F:NX_HF_S16_TM">
		\brief Height field height data is 16 bit signed integers, followed by triangle materials. 
		
		Each sample is 32 bits wide arranged as follows:
		
		\image html heightFieldFormat_S16_TM.png

		1) First there is a 16 bit height value.
		2) Next, two one byte material indices, with the high bit of each byte reserved for special use.
		(so the material index is only 7 bits).
		The high bit of material0 is the tess-flag.
		The high bit of material1 is reserved for future use.
		
		There are zero or more unused bytes before the next sample depending on NxHeightFieldDesc.sampleStride, 
		where the application may eventually keep its own data.

		This is the only format supported at the moment.

		<b>Platform:</b>
		\li PC SW: Yes
		\li PPU  : Yes (Software fallback)
		\li PS3  : Yes
		\li XB360: Yes

		@see NxHeightFieldDesc.format NxHeightFieldDesc.samples

</member>
        <member name="T:NxHWVersion">
Identifies the version of hardware present in the machine.

</member>
        <member name="T:NxSepAxis">
	Identifies each possible seperating axis for a pair of oriented bounding boxes.

	@see NxSeparatingAxis()

</member>
        <member name="T:NxFilterOp">
\brief Collision filtering operations.

@see NxGroupsMask

</member>
        <member name="T:NxGroupsMask">
	\brief 128-bit mask used for collision filtering.

	The collision filtering equation for 2 shapes S0 and S1 is:

	<pre> (G0 op0 K0) op2 (G1 op1 K1) == b </pre>

	with

	<ul><li> G0 = NxGroupsMask for shape S0. See ::setGroupsMask </li><li> G1 = NxGroupsMask for shape S1. See ::setGroupsMask </li><li> K0 = filtering constant 0. See ::setFilterConstant0 </li><li> K1 = filtering constant 1. See ::setFilterConstant1 </li><li> b = filtering boolean. See ::setFilterBool </li><li> op0, op1, op2 = filtering operations. See ::setFilterOps </li></ul>

	If the filtering equation is true, collision detection is enabled.

	@see NxScene::setFilterOps()

</member>
        <member name="T:NxParameter">
\brief Parameters enums to be used as the 1st arg to setParameter or getParameter.

@see NxPhysicsSDK.setParameter() NxPhysicsSDK.getParameter()

</member>
        <member name="F:NX_PARAMS_NUM_VALUES">
\brief This is not a parameter, it just records the current number of parameters (as max(NxParameter)+1) for use in loops.
When a new parameter is added this number should be assigned to it and then incremented.

</member>
        <member name="F:NX_ASYNCHRONOUS_MESH_CREATION">
	\brief [Experimental] Disables scene locks when creating/releasing meshes.

	Prevents the SDK from locking all scenes when creating and releasing triangle meshes, convex meshes, height field 
	meshes, softbody meshes and cloth meshes, which is the default behavior. Can be used to improve parallelism but beware
	of possible side effects.

	\warning Experimental feature.

</member>
        <member name="F:NX_VISUALIZE_FORCE_FIELDS">
\brief Force field visualization.

</member>
        <member name="F:NX_VISUALIZE_ACTIVE_VERTICES">
\brief Internal, used for debugging and testing. Not to be used.

</member>
        <member name="F:NX_SELECT_HW_ALGO">
\brief Internal, used for debugging and testing. Not to be used.

</member>
        <member name="F:NX_VISUALIZE_SOFTBODY_VALIDBOUNDS">
\brief Soft body valid bounds visualization.

</member>
        <member name="F:NX_VISUALIZE_SOFTBODY_ATTACHMENT">
\brief Soft body attachments visualization.

</member>
        <member name="F:NX_VISUALIZE_SOFTBODY_TEARING">
\brief Soft body tearing visualization.

</member>
        <member name="F:NX_VISUALIZE_SOFTBODY_TEARABLE_VERTICES">
\brief Soft body tearable vertices visualization.

</member>
        <member name="F:NX_VISUALIZE_SOFTBODY_SLEEP_VERTEX">
\brief Soft body per vertex sleeping visualization.

</member>
        <member name="F:NX_VISUALIZE_SOFTBODY_SLEEP">
\brief Soft body overall sleeping visualization.

</member>
        <member name="F:NX_VISUALIZE_SOFTBODY_WORKPACKETS">
\brief Soft body clustering for the PPU simulation visualization.

</member>
        <member name="F:NX_VISUALIZE_SOFTBODY_COLLISIONS">
\brief Soft body rigid body collision visualization.

</member>
        <member name="F:NX_VISUALIZE_SOFTBODY_MESH">
\brief Soft body mesh visualization.

</member>
        <member name="F:NX_VISUALIZE_CLOTH_VALIDBOUNDS">
\brief Cloth valid bounds visualization.

</member>
        <member name="F:NX_VISUALIZE_CLOTH_ATTACHMENT">
\brief Cloth attachments visualization.

</member>
        <member name="F:NX_VISUALIZE_CLOTH_TEARING">
\brief Cloth tearing visualization.

</member>
        <member name="F:NX_VISUALIZE_CLOTH_TEARABLE_VERTICES">
\brief Cloth tearable vertices visualization.

</member>
        <member name="F:NX_VISUALIZE_CLOTH_SLEEP_VERTEX">
\brief Cloth per vertex sleeping visualization.

</member>
        <member name="F:NX_VISUALIZE_CLOTH_SLEEP">
\brief Cloth overall sleeping visualization.

</member>
        <member name="F:NX_VISUALIZE_CLOTH_WORKPACKETS">
\brief Cloth clustering for the PPU simulation visualization.

</member>
        <member name="F:NX_VISUALIZE_CLOTH_SELFCOLLISIONS">
\brief Cloth cloth collision visualization.

</member>
        <member name="F:NX_VISUALIZE_CLOTH_COLLISIONS">
\brief Cloth rigid body collision visualization.

</member>
        <member name="F:NX_VISUALIZE_CLOTH_MESH">
\brief Cloth mesh visualization.

</member>
        <member name="F:NX_VISUALIZE_FLUID_PACKET_DATA">
\brief Fluid Packet Data visualization.

</member>
        <member name="F:NX_VISUALIZE_FLUID_DRAINS">
\brief Fluid drain shape visualization.

</member>
        <member name="F:NX_VISUALIZE_FLUID_MESH_PACKETS">
\brief Fluid available mesh packets visualization.

</member>
        <member name="F:NX_VISUALIZE_FLUID_STC_COLLISION">
\brief Fluid static collision visualization.

</member>
        <member name="F:NX_VISUALIZE_FLUID_DYN_COLLISION">
\brief Fluid dynamic collision visualization.

</member>
        <member name="F:NX_VISUALIZE_FLUID_MOTION_LIMIT">
\brief Fluid motion limit visualization.

</member>
        <member name="F:NX_VISUALIZE_FLUID_PACKETS">
\brief Fluid Packet visualization.

</member>
        <member name="F:NX_VISUALIZE_FLUID_BOUNDS">
\brief Fluid AABB visualization.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : No
\li PS3  : Yes
\li XB360: Yes

</member>
        <member name="F:NX_VISUALIZE_FLUID_KERNEL_RADIUS">
\brief Particle kernel radius visualization.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : No
\li PS3  : Yes
\li XB360: Yes

</member>
        <member name="F:NX_VISUALIZE_FLUID_VELOCITY">
\brief Particle velocity visualization.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : No
\li PS3  : Yes
\li XB360: Yes

</member>
        <member name="F:NX_VISUALIZE_FLUID_POSITION">
\brief Particle position visualization.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : No
\li PS3  : Yes
\li XB360: Yes

</member>
        <member name="F:NX_VISUALIZE_FLUID_EMITTERS">
\brief Emitter visualization.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : No
\li PS3  : Yes
\li XB360: Yes

</member>
        <member name="F:NX_VISUALIZE_COLLISION_SKELETONS">
	\brief Visualize CCD Skeletons

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxPhysicsSDK.createCCDSkeleton()

</member>
        <member name="F:NX_VISUALIZE_COLLISION_CCD">
	\brief Visualize the CCD tests

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxPhysicsSDK.createCCDSkeleton()

</member>
        <member name="F:NX_VISUALIZE_COLLISION_FREE">
\brief "Free" pruning structures

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : No
\li PS3  : Yes
\li XB360: Yes

</member>
        <member name="F:NX_VISUALIZE_COLLISION_DYNAMIC">
\brief Dynamic pruning structures

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : No
\li PS3  : Yes
\li XB360: Yes

</member>
        <member name="F:NX_VISUALIZE_COLLISION_STATIC">
\brief Static pruning structures

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : No
\li PS3  : Yes
\li XB360: Yes

</member>
        <member name="F:NX_VISUALIZE_COLLISION_SPHERES">
\brief Bounding spheres

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : No
\li PS3  : Yes
\li XB360: Yes

</member>
        <member name="F:NX_VISUALIZE_COLLISION_EDGES">
	\brief Active edges for meshes

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : No
	\li PS3  : Yes
	\li XB360: Yes

	@see NxTriangleMesh

</member>
        <member name="F:NX_VISUALIZE_COLLISION_COMPOUNDS">
\brief Compound visualization (compound AABBs in world space)

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : No
\li PS3  : Yes
\li XB360: Yes

</member>
        <member name="F:NX_VISUALIZE_COLLISION_AXES">
	\brief Shape axis visualization

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : No
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShape

</member>
        <member name="F:NX_VISUALIZE_COLLISION_SHAPES">
	\brief Shape visualization

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : No
	\li PS3  : Yes
	\li XB360: Yes

	@see NxShape

</member>
        <member name="F:NX_VISUALIZE_COLLISION_AABBS">
\brief Visualize bounds (AABBs in world space)

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : No
\li PS3  : Yes
\li XB360: Yes

</member>
        <member name="F:NX_VISUALIZE_ACTOR_AXES">
	\brief Visualize actor axes.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxActor

</member>
        <member name="F:NX_VISUALIZE_CONTACT_FORCE">
\brief Visualize Contact forces. Will enable contact information.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : No
\li PS3  : Yes
\li XB360: Yes

</member>
        <member name="F:NX_VISUALIZE_CONTACT_ERROR">
\brief  Visualize contact errors. Will enable contact information.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

</member>
        <member name="F:NX_VISUALIZE_CONTACT_NORMAL">
\brief Visualize contact normals. Will enable contact information.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

</member>
        <member name="F:NX_VISUALIZE_CONTACT_POINT">
\brief  Visualize contact points. Will enable contact information.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

</member>
        <member name="F:NX_VISUALIZE_JOINT_LIMITS">
	\brief Visualize joint limits.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : No
	\li PS3  : Yes
	\li XB360: Yes

	@see NxJoint

</member>
        <member name="F:NX_VISUALIZE_JOINT_WORLD_AXES">
	\brief Visualize joint world axes.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : No
	\li PS3  : Yes
	\li XB360: Yes

	@see NxJoint

</member>
        <member name="F:NX_VISUALIZE_JOINT_LOCAL_AXES">
	\brief Visualize local joint axes (including drive targets, if any)

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : No
	\li PS3  : Yes
	\li XB360: Yes

	@see NxJointDesc.localAxis NxJoint

</member>
        <member name="F:NX_VISUALIZE_BODY_JOINT_GROUPS">
\brief Visualize joint groups 

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : No
\li PS3  : Yes
\li XB360: Yes

</member>
        <member name="F:NX_VISUALIZE_BODY_ANG_VELOCITY">
	\brief Visualize the bodies angular velocity.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBodyDesc.angularVelocity NxActor

</member>
        <member name="F:NX_VISUALIZE_BODY_LIN_VELOCITY">
	\brief Visualize the bodies linear velocity.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBodyDesc.linearVelocity NxActor

</member>
        <member name="F:NX_VISUALIZE_BODY_MASS_AXES">
	\brief Visualize a body's mass axes.

	This visualization is also useful for visualizing the sleep state of bodies. Sleeping bodies are drawn in
	black, while awake bodies are drawn in white. If the body is sleeping and part of a sleeping group, it is
	drawn in red.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxBodyDesc.massLocalPose NxActor

</member>
        <member name="F:NX_VISUALIZE_BODY_AXES">
	\brief Visualize a bodies axes.

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : Yes
	\li PS3  : Yes
	\li XB360: Yes

	@see NxActor.globalPose NxActor

</member>
        <member name="F:NX_VISUALIZE_WORLD_AXES">
\brief Visualize the world axes.

<b>Platform:</b>
\li PC SW: Yes
\li PPU  : Yes
\li PS3  : Yes
\li XB360: Yes

</member>
        <member name="F:NX_PENALTY_FORCE">
	\brief DEPRECATED! Do not use!

	<b>Platform:</b>
	\li PC SW: Yes
	\li PPU  : No
	\li PS3  : Yes
	\li XB360: Yes

</member>
        <member name="T:NxQueryFlags">
\brief Used to control contact queries.

@see NxTriangleMeshShape.overlapAABBTriangles()

</member>
        <member name="T:NxSphericalJointFlag">
\brief Flags which control the behavior of spherical joints.

@see NxSphericalJoint NxSphericalJointDesc NxSphericalJointDesc.flags

</member>
        <member name="F:NX_SJF_PERPENDICULAR_DIR_CONSTRAINTS">
	\brief Add additional constraints to linear movement.

	Constrain movements along directions perpendicular to the distance vector defined by the two anchor points.

	\note Setting this flag can increase the stability of the joint but the computation will be more expensive.

</member>
        <member name="F:NX_SJF_JOINT_SPRING_ENABLED">
	\brief true if the joint spring is enabled

	@see NxSphericalJointDesc.jointSpring


</member>
        <member name="F:NX_SJF_SWING_SPRING_ENABLED">
	\brief true if the swing spring is enabled

	@see NxSphericalJointDesc.swingSpring

</member>
        <member name="F:NX_SJF_TWIST_SPRING_ENABLED">
	\brief true if the twist spring is enabled

	@see NxSphericalJointDesc.twistSpring

</member>
        <member name="F:NX_SJF_SWING_LIMIT_ENABLED">
	\brief true if the swing limit is enabled

	@see NxSphericalJointDesc.swingLimit

</member>
        <member name="F:NX_SJF_TWIST_LIMIT_ENABLED">
	\brief true if the twist limit is enabled

	@see NxSphericalJointDesc.twistLimit

</member>
        <member name="T:NxCompartmentFlag">
\brief Flags which control the properties of a scene compartment.

@see NxScene NxCompartmentDesc

</member>
        <member name="F:NX_CF_INHERIT_SETTINGS">
	\brief Inherit NX_CF_CONTINUOUS_CD and NX_CF_RESTRICTED_SCENE.

	Override the NX_CF_CONTINUOUS_CD and NX_CF_RESTRICTED_SCENE and inherit these settings from the SDK parameters and the
	primary scene respectively (i.e. NX_CONTINUOUS_CD and NX_SF_RESTRICTED_SCENE).

</member>
        <member name="F:NX_CF_RESTRICTED_SCENE">
	\brief Enable Restricted Scene on the compartment.

	\note Only applies to hardware scenes.
	\note This flag is immutable and can hence only be set at creation.

	@see NX_SF_RESTRICTED_SCENE

</member>
        <member name="F:NX_CF_CONTINUOUS_CD">
	\brief Enable/disable continuous collision detection on the compartment.

	@see NxPhysicsSDK.createCCDSkeleton()

</member>
        <member name="F:NX_CF_SLEEP_NOTIFICATION">
	\brief Enable/disable sleep event reporting

	If sleep notification is enabled for the compartment, onWake and onSleep will be called on the NxUserNotify associated with the master scene, if non-null. 
	Note that onWake and onSleep will be called one time for each compartment with sleep notification enabled, 
	i.e. not only once with all sleeping/awake bodies from all compartments.

	@see NxUserNotify

</member>
        <member name="T:NxActorFlag">
\brief Flags which control the behavior of an actor.

@see NxActor NxActorDesc NxActor.raiseBodyFlag()

</member>
        <member name="F:NX_AF_USER_ACTOR_PAIR_FILTERING">
	\brief Enable/disable custom contact filtering. 

	When enabled the user will be queried for contact filtering for all contacts involving this actor.

</member>
        <member name="F:NX_AF_FORCE_CONE_FRICTION">
	\brief Force cone friction to be used for this actor.	

	This ensures that all contacts involving the actor will use cone friction, rather than the default
	simplified scheme. This will however have a negative impact on performance in software scenes. Use this
	flag if sliding objects show an affinity for moving along the world axes.

	\note Only applies to software scenes. Hardware scenes always force cone friction.

	Cone friction may also be applied wholesale to a scene using the NX_SF_FORCE_CONE_FRICTION 
	flag, see #NxSceneFlags.

</member>
        <member name="F:NX_AF_CONTACT_MODIFICATION">
	\brief Turn on contact modification callback for the actor.

	@see NxScene.setUserContactModify(), NX_NOTIFY_CONTACT_MODIFICATION

</member>
        <member name="F:NX_AF_FLUID_DISABLE_COLLISION">
\brief Enable/disable collision with fluid.

</member>
        <member name="F:NX_AF_LOCK_COM">
	\brief Disables COM update when computing inertial properties at creation time.

	When sdk computes inertial properties, by default the center of mass will be calculated too.  However, if lockCOM is set to a non-zero (true) value then the center of mass will not be altered.

</member>
        <member name="F:NX_AF_DISABLE_RESPONSE">
	\brief Enable/disable collision response (reports contacts but don't use them)

	@see NxUserContactReport

</member>
        <member name="F:NX_AF_DISABLE_COLLISION">
	\brief Enable/disable collision detection

	Turn off collision detection, i.e. the actor will not collide with other objects. Please note that you might need to wake 
	the actor up if it is sleeping, this depends on the result you wish to get when using this flag. (If a body is asleep it 
	will not start to fall through objects unless you activate it).

	Note: Also excludes the actor from overlap tests!

</member>
        <member name="T:NxD6JointFlag">
\brief Flags which control the general behavior of D6 joints.

@see NxD6Joint NxD6JointDesc NxD6JointDesc.flags

</member>
        <member name="F:NX_D6JOINT_GEAR_ENABLED">
   	\brief Apply gearing to the angular motion, e.g. body 2s angular motion is twice body 1s etc.
   
   	@see NxD6JointDesc.gearRatio

</member>
        <member name="F:NX_D6JOINT_SLERP_DRIVE">
	\brief Drive along the shortest spherical arc.

	@see NxD6JointDesc.slerpDrive

</member>
        <member name="T:NxD6JointDriveType">
\brief Used to specify a particular drive method. i.e. Having a position based goal or a velocity based goal.

</member>
        <member name="F:NX_D6JOINT_DRIVE_VELOCITY">
	\brief Used to set a velocity goal when driving.

	Note: the appropriate target velocities should beset.

	@see NxD6JointDesc.xDrive NxD6Joint.swingDrive NxD6JointDesc.driveLinearVelocity

</member>
        <member name="F:NX_D6JOINT_DRIVE_POSITION">
	\brief Used to set a position goal when driving.

	Note: the appropriate target positions/orientations should be set.

	@see NxD6JointDesc.xDrive NxD6Joint.swingDrive NxD6JointDesc.drivePosition

</member>
        <member name="T:NxD6JointMotion">
\brief Used to specify the range of motions allowed for a DOF in a D6 joint.

@see NxD6Joint NxD6JointDesc
@see NxD6Joint.xMotion NxD6Joint.swing1Motion

</member>
        <member name="T:NxDistanceJointFlag">
\brief Flags which control the behavior of distance joints.

@see NxDistanceJoint NxDistanceJointDesc NxDistanceJointDesc.flags

</member>
        <member name="F:NX_DJF_SPRING_ENABLED">
\brief true if the spring is enabled

@see NxDistanceJointDesc.spring

</member>
        <member name="F:NX_DJF_MIN_DISTANCE_ENABLED">
\brief true if the joint enforces the minimum separate distance.

</member>
        <member name="F:NX_DJF_MAX_DISTANCE_ENABLED">
\brief true if the joint enforces the maximum separate distance.

</member>
        <member name="T:NxPulleyJointFlag">
\brief Flags to control the behavior of pulley joints.

@see NxPulleyJoint NxPulleyJointDesc NxPulleyJoint.setFlags()

</member>
        <member name="F:NX_PJF_MOTOR_ENABLED">
	\brief true if the motor is enabled

	@see NxPulleyJointDesc.motor

</member>
        <member name="F:NX_PJF_IS_RIGID">
\brief true if the joint also maintains a minimum distance, not just a maximum.

</member>
        <member name="T:NxRevoluteJointFlag">
\brief Flags to control the behavior of revolute joints.

@see NxRevoluteJoint NxRevoluteJointDesc

</member>
        <member name="F:NX_RJF_SPRING_ENABLED">
	\brief true if the spring is enabled. The spring will only take effect if the motor is disabled.

	@see NxRevoluteJoint.spring

</member>
        <member name="F:NX_RJF_MOTOR_ENABLED">
	\brief true if the motor is enabled

	@see NxRevoluteJoint.motor

</member>
        <member name="F:NX_RJF_LIMIT_ENABLED">
	\brief true if limits is enabled

	@see NxRevoluteJointDesc.limit

</member>
        <member name="T:NxJointProjectionMode">
\brief Joint projection modes.

Joint projection is a method for correcting large joint errors.

It is also necessary to set the distance above which projection occurs.

@see NxRevoluteJointDesc.projectionMode NxRevoluteJointDesc.projectionDistance NxRevoluteJointDesc.projectionAngle
@see NxSphericalJointDesc.projectionMode
@see NxD6JointDesc.projectionMode

</member>
        <member name="T:NxJointFlag">
\brief Joint flags.

@see NxJoint NxJointDesc

</member>
        <member name="F:NX_JF_VISUALIZATION">
	\brief Enable debug renderer for this joint

	@see NxScene.getDebugRenderable() NxDebugRenderable NxParameter

</member>
        <member name="F:NX_JF_COLLISION_ENABLED">
	\brief Raised if collision detection should be enabled between the bodies attached to the joint.

	By default collision constraints are not generated between pairs of bodies which are connected by joints.

</member>
        <member name="T:NxJointState">
\brief Describes the state of the joint.

@see NxJoint

</member>
        <member name="F:NX_JS_BROKEN">
\brief Set when the joint has been broken or one of the actors connected to the joint has been remove.
@see NxUserNotify.onJointBreak() NxJoint.setBreakable()

</member>
        <member name="F:NX_JS_SIMULATING">
\brief The joint is being simulated under normal conditions. I.e. it is not broken or deleted.

</member>
        <member name="F:NX_JS_UNBOUND">
\brief Not used.

</member>
        <member name="T:NxJointType">
\brief Identifies each type of joint.

@see NxJoint NxJointDesc NxScene.createJoint()

</member>
        <member name="F:NX_JOINT_D6">
	\brief A 6 degree of freedom joint

	@see NxD6Joint

</member>
        <member name="F:NX_JOINT_FIXED">
	\brief A "fixed" connection.

	@see NxFixedJoint

</member>
        <member name="F:NX_JOINT_PULLEY">
	\brief A pulley joint.

	@see NxPulleyJoint

</member>
        <member name="F:NX_JOINT_DISTANCE">
	\brief A point on one actor maintains a certain distance range to another point on another actor.

	@see NxDistanceJoint

</member>
        <member name="F:NX_JOINT_POINT_IN_PLANE">
	\brief A point on one actor is constrained to stay on a plane on another.

	@see NxPointInPlaneJoint

</member>
        <member name="F:NX_JOINT_POINT_ON_LINE">
	\brief A point on one actor is constrained to stay on a line on another.

	@see NxPointOnLineJoint

</member>
        <member name="F:NX_JOINT_SPHERICAL">
	\brief Also known as a ball or ball and socket joint.

	@see NxSphericalJoint

</member>
        <member name="F:NX_JOINT_CYLINDRICAL">
	\brief Formerly known as a sliding joint, permits one translational and one rotational degree of freedom.

	@see NxCylindricalJoint

</member>
        <member name="F:NX_JOINT_REVOLUTE">
	\brief Also known as a hinge joint, permits one rotational degree of freedom.

	@see NxRevoluteJoint

</member>
        <member name="F:NX_JOINT_PRISMATIC">
	\brief Permits a single translational degree of freedom.

	@see NxPrismaticJoint

</member>
        <member name="T:NxInternalArray">
\brief Enum to access internal data structures for triangle meshes and convex meshes.

@see NxTriangleMesh.getBase() NxConvexMesh.getBase()

</member>
        <member name="T:NxInternalFormat">
\brief Enum to access internal data structures for triangle meshes and convex meshes.

@see NxTriangleMesh.getFormat() NxConvexMesh.getFormat()

</member>
        <member name="D:NxSubmeshIndex">
\brief Typedef for submesh indexing.
@see NxTriangleMesh NxConvexMesh

</member>
        <member name="T:NxConstraintDominance">
\brief Expresses the dominance relationship of a constraint.
For the time being only three settings are permitted:

(1.0f, 1.0f), (0.0f, 1.0f), and (1.0f, 0.0f).

</member>
        <member name="T:NxActorGroupPair">
\brief Structure used to store actor group pair flags.

</member>
        <member name="T:NxTriangle32">
\brief Structure used to store indices for a triangles points.

</member>
        <member name="D:NxPoint">
\brief Compatability/readability typedef.

@see NxVec3

</member>
        <member name="T:NxHeightFieldAxis">
\brief Specifies which axis is the "up" direction for a heightfield.

</member>
        <member name="D:NxTriggerFlag">
\brief For compatibility with previous SDK versions before 2.1.1

@see NxShapeFlag

</member>
        <member name="T:NxShapeFlag">
\brief Flags which affect the behavior of NxShapes.

@see NxShape NxShapeDesc NxShape.setFlag()

</member>
        <member name="F:NX_SF_SOFTBODY_TWOWAY">
\brief  Enables the reaction of the shapes actor on soft body collision.
\warning Compound objects cannot use a different value for each constituent shape.

</member>
        <member name="F:NX_SF_CLOTH_TWOWAY">
\brief  Enables the reaction of the shapes actor on cloth collision.
\warning Compound objects cannot use a different value for each constituent shape.

</member>
        <member name="F:NX_SF_DISABLE_SCENE_QUERIES">
	\brief Disable participation in ray casts, overlap tests and sweeps.

	NOTE: Setting this flag for static non-trigger shapes may cause incorrect behavior for 
	colliding fluid and cloth.

</member>
        <member name="F:NX_SF_DYNAMIC_DYNAMIC_CCD">
\brief Enable dynamic-dynamic CCD for this shape. Used only when CCD is globally enabled and shape have a CCD skeleton.

</member>
        <member name="F:NX_SF_DISABLE_RESPONSE">
	\brief Disable collision response for this shape (counterpart of NX_AF_DISABLE_RESPONSE)

	\warning not supported by cloth / soft bodies

</member>
        <member name="F:NX_SF_POINT_CONTACT_FORCE">
\brief Enable contact force reporting per contact point in contact stream (otherwise we only report force per actor pair)

</member>
        <member name="F:NX_SF_DISABLE_RAYCASTING">
\brief Disable raycasting for this shape

</member>
        <member name="F:NX_SF_FEATURE_INDICES">
	\brief Enable feature indices in contact stream.

	@see NxUserContactReport NxContactStreamIterator NxContactStreamIterator.getFeatureIndex0()

</member>
        <member name="F:NX_SF_DISABLE_COLLISION">
	\brief Disable collision detection for this shape (counterpart of NX_AF_DISABLE_COLLISION)

	\warning IMPORTANT: this is only used for compound objects! Use NX_AF_DISABLE_COLLISION otherwise.

</member>
        <member name="F:NX_SF_VISUALIZATION">
	\brief Enable debug renderer for this shape

	@see NxScene.getDebugRenderable() NxDebugRenderable NxParameter

</member>
        <member name="F:NX_TRIGGER_ENABLE">
	\brief Combination of all the other trigger enable flags.

	@see NxUserTriggerReport NxScene.setUserTriggerReport()

</member>
        <member name="F:NX_TRIGGER_ON_STAY">
	\brief Trigger callback will be called while a shape is intersecting the trigger volume.

	@see NxUserTriggerReport NxScene.setUserTriggerReport()

</member>
        <member name="F:NX_TRIGGER_ON_LEAVE">
	\brief Trigger callback will be called after a shape leaves the trigger volume.

	@see NxUserTriggerReport NxScene.setUserTriggerReport()

</member>
        <member name="F:NX_TRIGGER_ON_ENTER">
	\brief Trigger callback will be called when a shape enters the trigger volume.

	@see NxUserTriggerReport NxScene.setUserTriggerReport()

</member>
        <member name="T:NxBodyFlag">
\brief Collection of flags describing the behavior of a dynamic rigid body.

@see NxBodyDesc NxActor NxActorDesc

</member>
        <member name="F:NX_BF_ENERGY_SLEEP_TEST">
\brief Enables energy-based sleeping algorithm.
@see NxActor.isSleeping() NxBodyDesc.sleepEnergyThreshold 

</member>
        <member name="F:NX_BF_FILTER_SLEEP_VEL">
\brief Filter velocities used keep body awake. The filter reduces rapid oscillations and transient spikes.
@see NxActor.isSleeping()

</member>
        <member name="F:NX_BF_VISUALIZATION">
	\brief Enable debug renderer for this body

	@see NxScene.getDebugRenderable() NxDebugRenderable NxParameter

</member>
        <member name="F:NX_BF_KINEMATIC">
	\brief Enables kinematic mode for the actor.
	
	Kinematic actors are special dynamic actors that are not 
	influenced by forces (such as gravity), and have no momentum. They are considered to have infinite
	mass and can be moved around the world using the moveGlobal*() methods. They will push 
	regular dynamic actors out of the way. Kinematics will not collide with static or other kinematic objects.
	
	Kinematic actors are great for moving platforms or characters, where direct motion control is desired.

	You can not connect Reduced joints to kinematic actors. Lagrange joints work ok if the platform
	is moving with a relatively low, uniform velocity.

	@see NxActor NxActor.raiseActorFlag()

</member>
        <member name="F:NX_BF_FROZEN_POS_X">
	\brief Enable/disable freezing for this body/actor. 

	\note This is an EXPERIMENTAL feature which doesn't always work on in all situations, e.g. 
	for actors which have joints connected to them.
	
	To freeze an actor is a way to simulate that it is static. The actor is however still simulated
	as if it was dynamic, it's position is just restored after the simulation has finished. A much
	more stable way to make an actor temporarily static is to raise the NX_BF_KINEMATIC flag.

</member>
        <member name="F:NX_BF_DISABLE_GRAVITY">
	\brief Set if gravity should not be applied on this body

	@see NxBodyDesc.flags NxScene.setGravity()

</member>
        <member name="T:NxForceMode">
\brief Parameter to addForce*() calls, determines the exact operation that is carried out.

@see NxActor.addForce() NxActor.addTorque()

</member>
        <member name="F:NX_SWEPT_SHAPE">
	\brief If this flag is set, the capsule shape represents a moving sphere, 
	moving along the ray defined by the capsule's positive Y axis.

	Currently this behavior is only implemented for points (zero radius spheres).

	Note:Used only in conjunction with the old-style capsule based wheel shape (see
	the Guide for more information).

</member>
        <member name="T:NxMeshPagingMode">
\brief Lets the user specify how to handle mesh paging to the PhysX card.

It is always possible to manually upload mesh pages, also in the modes called "automatic".
Actually the "automatic" modes should preferrably be used in a half-automatic manner, 
having the automaticy as a fallback if there are pages missing.

Although it is possible to manually map pages, you can not override the automatic
page mapping by unmapping an automatically mapped page. The pages that are mapped
on the PhysX card have two reference counters; one for the user (manual mapping) and
one for the automatic mapping. Only when both references are removed is the page
removed.

</member>
        <member name="F:NX_MESH_PAGING_AUTO">
	\brief [Experimental] Automatic paging of missing mesh pages.

	This mode checks which mesh pages are needed for each interaction between a mesh shape and another shape.
	If the page is not available on the PhysX card, then it is uploaded. If it is not possible to upload the
	mesh page (e.g. because the PhysX card is out of memory), then the SW fallback (see NX_MESH_PAGING_FALLBACK)
	is used instead.
	\warning This mesh paging method is still an experimental feature

</member>
        <member name="F:NX_MESH_PAGING_FALLBACK">
	\brief [Experimental] An automatic fallback to SW collision testing when mesh pages are missing on the PhysX card.

	This mode uses SW collision methods when an interaction between a shape and a mesh shape is missing mesh pages.
	The kind of constraints that are generated are both slower to generate, and takes more time to simulate.

	\warning This mesh paging method is still an experimental feature

</member>
        <member name="F:NX_MESH_PAGING_MANUAL">
	\brief Manual mesh paging is the default, and it is up to the user to see to it that all
	needed mesh pages are available on the PhysX card when they are needed.

	This mode should be the default choice, as it lets the developer prepare for scene
	switches, by uploading new mesh data continously.

</member>
        <member name="F:NX_MESH_SMOOTH_SPHERE_COLLISIONS">
	\brief Select between "normal" or "smooth" sphere-mesh/raycastcapsule-mesh contact generation routines.

	The 'normal' algorithm assumes that the mesh is composed from flat triangles. 
	When a ball rolls or a raycast capsule slides along the mesh surface, it will experience small,
	sudden changes in velocity as it rolls from one triangle to the next. The smooth algorithm, on
	the other hand, assumes that the triangles are just an approximation of a surface that is smooth.  
	It uses the Gouraud algorithm to smooth the triangles' vertex normals (which in this 
	case are particularly important). This way the rolling sphere's/capsule's velocity will change
	smoothly over time, instead of suddenly. We recommend this algorithm for simulating car wheels
	on a terrain.

	@see NxSphereShape NxTriangleMeshShape NxHeightFieldShape

</member>
        <member name="T:NxShapeType">
\brief Identified a particular shape type.

@see NxShape NxShapeDesc

</member>
        <member name="F:NX_SHAPE_RAW_MESH">
	\brief internal use only!


</member>
        <member name="F:NX_SHAPE_HEIGHTFIELD">
\brief A physical height-field
@see NxHeightFieldShape NxHeightField

</member>
        <member name="F:NX_SHAPE_MESH">
\brief A physical mesh
@see NxTriangleMeshShape NxTriangleMesh

</member>
        <member name="F:NX_SHAPE_CONVEX">
\brief A physical convex mesh
@see NxConvexShape NxConvexMesh

</member>
        <member name="F:NX_SHAPE_WHEEL">
\brief A wheel for raycast cars
@see NxWheelShape

</member>
        <member name="F:NX_SHAPE_CAPSULE">
\brief A physical capsule (LSS)
@see NxCapsuleShape

</member>
        <member name="F:NX_SHAPE_BOX">
\brief A physical box (OBB)
@see NxBoxShape

</member>
        <member name="F:NX_SHAPE_SPHERE">
\brief A physical sphere
@see NxSphereShape

</member>
        <member name="F:NX_SHAPE_PLANE">
	\brief A physical plane
    @see NxPlaneShape

</member>
        <member name="D:NxActorGroup">
@} 
@} 
\addtogroup physics
  @{

\addtogroup physics
  @{

\addtogroup foundation
  @{

@} 
Pass the constant NX_PHYSICS_SDK_VERSION to the NxCreatePhysicsSDK function. 
This is to ensure that the application is using the same header version as the
library was built with.

</member>
        <member name="M:NxRemoteDebugger.unregisterEventListener(NxRemoteDebuggerEventListener*)">
	Unregisters an event listener.

	\param eventListener The event listener to unregister.

</member>
        <member name="M:NxRemoteDebugger.registerEventListener(NxRemoteDebuggerEventListener*)">
	Registers an event listener that will be notified of Visual Remote Debugger events (i.e. connect and disconnect events). 

	\param eventListener The event listener to register.

</member>
        <member name="M:NxRemoteDebugger.getPickPoint">
Returns the current picking point in the debugger

</member>
        <member name="M:NxRemoteDebugger.getPickedObject">
Returns the object that is currently picked by the debugger

</member>
        <member name="M:NxRemoteDebugger.getMask">
Returns the mask the Visual Remote Debugger stream is filtered with.

</member>
        <member name="M:NxRemoteDebugger.setMask(System.UInt32)">
Sets the mask which is used to filter out events from the Visual Remote Debugger stream.

</member>
        <member name="M:NxRemoteDebugger.writeParameter(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Boolean,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
	Write an object ID parameter to output stream.

	\param parameter The value to write.
	\param object The object to write a parameter to.
	\param create Must be true at parameter creation, and should be false for all consecutive writes of the same parameter for optimal stream size.
	\param name Name of the parameter.
	\param mask Event group mask that this event is contained in, e.g. NX_DBG_EVENTGROUP_JOINTS.

</member>
        <member name="M:NxRemoteDebugger.writeParameter(System.Boolean!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Void*,System.Boolean,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
	Write a boolean parameter to output stream.

	\param parameter The value to write.
	\param object The object to write a parameter to.
	\param create Must be true at parameter creation, and should be false for all consecutive writes of the same parameter for optimal stream size.
	\param name Name of the parameter.
	\param mask Event group mask that this event is contained in, e.g. NX_DBG_EVENTGROUP_JOINTS.

</member>
        <member name="M:NxRemoteDebugger.writeParameter(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Boolean,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
	Write a string parameter to output stream.

	\param parameter The value to write.
	\param object The object to write a parameter to.
	\param create Must be true at parameter creation, and should be false for all consecutive writes of the same parameter for optimal stream size.
	\param name Name of the parameter.
	\param mask Event group mask that this event is contained in, e.g. NX_DBG_EVENTGROUP_JOINTS.

</member>
        <member name="M:NxRemoteDebugger.writeParameter(System.Byte!System.Runtime.CompilerServices.IsConst*,System.Void*,System.Boolean,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
	Write an NxU32 parameter to output stream.

	\param parameter Pointer to a binary chunk of data to write. The first 4 bytes
	must be an NxU32 containing the data size, including those 4 size
	bytes. The data is assumed to be of the same endianness as the output
	stream.
	\param object The object to write a parameter to.
	\param create Must be true at parameter creation, and should be false for all consecutive writes of the same parameter for optimal stream size.
	\param name Name of the parameter.
	\param mask Event group mask that this event is contained in, e.g. NX_DBG_EVENTGROUP_JOINTS.

</member>
        <member name="M:NxRemoteDebugger.writeParameter(NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Void*,System.Boolean,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
	Write an NxMat33 parameter to output stream.

	\param parameter The value to write.
	\param object The object to write a parameter to.
	\param create Must be true at parameter creation, and should be false for all consecutive writes of the same parameter for optimal stream size.
	\param name Name of the parameter.
	\param mask Event group mask that this event is contained in, e.g. NX_DBG_EVENTGROUP_JOINTS.

</member>
        <member name="M:NxRemoteDebugger.writeParameter(NxMat34!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Void*,System.Boolean,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
	Write an NxMat34 parameter to output stream.

	\param parameter The value to write.
	\param object The object to write a parameter to.
	\param create Must be true at parameter creation, and should be false for all consecutive writes of the same parameter for optimal stream size.
	\param name Name of the parameter.
	\param mask Event group mask that this event is contained in, e.g. NX_DBG_EVENTGROUP_JOINTS.

</member>
        <member name="M:NxRemoteDebugger.writeParameter(NxPlane!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Void*,System.Boolean,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
	Write a Plane parameter to output stream.

	\param parameter The value to write.
	\param object The object to write a parameter to.
	\param create Must be true at parameter creation, and should be false for all consecutive writes of the same parameter for optimal stream size.
	\param name Name of the parameter.
	\param mask Event group mask that this event is contained in, e.g. NX_DBG_EVENTGROUP_JOINTS.

</member>
        <member name="M:NxRemoteDebugger.writeParameter(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Void*,System.Boolean,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
	Write a Vector parameter to output stream.

	\param parameter The value to write.
	\param object The object to write a parameter to.
	\param create Must be true at parameter creation, and should be false for all consecutive writes of the same parameter for optimal stream size.
	\param name Name of the parameter.
	\param mask Event group mask that this event is contained in, e.g. NX_DBG_EVENTGROUP_JOINTS.

</member>
        <member name="M:NxRemoteDebugger.writeParameter(System.UInt32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Void*,System.Boolean,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
	Write a NxU32 parameter to output stream.

	\param parameter The value to write.
	\param object The object to write a parameter to.
	\param create Must be true at parameter creation, and should be false for all consecutive writes of the same parameter for optimal stream size.
	\param name Name of the parameter.
	\param mask Event group mask that this event is contained in, e.g. NX_DBG_EVENTGROUP_JOINTS.

</member>
        <member name="M:NxRemoteDebugger.writeParameter(System.Single!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Void*,System.Boolean,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Write a real parameter to output stream.

\param parameter The value to write.
\param object The object to write a parameter to.
\param create Must be true at parameter creation, and should be false for all consecutive writes of the same parameter for optimal stream size.
\param name Name of the parameter.
\param mask Event group mask that this event is contained in, e.g. NX_DBG_EVENTGROUP_JOINTS.

</member>
        <member name="M:NxRemoteDebugger.removeChild(System.Void*,System.Void*,System.UInt32)">
	Remove a child object from another object.

	\param object Object identifier of the parent.
	\param child Object identifier of the child.
	\param mask Event group mask that this event is contained in, e.g. NX_DBG_EVENTGROUP_JOINTS.

</member>
        <member name="M:NxRemoteDebugger.addChild(System.Void*,System.Void*,System.UInt32)">
	Add an object as child to another object.

	\param object Object identifier of the parent.
	\param child Object identifier of the child.
	\param mask Event group mask that this event is contained in, e.g. NX_DBG_EVENTGROUP_JOINTS.

</member>
        <member name="M:NxRemoteDebugger.removeObject(System.Void*,System.UInt32)">
	Remove an object in the output stream.

	\param object Object identifier of the object to remove.
	\param mask Event group mask that this event is contained in, e.g. NX_DBG_EVENTGROUP_JOINTS.

</member>
        <member name="M:NxRemoteDebugger.createObject(System.Void*,NxRemoteDebuggerObjectType,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Create an object in the output stream.

\param object Object identifier, usually a pointer.
\param type Type of object to create.
\param className Class name of the object, e.g. "NxBox" or "PulseRifleBolt".
\param mask Event group mask that this event is contained in, e.g. NX_DBG_EVENTGROUP_JOINTS.

</member>
        <member name="M:NxRemoteDebugger.frameBreak">
Write a frame break to the output stream.

</member>
        <member name="M:NxRemoteDebugger.isConnected">
Returns whether the debugger is connected or not.

</member>
        <member name="M:NxRemoteDebugger.flush">
Flushes the output stream, i.e. forces it to write/send any queued data.

</member>
        <member name="M:NxRemoteDebugger.disconnect">
Disconnects the SDK from the Visual Remote Debugger application.

</member>
        <member name="M:NxRemoteDebugger.connect(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.UInt32)">
	Connects the SDK to the Visual Remote Debugger application

	\param host The host name of the computer running the VRD, e.g. "localhost".
	\param port The port that the VRD is listening to.
	\param eventMask 32 bit mask used to filter information sent to the debugger, constructed from NX_DBG_EVENTMASK_X macros.

</member>
        <member name="T:NxRemoteDebugger">
\brief Singleton class used to communicate with the Visual Remote Debugger. 
Generally this class is only accessed through the NX_DBG_X macros.

</member>
        <member name="M:NxRemoteDebuggerEventListener.afterMaskChange(System.UInt32,System.UInt32)">
This is called right after the event mask is changed.

</member>
        <member name="M:NxRemoteDebuggerEventListener.beforeMaskChange(System.UInt32,System.UInt32)">
This is called right before the event mask is changed.

</member>
        <member name="M:NxRemoteDebuggerEventListener.onDisconnect">
This is called right before the SDK is disconnected from the Visual Remote Debugger application.

</member>
        <member name="M:NxRemoteDebuggerEventListener.onConnect">
This is called right after the SDK is connected to the Visual Remote Debugger application.

</member>
        <member name="T:NxRemoteDebuggerEventListener">
An event listener that can be registered to listen to Visual Remote Debugger events.

</member>
        <member name="T:NxRemoteDebuggerObjectType">
@} 
\addtogroup foundation
@{

</member>
        <member name="M:NxComputeBarycentricPoint(NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,System.Single)">
	\brief Computes a point on a triangle using barycentric coordinates. 
	
	It's only been extracted as a function so that there's no confusion regarding the order in 
	which u and v should be used.

	pt = (1 - u - v) * p0 + u * p1 + v * p2

	\param pt Contains the computed point.
	\param p0 First point of triangle.
	\param p1 Second.
	\param p2 Third.
	\param u U parameter.
	\param v V parameter.

</member>
        <member name="M:NxDecomposeVector(NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">

	\param normalCompo
	\param tangentCompo
	\param outwardDir
	\param outwardNormal

</member>
        <member name="M:NxComputeTangentCompo(NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">

	\param outwardDir
	\param outwardNormal

</member>
        <member name="M:NxComputeNormalCompo(NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">

	\param normalCompo
	\param outwardDir
	\param outwardNormal

</member>
        <member name="M:NxMakeFatEdge(NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
	\brief Make an edge longer by a factor of its length.

	\param p0 First point of edge.
	\param p1 Second point of edge.
	\param fatCoeff Factor by which to make fatter by.

</member>
        <member name="M:NxAngle(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Returns the angle between two (possibly un-normalized) vectors 
\param v0 First Vector.
\param v1 Second Vector.

</member>
        <member name="M:NxFlexiCopy(System.Void!System.Runtime.CompilerServices.IsConst*,System.Void*,System.UInt32,System.UInt32,System.UInt32)">
@} 
\addtogroup foundation
  @{

 \brief Utility calls that don't fit anywhere else.

 Gathers elements seperated by stride byes into source.

 \param src Source memory block.
 \param dst Destination memory block.
 \param nbElem Number of elements to copy.
 \param elemSize Size of each element.
 \param stride Number of bytes from one element to the next.

</member>
        <member name="M:NxSimpleTriangleMesh.isValid">
\brief returns true if the current settings are valid

</member>
        <member name="M:NxSimpleTriangleMesh.setToDefault">
\brief (re)sets the structure to the default.	

</member>
        <member name="M:NxSimpleTriangleMesh.#ctor">
\brief constructor sets to default.

</member>
        <member name="F:NxSimpleTriangleMesh.flags">
\brief Flags bits, combined from values of the enum ::NxMeshFlags

</member>
        <member name="F:NxSimpleTriangleMesh.triangles">
	\brief Pointer to first triangle.
	
	Caller may add triangleStrideBytes bytes to the pointer to access the next triangle.
	
	These are triplets of 0 based indices:
	vert0 vert1 vert2
	vert0 vert1 vert2
	vert0 vert1 vert2
	...

	where vertex is either a 32 or 16 bit unsigned integer. There are numTriangles*3 indices.

	This is declared as a void pointer because it is actually either an NxU16 or a NxU32 pointer.

</member>
        <member name="F:NxSimpleTriangleMesh.points">
\brief Pointer to first vertex point.

Caller may add pointStrideBytes bytes to the pointer to access the next point.

</member>
        <member name="T:NxSimpleTriangleMesh">
\brief A structure describing a triangle mesh.


@} 
\addtogroup physics
  @{

</member>
        <member name="T:NxMeshFlags">
@} 
\addtogroup foundation
  @{

\brief Enum with flag values to be used in NxSimpleTriangleMesh::flags.

</member>
        <member name="F:NX_MF_FLIPNORMALS">
	\brief Specifies if the SDK should flip normals.

	The Nx libraries assume that the face normal of a triangle with vertices [a,b,c] can be computed as:
	edge1 = b-a
	edge2 = c-a
	face_normal = edge1 x edge2.

	Note: This is the same as a counterclockwise winding in a right handed coordinate system or
	alternatively a clockwise winding order in a left handed coordinate system.

	If this does not match the winding order for your triangles, raise the below flag.

</member>
        <member name="M:NxDebugRenderable.getTriangles">
\brief Retrieve an array of triangles to render.
\return Array of #NxDebugTriangle

</member>
        <member name="M:NxDebugRenderable.getNbTriangles">
\brief Retrieve the number of triangles to render.
\return Array of #NxDebugTriangle

</member>
        <member name="M:NxDebugRenderable.getLines">
\brief Retrieve an array of lines to render.
\return Array of #NxDebugLine

</member>
        <member name="M:NxDebugRenderable.getNbLines">
\brief Retrieve the number of lines to render.
\return Line Count.

</member>
        <member name="M:NxDebugRenderable.getPoints">
\brief Retrieve an array of points.
\return Array of #NxDebugPoint

</member>
        <member name="M:NxDebugRenderable.getNbPoints">
\brief Retrieve the number of points to render.
\return Point count.

</member>
        <member name="T:NxDebugRenderable">
\brief This class references buffers with points, lines, and triangles.  They represent visualizations
of SDK objects to help with debugging the user's code.  

The user should not have to instance this class.

<h3>Example</h3>

\include NxUserDebugRenderer_Example.cpp

</member>
        <member name="T:NxDebugTriangle">
\brief Used to store a single triangle and colour for debug rendering.

</member>
        <member name="T:NxDebugLine">
\brief Used to store a single line and colour for debug rendering.

</member>
        <member name="T:NxDebugPoint">
\brief Used to store a single point and colour for debug rendering.

</member>
        <member name="T:NxDebugColor">
@} 
\addtogroup foundation
  @{

\brief Default color values used for debug rendering.

</member>
        <member name="M:NxRay.Dispose">
Destructor

</member>
        <member name="M:NxRay.#ctor(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor

</member>
        <member name="M:NxRay.#ctor">
Constructor

</member>
        <member name="T:NxRay">
@} 
\addtogroup foundation
  @{


\brief Represents an infinite ray as an origin and direction.

The direction should be normalized.


@} 

@} 

@} 
\addtogroup physics
  @{


@} 
\addtogroup physics
  @{

</member>
        <member name="M:NxPlane.pointInPlane">
\brief find an arbitrary point in the plane

</member>
        <member name="M:NxPlane.project(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief projects p into the plane

</member>
        <member name="M:NxPlane.set(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Computes the plane equation from 3 points.

</member>
        <member name="M:NxPlane.zero">
\brief Sets plane to zero.

</member>
        <member name="M:NxPlane.Dispose">
\brief Destructor

</member>
        <member name="M:NxPlane.#ctor(NxPlane!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Copy constructor

</member>
        <member name="M:NxPlane.#ctor(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
\brief Constructor from a normal and a distance

</member>
        <member name="M:NxPlane.#ctor(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Constructor from three points

</member>
        <member name="M:NxPlane.#ctor(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Constructor from a point on the plane and a normal

</member>
        <member name="M:NxPlane.#ctor(System.Single,System.Single,System.Single,System.Single)">
\brief Constructor from a normal and a distance

</member>
        <member name="M:NxPlane.#ctor">
\brief Constructor

</member>
        <member name="T:NxPlane">
@} 
\addtogroup foundation
  @{

\brief Representation of a plane.

 Plane equation used: a*x + b*y + c*z + d = 0


@} 
\addtogroup physics
  @{

</member>
        <member name="M:NxCapsule.Dispose">
\brief Destructor

</member>
        <member name="M:NxCapsule.#ctor(NxSegment!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
\brief Constructor

\param seg Line segment to create capsule from.
\param _radius Radius of the capsule.

</member>
        <member name="M:NxCapsule.#ctor">
\brief Constructor

</member>
        <member name="M:NxSphere.Intersect(NxSphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Tests if the sphere intersects another sphere

	\param		sphere	[in] the other sphere
	\return		true if spheres overlap

</member>
        <member name="M:NxSphere.Contains(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Tests if a box is contained within the sphere.

	\param		min		[in] min value of the box
	\param		max		[in] max value of the box
	\return		true if inside the sphere

</member>
        <member name="M:NxSphere.Contains(NxSphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Tests if a sphere is contained within the sphere.

	\param		sphere	[in] the sphere to test
	\return		true if inside the sphere

</member>
        <member name="M:NxSphere.Contains(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Tests if a point is contained within the sphere.

	\param[in] p the point to test
	\return	true if inside the sphere

</member>
        <member name="M:NxSphere.IsValid">
	\brief Checks the sphere is valid.

	\return		true if the sphere is valid

</member>
        <member name="M:NxSphere.Dispose">
\brief Destructor

</member>
        <member name="M:NxSphere.#ctor(NxSphere!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Copy constructor

</member>
        <member name="M:NxSphere.#ctor(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
\brief Constructor

</member>
        <member name="M:NxSphere.#ctor">
\brief Constructor

</member>
        <member name="T:NxSphere">
\brief Represents a sphere defined by its center point and radius.

</member>
        <member name="T:NxBSphereMethod">
@} 
\addtogroup foundation
  @{

\brief Enum to control the sphere generation method from a set of points.

</member>
        <member name="M:NxSegment.computePoint(NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
	\brief Computes a point on the segment

	\param[out] pt point on segment
	\param[in] t point's parameter [t=0 =&gt; pt = mP0, t=1 =&gt; pt = mP1]

</member>
        <member name="M:NxSegment.Dispose">
\brief Destructor

</member>
        <member name="M:NxSegment.#ctor(NxSegment!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Copy constructor

</member>
        <member name="M:NxSegment.#ctor(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Constructor

</member>
        <member name="M:NxSegment.#ctor">
\brief Constructor

</member>
        <member name="T:NxSegment">
@} 
\addtogroup foundation
  @{

\addtogroup foundation
  @{


\brief Represents a line segment.


</member>
        <member name="M:NxBox.GetRot">
		\brief return box rotation.

		\return Box Rotation.

</member>
        <member name="M:NxBox.GetExtents">
		\brief Return extents(radii) of box.

		\return Extents of box.

</member>
        <member name="M:NxBox.GetCenter">
		\brief Return center of box.

		\return Center of box.

</member>
        <member name="M:NxBox.isValid">
	 \brief Checks the box is valid.

	 \return	true if the box is valid

</member>
        <member name="M:NxBox.rotate(NxMat34!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxBox*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	 \brief Recomputes the box after an arbitrary transform by a 4x4 matrix.

	 \param		mtx		[in] the transform matrix
	 \param		obb		[out] the transformed OBB

</member>
        <member name="M:NxBox.setEmpty">
\brief Setups an empty box.

</member>
        <member name="M:NxBox.Dispose">
\brief Destructor

</member>
        <member name="M:NxBox.#ctor(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Constructor

	\param _center Center of the OBB
	\param _extents Extents/radii of the obb.
	\param _rot rotation to apply to the obb.

</member>
        <member name="M:NxBox.#ctor">
\brief Constructor

</member>
        <member name="T:NxBox">
\brief Represents an oriented bounding box. 

As a center point, extents(radii) and a rotation. i.e. the center of the box is at the center point, 
the box is rotated around this point with the rotation and it is 2*extents in width, height and depth.


@} 
\addtogroup physics
  @{

</member>
        <member name="T:NxCapsule">
@} 

@} 

\brief Represents a capsule.

</member>
        <member name="M:NxMat34.getRowMajor44(System.Single(*)[N4])">
\brief retrieve the matrix in a row major format.

</member>
        <member name="M:NxMat34.getRowMajor44(System.Single*)">
\brief retrieve the matrix in a row major format.

</member>
        <member name="M:NxMat34.setRowMajor44(System.Single!System.Runtime.CompilerServices.IsConst(*)[N4])">
\brief set the matrix given a row major matrix.

</member>
        <member name="M:NxMat34.setRowMajor44(System.Single!System.Runtime.CompilerServices.IsConst*)">
\brief set the matrix given a row major matrix.

</member>
        <member name="M:NxMat34.getColumnMajor44(System.Single(*)[N4])">
\brief convert to a matrix format appropriate for rendering

</member>
        <member name="M:NxMat34.getColumnMajor44(System.Single*)">
\brief convert to a matrix format appropriate for rendering

</member>
        <member name="M:NxMat34.setColumnMajor44(System.Single!System.Runtime.CompilerServices.IsConst(*)[N4])">
\brief convert from a matrix format appropriate for rendering

</member>
        <member name="M:NxMat34.setColumnMajor44(System.Single!System.Runtime.CompilerServices.IsConst*)">
\brief convert from a matrix format appropriate for rendering

</member>
        <member name="M:NxMat34.op_Multiply(NxMat34!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief operator wrapper for multiply

</member>
        <member name="M:NxMat34.multiplyInverseRTRight(NxMat34!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat34!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief this = left * inverse(right)	-- assumes M is rotation matrix!!!

</member>
        <member name="M:NxMat34.multiplyInverseRTLeft(NxMat34!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat34!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief this = inverse(left) * right	-- assumes M is rotation matrix!!!

</member>
        <member name="M:NxMat34.multiply(NxMat34!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat34!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief this = left * right	

</member>
        <member name="M:NxMat34.op_Modulus(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief operator wrapper for multiplyByInverseRT

</member>
        <member name="M:NxMat34.multiplyByInverseRT(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief dst = inverse(this) * src	-- assumes M is rotation matrix!!!

</member>
        <member name="M:NxMat34.op_Multiply(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief operator wrapper for multiply

</member>
        <member name="M:NxMat34.multiply(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief dst = this * src

</member>
        <member name="M:NxMat34.getInverseRT(NxMat34*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief same as #getInverse(), but assumes that M is orthonormal

</member>
        <member name="M:NxMat34.getInverse(NxMat34*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief assigns inverse to dest. 

Returns false if singular (i.e. if no inverse exists), setting dest to identity.  dest may equal this.

</member>
        <member name="M:NxMat34.isFinite">
\brief returns true if all elems are finite (not NAN or INF, etc.)

</member>
        <member name="M:NxMat34.isIdentity">
\brief returns true for identity matrix

</member>
        <member name="M:NxMat34.#ctor(System.Boolean)">
\brief by default M is inited and t isn't.  Use this ctor to either init or not init in full.

</member>
        <member name="F:NxMat34.M">
\brief [ M t ]

</member>
        <member name="T:NxMat34">
\addtogroup foundation
  @{

\addtogroup foundation
  @{

\brief Combination of a 3x3 rotation matrix and a translation vector.

homogenous transform class composed of a matrix and a vector.

</member>
        <member name="M:NxBounds3.fatten(System.Single)">
fattens the AABB in all 3 dimensions by the given distance. 

</member>
        <member name="M:NxBounds3.scale(System.Single)">
	\brief scales the AABB.

	\param scale Factor to scale AABB by.

</member>
        <member name="M:NxBounds3.getExtents(NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief returns the extents, which are half of the width/height/depth.

	\param extents The extents/radii of the bounds.

</member>
        <member name="M:NxBounds3.getDimensions(NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief returns the dimensions (width/height/depth) of this axis aligned box.

	\param dims The dimensions of the bounds.

</member>
        <member name="M:NxBounds3.getCenter(NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief returns the center of this axis aligned box.

	\param center The center of the bounds.

</member>
        <member name="M:NxBounds3.contain(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief indicates if these bounds contain v.

	\param v Point to test against bounds.

</member>
        <member name="M:NxBounds3.intersects2D(NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
	\brief indicates whether the intersection of this and b is empty or not in the plane orthogonal to the axis passed (X = 0, Y = 1 or Z = 2).

	\param b Bounds to test for intersection.
	\param axisToIgnore Axis to ignore when performing the intersection test.

</member>
        <member name="M:NxBounds3.intersects(NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief indicates whether the intersection of this and b is empty or not.

	\param b Bounds to test for intersection.

</member>
        <member name="M:NxBounds3.transform(NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief transforms this volume as if it was an axis aligned bounding box, and then assigns the results' bounds to this.

	\param orientation Orientation to apply.
	\param translation Translation to apply(applied after orientation transform)

</member>
        <member name="M:NxBounds3.boundsOfOBB(NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief sets this to the AABB of the OBB passed.

	\param orientation Orientation of the OBB.
	\param translation Translation of the OBB.
	\param halfDims radii of the OBB.

</member>
        <member name="M:NxBounds3.combine(NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief sets this to the union of this and b2.

	\param b2 Bounds to perform union with.

</member>
        <member name="M:NxBounds3.include(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief expands the volume to include v

	\param v Point to expand to.

</member>
        <member name="M:NxBounds3.set(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief vector assignment.

	\param min Minimum point of bounds.
	\param max Maximum point of bounds.

</member>
        <member name="M:NxBounds3.set(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
	\brief low level assignment.

	\param minx Minimum X value
	\param miny Minimum Y value
	\param minz Minimum Z value
	\param maxx Maximum X value
	\param maxy Maximum Y value
	\param maxz Maximum Z value

</member>
        <member name="M:NxBounds3.setInfinite">
\brief Sets infinite bounds

</member>
        <member name="M:NxBounds3.setEmpty">
\brief Sets empty to true

</member>
        <member name="M:NxMat33.op_Multiply(System.Single)">
\brief matrix scalar product

</member>
        <member name="M:NxMat33.op_Multiply(NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief matrix product

</member>
        <member name="M:NxMat33.op_Addition(NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief matrix addition

</member>
        <member name="M:NxMat33.op_Subtraction(NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief matrix difference

</member>
        <member name="M:NxMat33.op_MultiplicationAssignment(NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief matrix product

</member>
        <member name="M:NxMat33.op_Multiply(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief matrix vector product

</member>
        <member name="M:NxMat33.op_Modulus(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief returns transpose(this)*src

</member>
        <member name="M:NxMat33.rotZ(System.Single)">
	\brief this = rotation matrix around Z axis

	<b>Unit:</b> Radians

</member>
        <member name="M:NxMat33.rotY(System.Single)">
	\brief this = rotation matrix around Y axis

	<b>Unit:</b> Radians

</member>
        <member name="M:NxMat33.rotX(System.Single)">
	\brief this = rotation matrix around X axis

	<b>Unit:</b> Radians

</member>
        <member name="M:NxMat33.multiplyTransposeRight(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief this = left * transpose(right)

</member>
        <member name="M:NxMat33.multiplyTransposeRight(NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief this = left * transpose(right)

\note faster than #multiplyByTranspose().

</member>
        <member name="M:NxMat33.multiplyTransposeLeft(NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief this = transpose(left) * right

	\note #multiplyByTranspose() is faster.

</member>
        <member name="M:NxMat33.multiply(NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief this = left * right

</member>
        <member name="M:NxMat33.multiply(System.Single,NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief this = s * a;

</member>
        <member name="M:NxMat33.add(NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief this = a + b

</member>
        <member name="M:NxMat33.multiplyByTranspose(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief dst = transpose(this) * src

</member>
        <member name="M:NxMat33.multiply(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief dst = this * src

</member>
        <member name="M:NxMat33.multiplyDiagonalTranspose(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat33*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief dst = transpose(this) * [ d.x 0 0; 0 d.y 0; 0 0 d.z];

</member>
        <member name="M:NxMat33.multiplyDiagonal(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxMat33*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief dst = this * [ d.x 0 0; 0 d.y 0; 0 0 d.z];

</member>
        <member name="M:NxMat33.multiplyDiagonalTranspose(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief this = transpose(this) * [ d.x 0 0; 0 d.y 0; 0 0 d.z];

</member>
        <member name="M:NxMat33.multiplyDiagonal(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief this = this * [ d.x 0 0; 0 d.y 0; 0 0 d.z];

</member>
        <member name="M:NxMat33.setTransposed">
\brief this = transpose(this)

</member>
        <member name="M:NxMat33.setTransposed(NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief this = transpose(other)

	this == other is OK.

</member>
        <member name="M:NxMat33.getInverse(NxMat33*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief assigns inverse to dest.

Returns false if singular (i.e. if no inverse exists), setting dest to identity.

</member>
        <member name="M:NxMat33.determinant">
\brief returns determinant

</member>
        <member name="M:NxMat33.star(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Sets this matrix to the Star(Skew Symetric) matrix.

	So that star(v) * x = v.cross(x) .

</member>
        <member name="M:NxMat33.diagonal(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief sets this matrix to the diagonal matrix.

</member>
        <member name="M:NxMat33.setNegative">
\brief this = -this

</member>
        <member name="M:NxMat33.id">
\brief sets this matrix to the identity matrix.

</member>
        <member name="M:NxMat33.zero">
\brief sets this matrix to the zero matrix.

</member>
        <member name="M:NxMat33.isFinite">
\brief returns true if all elems are finite (not NAN or INF, etc.)

</member>
        <member name="M:NxMat33.isZero">
\brief returns true for zero matrix

</member>
        <member name="M:NxMat33.isIdentity">
\brief returns true for identity matrix

</member>
        <member name="M:NxMat33.#ctor(NxMatrixType)">
	\param type Special matrix type to initialize with.

	@see NxMatrixType

</member>
        <member name="D:Mat33DataType">
\endcond 
@} 
</member>
        <member name="T:Nx9Real">
\addtogroup foundation
  @{

\cond 
</member>
        <member name="T:NxMatrixType">
@} 
\brief Identifies a special matrix. Can be passed to the #NxMat33 constructor.

</member>
        <member name="F:NX_IDENTITY_MATRIX">
\brief Identity matrix.

</member>
        <member name="F:NX_ZERO_MATRIX">
\brief Matrix of all zeros.

</member>
        <member name="M:NxQuat.op_LogicalNot">
quaternion conjugate 
</member>
        <member name="M:NxQuat.op_Subtraction(NxQuat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
quaternion subtraction 
</member>
        <member name="M:NxQuat.op_Addition(NxQuat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
quaternion addition 
</member>
        <member name="M:NxQuat.op_Multiply(NxQuat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
quaternion multiplication 
</member>
        <member name="F:NxQuat.x">
the quaternion elements 
</member>
        <member name="M:NxQuat.negate">
negates all the elements of the quat.  q and -q represent the same rotation.

</member>
        <member name="M:NxQuat.inverseRotate(NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
rotates passed vec by opposite of rot expressed by unit quaternion.  overwrites arg with the result.

</member>
        <member name="M:NxQuat.invTransform(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
inverse rotates passed vec by this (assumed unitary)

</member>
        <member name="M:NxQuat.transform(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
transform passed vec by this rotation (assumed unitary) and translation p

</member>
        <member name="M:NxQuat.invRot(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
inverse rotates passed vec by this (assumed unitary)

</member>
        <member name="M:NxQuat.rot(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
rotates passed vec by this (assumed unitary)

</member>
        <member name="M:NxQuat.rotate(NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
rotates passed vec by rot expressed by unit quaternion.  overwrites arg with the result.

</member>
        <member name="M:NxQuat.slerp(System.Single!System.Runtime.CompilerServices.IsConst,NxQuat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxQuat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
this = slerp(t, a, b)

</member>
        <member name="M:NxQuat.multiply(NxQuat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
this = a * v
v is interpreted as quat [xyz0]

</member>
        <member name="M:NxQuat.multiply(NxQuat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxQuat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
this = a * b

</member>
        <member name="M:NxQuat.normalize">
\brief maps to the closest unit quaternion.

</member>
        <member name="M:NxQuat.dot(NxQuat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief returns the scalar product of this and other.

</member>
        <member name="M:NxQuat.magnitudeSquared">
\brief This is the squared 4D vector length, should be 1 for unit quaternions.

</member>
        <member name="M:NxQuat.getAngle(NxQuat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Gets the angle between this quat and the argument

	<b>Unit:</b> Degrees

</member>
        <member name="M:NxQuat.getAngle">
	\brief Gets the angle between this quat and the identity quaternion.

	<b>Unit:</b> Degrees

</member>
        <member name="M:NxQuat.getAngleAxis(System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Fetches the Angle/axis given by the NxQuat.

	<b>Unit:</b> Degrees

</member>
        <member name="M:NxQuat.invert">
\brief Sets this to the opposite rotation of this.

</member>
        <member name="M:NxQuat.fromAngleAxisFast(System.Single,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Creates from angle-axis representation.

	Axis must be normalized!
	
	<b>Unit:</b> Radians

</member>
        <member name="M:NxQuat.fromAngleAxis(System.Single,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief creates from angle-axis representation.

	Note that if Angle &gt; 360 the resulting rotation is Angle mod 360.
	
	<b>Unit:</b> Degrees

</member>
        <member name="M:NxQuat.random">
\brief creates a random unit quaternion.

</member>
        <member name="M:NxQuat.zero">
\brief sets to the quat [0,0,0,1]

</member>
        <member name="M:NxQuat.isFinite">
\brief returns true if all elements are finite (not NAN or INF, etc.)

</member>
        <member name="M:NxQuat.op_Assign(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Implicitly extends vector by a 0 w element.

</member>
        <member name="M:NxQuat.setXYZW(System.Single!System.Runtime.CompilerServices.IsConst*)">
\brief Set the members of the quaternion, in order XYZW

</member>
        <member name="M:NxQuat.setWXYZ(System.Single!System.Runtime.CompilerServices.IsConst*)">
\brief Set the members of the quaternion, in order WXYZ

</member>
        <member name="M:NxQuat.setXYZW(System.Single,System.Single,System.Single,System.Single)">
\brief Set the members of the quaternion, in order XYZW

</member>
        <member name="M:NxQuat.setWXYZ(System.Single,System.Single,System.Single,System.Single)">
\brief Set the members of the quaternion, in order WXYZ

</member>
        <member name="M:NxQuat.isIdentityRotation">
\brief Test if the quaternion is the identity rotation.

</member>
        <member name="M:NxQuat.id">
\brief Set the quaternion to the identity rotation.

</member>
        <member name="M:NxQuat.#ctor(NxMat33!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Creates from orientation matrix.

	\param[in] m Rotation matrix to extract quaternion from.

</member>
        <member name="M:NxQuat.#ctor(System.Single!System.Runtime.CompilerServices.IsConst,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief creates from angle-axis representation.

	note that if Angle &gt; 360 the resulting rotation is Angle mod 360.
	
	<b>Unit:</b> Degrees

</member>
        <member name="M:NxQuat.#ctor(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
\brief copies xyz elements from v, and scalar from w (defaults to 0).

</member>
        <member name="M:NxQuat.#ctor(NxQuat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Copy constructor.

</member>
        <member name="M:NxQuat.#ctor">
\brief Default constructor, does not do any initialization.

</member>
        <member name="T:NxQuat">
@} 
\addtogroup foundation
  @{

\addtogroup foundation
  @{

\brief This is a quaternion class. For more information on quaternion mathematics
consult a mathematics source on complex numbers.
 

</member>
        <member name="M:op_Multiply(System.Single,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
scalar pre-multiplication

</member>
        <member name="M:_Nx3F32.op_Assign(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\cond Exclude from documentation 
</member>
        <member name="M:NxVec3.op_BitwiseOr(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief dot product

</member>
        <member name="M:NxVec3.op_ExclusiveOr(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief cross product

</member>
        <member name="M:NxVec3.cross(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief cross product

</member>
        <member name="M:NxVec3.op_DivisionAssignment(System.Single)">
\brief scalar division

</member>
        <member name="M:NxVec3.op_MultiplicationAssignment(System.Single)">
\brief scalar multiplication

</member>
        <member name="M:NxVec3.op_SubtractionAssignment(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief vector difference

</member>
        <member name="M:NxVec3.op_AdditionAssignment(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief vector addition

</member>
        <member name="M:NxVec3.op_Division(System.Single)">
\brief scalar division

</member>
        <member name="M:NxVec3.op_Multiply(System.Single)">
\brief scalar post-multiplication

</member>
        <member name="M:NxVec3.op_Subtraction(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief vector difference

</member>
        <member name="M:NxVec3.op_Addition(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief vector addition

</member>
        <member name="M:NxVec3.op_UnaryNegation">
\brief negation

</member>
        <member name="M:NxVec3.equals(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
\brief returns true if this and arg's elems are within epsilon of each other.

</member>
        <member name="M:NxVec3.isNotUsed">
\brief Checks the point is marked as not used

</member>
        <member name="M:NxVec3.setNotUsed">
\brief Stuff magic values in the point, marking it as explicitly not used.

</member>
        <member name="M:NxVec3.cross(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief this = left x right

</member>
        <member name="M:NxVec3.distanceSquared(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief returns (this - other).magnitudeSquared();

</member>
        <member name="M:NxVec3.distance(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief returns (this - other).magnitude();

</member>
        <member name="M:NxVec3.magnitudeSquared">
\brief returns the squared magnitude

Avoids calling sqrt()!

</member>
        <member name="M:NxVec3.magnitude">
\brief returns the magnitude

</member>
        <member name="M:NxVec3.sameDirection(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief compares orientations (more readable, user-friendly function)

</member>
        <member name="M:NxVec3.dot(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief returns the scalar product of this and other.

</member>
        <member name="M:NxVec3.isFinite">
\brief returns true if all 3 elems of the vector are finite (not NAN or INF, etc.)

</member>
        <member name="M:NxVec3.snapToClosestAxis">
\brief snaps to closest axis

</member>
        <member name="M:NxVec3.closestAxis">
\brief snaps to closest axis

</member>
        <member name="M:NxVec3.setMagnitude(System.Single)">
\brief sets the vector's magnitude

</member>
        <member name="M:NxVec3.normalize">
\brief normalizes the vector

</member>
        <member name="M:NxVec3.multiplyAdd(System.Single,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief this = s * a + b;

</member>
        <member name="M:NxVec3.arrayMultiply(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief this[i] = a[i] * b[i], for all i.

</member>
        <member name="M:NxVec3.multiply(System.Single,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief this = s * a;

</member>
        <member name="M:NxVec3.subtract(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief this = a - b

</member>
        <member name="M:NxVec3.add(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief this = a + b

</member>
        <member name="M:NxVec3.max(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief this = element wise max(this,other)

</member>
        <member name="M:NxVec3.min(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief this = element wise min(this,other)

</member>
        <member name="M:NxVec3.isZero">
\brief tests for exact zero vector

</member>
        <member name="M:NxVec3.set(System.Double!System.Runtime.CompilerServices.IsConst*)">
\brief reads 3 consecutive values from the ptr passed

</member>
        <member name="M:NxVec3.set(System.Single!System.Runtime.CompilerServices.IsConst*)">
\brief reads 3 consecutive values from the ptr passed

</member>
        <member name="M:NxVec3.setNegative">
\brief this = -this

</member>
        <member name="M:NxVec3.setNegative(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief this = -a

</member>
        <member name="M:NxVec3.op_Inequality(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief returns true if the two vectors are exactly unequal.

	use !equal() to test with a tolerance.

</member>
        <member name="M:NxVec3.op_Equality(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief returns true if the two vectors are exactly equal.

	use equal() to test with a tolerance.

</member>
        <member name="M:NxVec3.op_LessThan(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief true if all the members are smaller.

</member>
        <member name="M:NxVec3.get(System.Double*)">
\brief writes out the 3 values to dest.

</member>
        <member name="M:NxVec3.get(System.Single*)">
	\brief writes out the 3 values to dest.

	\param[out] dest Array to write elements to.

</member>
        <member name="M:NxVec3.get">
	\brief Access the data as an array.

	\return Array of 3 floats.


	\brief Access the data as an array.

	\return Array of 3 floats.

</member>
        <member name="M:NxVec3.op_Assign(_Nx3F32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Assignment operator.

</member>
        <member name="M:NxVec3.op_Assign(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Assignment operator.

</member>
        <member name="M:NxVec3.#ctor(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Copy constructor.

</member>
        <member name="M:NxVec3.#ctor(System.Single!System.Runtime.CompilerServices.IsConst*)">
	\brief Initializes from an array of scalar parameters.

	\param[in] v Value to initialize with.

</member>
        <member name="M:NxVec3.#ctor(_Nx3F32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
	\brief Initializes from Nx3F32 data type.

	\param[in] a Value to initialize with.

</member>
        <member name="M:NxVec3.#ctor(System.Single,System.Single,System.Single)">
	\brief Initializes from 3 scalar parameters.

	\param[in] nx Value to initialize X component.
	\param[in] ny Value to initialize Y component.
	\param[in] nz Value to initialize Z component.

</member>
        <member name="M:NxVec3.#ctor(System.Single)">
	\brief Assigns scalar parameter to all elements.
	
	Useful to initialize to zero or one.

	\param[in] a Value to assign to elements.


\endcond 
</member>
        <member name="M:NxVec3.#ctor">
\brief default constructor leaves data uninitialized.

</member>
        <member name="T:NxVec3">
\endcond 
\brief 3 Element vector class.

This is a vector class with public data members.
This is not nice but it has become such a standard that hiding the xyz data members
makes it difficult to reuse external code that assumes that these are public in the library.
The vector class can be made to use float or double precision by appropriately defining NxReal.
This has been chosen as a cleaner alternative to a template class.

</member>
        <member name="T:_Nx3F32">
\cond Exclude from documentation 
</member>
        <member name="T:NxAxisType">
\brief Enum to classify an axis.

</member>
        <member name="T:NxMat33">
@} 

\brief 3x3 Matrix Class.

 The idea of the matrix/vector classes is to partition them into two parts:
 One is the data structure which may have different formatting (3x3, 3x4, 4x4),
 row or column major.  The other is a template class which has all the operators
 but is storage format independent.

 This way it should be easier to change formats depending on what is faster/slower
 on a particular platform.

 Design issue: We use nameless struct/unions here.
 Design issue: this used to be implemented with a template.  This had no benefit
 but it added syntactic complexity.  Currently we just use a typedef and a preprocessor switch 
 to change between different memory layouts.

 The matrix math in this class is storage format (row/col major) independent as far
 as the user is concerned.
 When the user wants to get/set raw data, he needs to specify what order the data is
 coming in.  
 

</member>
        <member name="M:NxMath.isFinite(System.Double)">
\brief returns true if the passed number is a finite floating point number as opposed to INF, NAN, etc.

</member>
        <member name="M:NxMath.isFinite(System.Single)">
\brief returns true if the passed number is a finite floating point number as opposed to INF, NAN, etc.

</member>
        <member name="M:NxMath.hash32(System.Int32)">
\brief hash32

</member>
        <member name="M:NxMath.hash(System.UInt32!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
\brief hashing: hashes an array of n 32 bit values	to a 32 bit value.

Because the output bits are uniformly distributed, the caller may mask
off some of the bits to index into a hash table	smaller than 2^32.

</member>
        <member name="M:NxMath.rand(System.Int32,System.Int32)">
\brief uniform random number in [a,b]

</member>
        <member name="M:NxMath.rand(System.Single,System.Single)">
\brief uniform random number in [a,b]

</member>
        <member name="M:NxMath.atan2(System.Double,System.Double)">
		\brief Arctangent of (x/y) with correct sign.
		
		Returns angle between -PI and PI in radians

		<b>Unit:</b> Radians

</member>
        <member name="M:NxMath.atan2(System.Single,System.Single)">
		\brief Arctangent of (x/y) with correct sign.
		
		Returns angle between -PI and PI in radians

		<b>Unit:</b> Radians

</member>
        <member name="M:NxMath.atan(System.Double)">
		\brief ArcTangent.
		
		Returns angle between -PI/2 and PI/2 in radians

		<b>Unit:</b> Radians

</member>
        <member name="M:NxMath.atan(System.Single)">
		\brief ArcTangent.
		
		Returns angle between -PI/2 and PI/2 in radians

		<b>Unit:</b> Radians

</member>
        <member name="M:NxMath.acos(System.Double)">
		\brief Arccosine.
		
		Returns angle between 0 and PI in radians

		<b>Unit:</b> Radians

</member>
        <member name="M:NxMath.acos(System.Single)">
		\brief Arccosine.
		
		Returns angle between 0 and PI in radians

		<b>Unit:</b> Radians

</member>
        <member name="M:NxMath.asin(System.Double)">
		\brief Arcsine.
		
		Returns angle between -PI/2 and PI/2 in radians

		<b>Unit:</b> Radians

</member>
        <member name="M:NxMath.asin(System.Single)">
		\brief Arcsine.
		
		Returns angle between -PI/2 and PI/2 in radians

		<b>Unit:</b> Radians

</member>
        <member name="M:NxMath.tan(System.Double)">
		\brief Tangent of an angle.

		<b>Unit:</b> Radians

</member>
        <member name="M:NxMath.tan(System.Single)">
		\brief Tangent of an angle.

		<b>Unit:</b> Radians

</member>
        <member name="M:NxMath.sinCos(System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
		\brief Computes both the sin and cos.

		<b>Unit:</b> Radians

</member>
        <member name="M:NxMath.sinCos(System.Single,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
		\brief Computes both the sin and cos.

		<b>Unit:</b> Radians

</member>
        <member name="M:NxMath.cos(System.Double)">
		\brief Cosine of an angle.

		<b>Unit:</b> Radians

</member>
        <member name="M:NxMath.cos(System.Single)">
		\brief Cosine of an angle.

		<b>Unit:</b> Radians

</member>
        <member name="M:NxMath.sin(System.Double)">
		\brief Sine of an angle.

		<b>Unit:</b> Radians

</member>
        <member name="M:NxMath.sin(System.Single)">
		\brief Sine of an angle.

		<b>Unit:</b> Radians

</member>
        <member name="M:NxMath.radToDeg(System.Double)">
\brief Converts radians to degrees.

</member>
        <member name="M:NxMath.radToDeg(System.Single)">
\brief Converts radians to degrees.

</member>
        <member name="M:NxMath.degToRad(System.Double)">
\brief Converts degrees to radians.

</member>
        <member name="M:NxMath.degToRad(System.Single)">
\brief Converts degrees to radians.

</member>
        <member name="M:NxMath.log10(System.Double)">
\brief Calculates logarithms.

</member>
        <member name="M:NxMath.log10(System.Single)">
\brief Calculates logarithms.

</member>
        <member name="M:NxMath.log2(System.Double)">
\brief Calculates logarithms.

</member>
        <member name="M:NxMath.log2(System.Single)">
\brief Calculates logarithms.

</member>
        <member name="M:NxMath.logE(System.Double)">
\brief Calculates logarithms.

</member>
        <member name="M:NxMath.logE(System.Single)">
\brief Calculates logarithms.

</member>
        <member name="M:NxMath.exp(System.Double)">
\brief Calculates e^n

</member>
        <member name="M:NxMath.exp(System.Single)">
\brief Calculates e^n

</member>
        <member name="M:NxMath.pow(System.Double,System.Double)">
\brief Calculates x raised to the power of y.

</member>
        <member name="M:NxMath.pow(System.Single,System.Single)">
\brief Calculates x raised to the power of y.

</member>
        <member name="M:NxMath.recipSqrt(System.Double)">
\brief reciprocal square root.

</member>
        <member name="M:NxMath.recipSqrt(System.Single)">
\brief reciprocal square root.

</member>
        <member name="M:NxMath.sqrt(System.Double)">
\brief Square root.

</member>
        <member name="M:NxMath.sqrt(System.Single)">
\brief Square root.

</member>
        <member name="M:NxMath.clamp(System.Int32,System.Int32,System.Int32)">
\brief Clamps v to the range [hi,lo]

</member>
        <member name="M:NxMath.clamp(System.UInt32,System.UInt32,System.UInt32)">
\brief Clamps v to the range [hi,lo]

</member>
        <member name="M:NxMath.clamp(System.Double,System.Double,System.Double)">
\brief Clamps v to the range [hi,lo]

</member>
        <member name="M:NxMath.clamp(System.Single,System.Single,System.Single)">
\brief Clamps v to the range [hi,lo]

</member>
        <member name="M:NxMath.mod(System.Double,System.Double)">
\brief mod returns the floating-point remainder of x / y. 

If the value of y is 0.0, mod returns a quiet NaN.

</member>
        <member name="M:NxMath.mod(System.Single,System.Single)">
\brief mod returns the floating-point remainder of x / y. 

If the value of y is 0.0, mod returns a quiet NaN.

</member>
        <member name="M:NxMath.min(System.UInt16,System.UInt16)">
\brief The return value is the lesser of the two specified values. 

</member>
        <member name="M:NxMath.min(System.UInt32,System.UInt32)">
\brief The return value is the lesser of the two specified values. 

</member>
        <member name="M:NxMath.min(System.Int32,System.Int32)">
\brief The return value is the lesser of the two specified values. 

</member>
        <member name="M:NxMath.min(System.Double,System.Double)">
\brief The return value is the lesser of the two specified values. 

</member>
        <member name="M:NxMath.min(System.Single,System.Single)">
\brief The return value is the lesser of the two specified values. 

</member>
        <member name="M:NxMath.max(System.UInt16,System.UInt16)">
\brief The return value is the greater of the two specified values. 

</member>
        <member name="M:NxMath.max(System.UInt32,System.UInt32)">
\brief The return value is the greater of the two specified values. 

</member>
        <member name="M:NxMath.max(System.Int32,System.Int32)">
\brief The return value is the greater of the two specified values. 

</member>
        <member name="M:NxMath.max(System.Double,System.Double)">
\brief The return value is the greater of the two specified values. 

</member>
        <member name="M:NxMath.max(System.Single,System.Single)">
\brief The return value is the greater of the two specified values. 

</member>
        <member name="M:NxMath.sign(System.Int32)">
\brief sign returns the sign of its argument. The sign of zero is undefined.

</member>
        <member name="M:NxMath.sign(System.Double)">
\brief sign returns the sign of its argument. The sign of zero is undefined.

</member>
        <member name="M:NxMath.sign(System.Single)">
\brief sign returns the sign of its argument. The sign of zero is undefined.

</member>
        <member name="M:NxMath.abs(System.Int32)">
\brief abs returns the absolute value of its argument. 

</member>
        <member name="M:NxMath.abs(System.Double)">
\brief abs returns the absolute value of its argument. 

</member>
        <member name="M:NxMath.abs(System.Single)">
\brief abs returns the absolute value of its argument. 

</member>
        <member name="M:NxMath.trunc(System.Double)">
\brief Truncates the double precision float to an integer.

</member>
        <member name="M:NxMath.trunc(System.Single)">
\brief Truncates the float to an integer.

</member>
        <member name="M:NxMath.ceil(System.Double)">
\brief The ceil function returns a double value representing the smallest integer that is greater than or equal to x. 

</member>
        <member name="M:NxMath.ceil(System.Single)">
\brief The ceil function returns a single value representing the smallest integer that is greater than or equal to x. 

</member>
        <member name="M:NxMath.floor(System.Double)">
\brief The floor function returns a floating-point value representing the largest integer that is less than or equal to x.

</member>
        <member name="M:NxMath.floor(System.Single)">
\brief The floor function returns a floating-point value representing the largest integer that is less than or equal to x.

</member>
        <member name="M:NxMath.equals(System.Double,System.Double,System.Double)">
\brief Returns true if the two numbers are within eps of each other.

</member>
        <member name="M:NxMath.equals(System.Single,System.Single,System.Single)">
\brief Returns true if the two numbers are within eps of each other.

</member>
        <member name="T:NxMath">
\brief Static class with stateless scalar math routines.

</member>
        <member name="T:_exception">
@} 
\addtogroup foundation
  @{

\addtogroup foundation
  @{

\addtogroup foundation
  @{

</member>
        <member name="T:NxBitField.FlagRef">
\brief Refrences an individual flag.

</member>
        <member name="D:NxBitField.IntType">
this could be bool, but an integer type is more efficient.  In any case, Flag variables
should either be 1 or 0.

</member>
        <member name="T:NxBitField">
@} 
\addtogroup foundation
  @{

 \brief BitField class, for efficient storage of flags, and sub-byte width enums.

 Bits can hypothetically be changed by changing the integer type of the flags member var.
 Previously this used to be a template class but it was too painful to maintain for what is probably zero benefit.

</member>
        <member name="M:NxAllocatorDefault.check(System.Void*)">
Check a memory block is valid.

</member>
        <member name="M:NxAllocatorDefault.free(System.Void*)">
		Frees the memory previously allocated by malloc() or realloc().

		Compatible with the standard C free().

		\param memory Memory to free.

</member>
        <member name="M:NxAllocatorDefault.realloc(System.Void*,System.UInt32)">
		Resizes the memory block previously allocated with malloc() or
		realloc() to be size() bytes, and returns the possibly moved memory.

		Compatible with the standard C realloc().

		\param memory Memory block to change the size of.
		\param size New size for memory block.

</member>
        <member name="M:NxAllocatorDefault.mallocDEBUG(System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,NxMemoryType)">
		Allocates size bytes of memory.

		Same as above, but with extra debug info fields.

		\param size Number of bytes to allocate.
		\param fileName File which is allocating the memory.
		\param line Line which is allocating the memory.
		\param className Name of the class which is allocating the memory.
		\param type A hint about what the memory will be used for. See #NxMemoryType.

</member>
        <member name="M:NxAllocatorDefault.malloc(System.UInt32,NxMemoryType)">
		Allocates size bytes of memory.

		Compatible with the standard C malloc().

		\param size Number of bytes to allocate.
		\param type A hint about what the memory will be used for. See #NxMemoryType.

</member>
        <member name="T:NxAllocatorDefault">
The constant NX_FOUNDATION_SDK_VERSION is used when creating the NxFoundationSDK object, 
which is an internally created object. This is to ensure that the application is using 
the same header version as the library was built with.

@} 
\addtogroup foundation
  @{

\addtogroup foundation
  @{

\brief Default memory allocator using standard C malloc / free / realloc.

</member>
        <member name="M:NxFoundationSDK.setAllocaThreshold(System.UInt32)">
Sets the threshold for internal stack allocation. By default, stack allocations
are limited to half the default stack size for the platform or half the smallest
stack size of any thread created by the SDK. If called with threshold 0, this automatic
scheme is re-activated.

</member>
        <member name="M:NxFoundationSDK.getRemoteDebugger">
retrieves the current remote debugger.

</member>
        <member name="M:NxFoundationSDK.getAllocator">
retrieves the current allocator.

</member>
        <member name="M:NxFoundationSDK.getFirstError">
retrieves information about the first error that has occurred since the last call to
getLastError() or getFirstError(), and then	this error code to NXE_NO_ERROR.

</member>
        <member name="M:NxFoundationSDK.getLastError">
retrieves information about the last (most recent) error that has occurred, and then
resets both the last error code to NXE_NO_ERROR.

</member>
        <member name="M:NxFoundationSDK.getErrorStream">
retrieves error stream

</member>
        <member name="M:NxFoundationSDK.setErrorStream(NxUserOutputStream*)">
	Sets an error stream provided by the user.

	After an error stream has been set, human readable error messages 
	will be inserted into it.  

	\param stream Stream to report error on.

</member>
        <member name="M:NxFoundationSDK.release">
	Destroys the instance it is called on.

	Use this release method to destroy an instance of this class. Be sure
	to not keep a reference to this object after calling release.

	Note: the foundation SDK instance used by the SDK should not be manually released, 
	please use the NxReleasePhysicsSDK() function to release the SDK and foundation SDK.

</member>
        <member name="T:NxFoundationSDK">
\brief Foundation SDK singleton class.

You need to have an instance of this class to instance the higher level SDKs.

</member>
        <member name="D:NxReal">
@} 
\addtogroup foundation
  @{

\addtogroup foundation
  @{

</member>
        <member name="M:NxUserAllocator.checkDEBUG">
	\brief Verify heap.

	<b>Threading:</b> This function should be thread safe as it can be called in the context of the user thread 
	and physics processing thread(s).

</member>
        <member name="M:NxUserAllocator.free(System.Void*)">
	\brief Frees the memory previously allocated by malloc() or realloc().

	Compatible with the standard C free().

	<b>Threading:</b> This function should be thread safe as it can be called in the context of the user thread 
	and physics processing thread(s).

	\param memory Memory to free.

</member>
        <member name="M:NxUserAllocator.realloc(System.Void*,System.UInt32)">
	\brief Resizes the memory block previously allocated with malloc() or
	realloc() to be size() bytes, and returns the possibly moved memory.

	Compatible with the standard C realloc(), with the exception that
	it should never return NULL.  If you run out of memory, then
	you should terminate the app or take some other appropriate action.

	<b>Threading:</b> This function should be thread safe as it can be called in the context of the user thread 
	and physics processing thread(s).

	\param memory Memory block to change the size of.
	\param size New size for memory block.
	\return New pointer to the block of memory.

</member>
        <member name="M:NxUserAllocator.malloc(System.UInt32,NxMemoryType)">
	\brief Allocates size bytes of memory.

	Compatible with the standard C malloc(), with the exception that
	it should never return NULL.  If you run out of memory, then
	you should terminate the app or take some other appropriate action.

	<b>Threading:</b> This function should be thread safe as it can be called in the context of the user thread 
	and physics processing thread(s).

	\param size Number of bytes to allocate.
	\param type A hint about what the memory will be used for. See #NxMemoryType.
	\return The allocated block of memory.

</member>
        <member name="M:NxUserAllocator.malloc(System.UInt32)">
	\brief Allocates size bytes of memory.

	Compatible with the standard C malloc(), with the exception that
	it should never return NULL.  If you run out of memory, then
	you should terminate the app or take some other appropriate action.

	<b>Threading:</b> This function should be thread safe as it can be called in the context of the user thread 
	and physics processing thread(s).

	\param size Number of bytes to allocate.
	\return The allocated block of memory.

</member>
        <member name="M:NxUserAllocator.mallocDEBUG(System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,NxMemoryType)">
	\brief Allocates size bytes of memory.

	Same as simple #malloc below, but with extra debug info fields.

	<b>Threading:</b> This function should be thread safe as it can be called in the context of the user thread 
	and physics processing thread(s).

	\param size Number of bytes to allocate.
	\param fileName File which is allocating the memory.
	\param line Line which is allocating the memory.
	\param className Name of the class which is allocating the memory.
	\param type A hint about what the memory will be used for. See #NxMemoryType.
	\return The allocated block of memory.

</member>
        <member name="M:NxUserAllocator.mallocDEBUG(System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
	\brief Allocates size bytes of memory.

	Same as simple #malloc below, but with extra debug info fields.

	<b>Threading:</b> This function should be thread safe as it can be called in the context of the user thread 
	and physics processing thread(s).

	\param size Number of bytes to allocate.
	\param fileName File which is allocating the memory.
	\param line Line which is allocating the memory.
	\return The allocated block of memory.

</member>
        <member name="T:NxMemoryType">
\brief Enum tp identify memory allocations within the SDK.

</member>
        <member name="T:NxUserAllocator">
@} 
\addtogroup foundation
  @{


 \brief Abstract base class for an application defined memory allocator that can be used by the Nx library.

 \note The SDK state should not be modified from within any allocation/free function.

 <b>Threading:</b> All methods of this class should be thread safe as it can be called from the user thread or the physics processing thread(s).

 <h2>Example</h2>

 \include NxUserAllocator_Example.cpp


@} 
@} 
DLL export macros

</member>
        <member name="M:NxUserOutputStream.print(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
	\brief Simply prints some debug text

	\param message Message to display.

</member>
        <member name="M:NxUserOutputStream.reportAssertViolation(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
	\brief Reports an assertion violation.  The user should return 

	\param message Message to display.
	\param file File error occured in.
	\param line Line number error occured on.

</member>
        <member name="M:NxUserOutputStream.reportError(NxErrorCode,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
	\brief Reports an error code.

	\param code Error code, see #NxErrorCode
	\param message Message to display.
	\param file File error occured in.
	\param line Line number error occured on.

</member>
        <member name="T:NxUserOutputStream">
 \brief User defined interface class.  Used by the library to emit debug information.

 \note The SDK state should not be modified from within any error reporting functions.

 <b>Threading:</b> It is not necessary to make this class thread safe as it will only be called in the context of the
 user thread.


@} 
\addtogroup foundation
  @{

@} 
</member>
        <member name="T:NxAssertResponse">
@} 
\addtogroup foundation
  @{

</member>
        <member name="T:NxThreadPriority">
\brief Used to specify a thread priority.

</member>
        <member name="F:NX_TP_LOW">
\brief Low priority.

</member>
        <member name="F:NX_TP_BELOW_NORMAL">
\brief Below Normal priority

</member>
        <member name="F:NX_TP_NORMAL">
\brief Normal/default priority

</member>
        <member name="F:NX_TP_ABOVE_NORMAL">
\brief Above Normal priority

</member>
        <member name="F:NX_TP_HIGH">
\brief High priority

</member>
        <member name="T:_heapinfo">
@} 
\addtogroup foundation
  @{

This ANSI assert is included so that NX_ASSERTs can continue to appear in user side
code, where the custom assert in Assert.h would not work.

@} 
</member>
        <member name="D:NxI64">
\addtogroup foundation
  @{

</member>
        <member name="T:NxSDKCreateError">
\brief These errors are returned by the NxCreatePhysicsSDK() function

</member>
        <member name="F:NXCE_BUNDLE_ERROR">
\brief A PhysX card was found, but there are issues with loading the firmware.

</member>
        <member name="F:NXCE_IN_USE_ERROR">
\brief A PhysX card was found, but it is already in use by another application.

</member>
        <member name="F:NXCE_RESET_ERROR">
\brief A PhysX card was found, but it did not reset (or initialize) properly.

</member>
        <member name="F:NXCE_CONNECTION_ERROR">
\brief A PhysX card was found, but there are problems when communicating with the card.

</member>
        <member name="F:NXCE_DESCRIPTOR_INVALID">
\brief The supplied SDK descriptor is invalid.

</member>
        <member name="F:NXCE_WRONG_VERSION">
\brief The application supplied a version number that does not match with the libraries.

</member>
        <member name="F:NXCE_PHYSX_NOT_FOUND">
\brief Unable to find the PhysX libraries. The PhysX drivers are not installed correctly.

</member>
        <member name="F:NXCE_NO_ERROR">
\brief No errors occurred when creating the Physics SDK.

</member>
        <member name="T:NxErrorCode">
\brief Error codes

These error codes are passed to #NxUserOutputStream

@see NxUserOutputStream

</member>
        <member name="F:NXE_DB_PRINT">
	\brief the message should simply be printed without any additional infos (line number, etc).

	Only emitted when NX_USER_DEBUG_MODE is defined.

</member>
        <member name="F:NXE_DB_WARNING">
	\brief a warning message for the user to help with debugging

	Only emitted when NX_USER_DEBUG_MODE is defined.

</member>
        <member name="F:NXE_DB_INFO">
	\brief An informational message.

	Only emitted when NX_USER_DEBUG_MODE is defined.

</member>
        <member name="F:NXE_ASSERTION">
\brief an assertion failed.

</member>
        <member name="F:NXE_INTERNAL_ERROR">
\brief The library failed for some reason.

Usually because you have passed invalid values like NaNs into the system, which are not checked for.

</member>
        <member name="F:NXE_OUT_OF_MEMORY">
\brief method failed to allocate some memory

</member>
        <member name="F:NXE_INVALID_OPERATION">
\brief method was called at a time when an operation is not possible

</member>
        <member name="F:NXE_INVALID_PARAMETER">
\brief method called with invalid parameter(s)

</member>
        <member name="F:NXE_NO_ERROR">
\brief no error

</member>
        <member name="D:size_t">
\addtogroup physics
  @{

This is the main include header for the Physics SDK, for users who
want to use a single #include file.

Alternatively, one can instead directly #include a subset of the below files.

\addtogroup foundation
  @{

This is main user include of foundation SDK.  It includes the most often
used headers of the foundation SDK at once.  The user may also include
a subset of these separately instead.

\addtogroup foundation
  @{

DLL export macros

Nx SDK misc defines.

</member>
        <!-- Discarding badly formed XML document comment for member 'M:NxBitField.getField(System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxBounds3'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxBounds3.setCenterExtents(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxTriangleFlags'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_SKIN_WIDTH'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_DEFAULT_SLEEP_LIN_VEL_SQUARED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_DEFAULT_SLEEP_ANG_VEL_SQUARED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_BOUNCE_THRESHOLD'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_DYN_FRICT_SCALING'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_STA_FRICT_SCALING'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_MAX_ANGULAR_VELOCITY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_CONTINUOUS_CD'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_VISUALIZATION_SCALE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_VISUALIZE_COLLISION_VNORMALS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_VISUALIZE_COLLISION_FNORMALS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_ADAPTIVE_FORCE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_COLL_VETO_JOINTED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_TRIGGER_TRIGGER_CALLBACK'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_CCD_EPSILON'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_SOLVER_CONVERGENCE_THRESHOLD'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_BBOX_NOISE_LEVEL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_IMPLICIT_SWEEP_CACHE_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_DEFAULT_SLEEP_ENERGY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_CONSTANT_FLUID_MAX_PACKETS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_CONSTANT_FLUID_MAX_PARTICLES_PER_STEP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_FORCE_FIELD_CUSTOM_KERNEL_EPSILON'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_IMPROVED_SPRING_SOLVER'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSceneDesc.gravity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSceneDesc.maxTimestep'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSceneDesc.maxBounds'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSceneDesc.dynamicTreeRebuildRateHint'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxParticleUpdateData'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluidEmitter'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxFluidEmitterDesc.repulsionCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxFluidDescBase.fadeInTime'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxFluidDescBase.collisionResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluidDesc'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluid'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxFluid.addParticles(NxParticleData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxFluid.saveToDesc(NxFluidDescBase*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.thickness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.density'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.bendingStiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.stretchingStiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.dampingCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.friction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.pressure'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.tearFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.collisionResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.attachmentResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.attachmentTearFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.toFluidResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.fromFluidResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.wakeUpCounter'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.sleepLinearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.relativeGridSpacing'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxCloth.dominateVertex(System.UInt32,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.particleRadius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.density'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.volumeStiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.stretchingStiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.dampingCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.friction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.tearFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.collisionResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.attachmentResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.attachmentTearFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.toFluidResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.fromFluidResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.wakeUpCounter'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.sleepLinearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.relativeGridSpacing'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxScene.createForceFieldVariety'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxScene.setGroupCollisionFlag(System.UInt16,System.UInt16,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxScene.setDominanceGroupPair(System.UInt16,System.UInt16,NxConstraintDominance*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.massLocalPose'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.massSpaceInertia'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.mass'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.linearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.angularVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.wakeUpCounter'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.linearDamping'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.angularDamping'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.maxAngularVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.CCDMotionThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.sleepLinearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.sleepAngularVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.solverIterationCount'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.sleepEnergyThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.sleepDamping'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.contactReportThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxShapeDesc.localPose'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxShapeDesc.density'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxShapeDesc.mass'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxShapeDesc.skinWidth'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxActorDescBase.globalPose'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxActorDescBase.density'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxActorDesc'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringDesc.spring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringDesc.damper'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringDesc.targetValue'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.dynamicFriction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.staticFriction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.restitution'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.dynamicFrictionV'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.staticFrictionV'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.dirOfAnisotropy'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxMaterial.setStaticFriction(System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxContactStreamIterator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxContactStreamIterator.getFeatureIndex0'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxContactStreamIterator.getFeatureIndex1'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxContactStreamIterator.getPointNormalForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxContactStreamIterator.pointNormalForce'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluidEventType'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluidEmitterEventType'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxSpringAndDamperEffector.setLinearSpring(System.Single,System.Single,System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxSpringAndDamperEffector.setLinearDamper(System.Single,System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.pos1'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.pos2'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springDistCompressSaturate'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springDistRelaxed'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springDistStretchSaturate'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springMaxCompressForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springMaxStretchForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.damperVelCompressSaturate'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.damperVelStretchSaturate'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.damperMaxCompressForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.damperMaxStretchForce'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxForceField.samplePoints(System.UInt32,NxVec3!System.Runtime.CompilerServices.IsConst*,NxVec3!System.Runtime.CompilerServices.IsConst*,NxVec3*,NxVec3*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxCapsuleForceFieldShapeDesc.radius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxCapsuleForceFieldShapeDesc.height'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitDesc.value'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitDesc.restitution'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitDesc.hardness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitPairDesc.low'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitPairDesc.high'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMotorDesc.velTarget'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMotorDesc.maxForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.localNormal'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.localAxis'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.localAnchor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.maxForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.maxTorque'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.solverExtrapolationFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.useAccelerationSpring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.limit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.motor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.spring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.projectionDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.projectionAngle'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxRevoluteJoint.setLimits(NxJointLimitPairDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.swingAxis'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.projectionDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.twistLimit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.swingLimit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.twistSpring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.swingSpring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.jointSpring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxDistanceJointDesc.maxDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxDistanceJointDesc.minDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxDistanceJointDesc.spring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.pulley'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.distance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.stiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.ratio'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.motor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftDesc.value'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftDesc.restitution'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftDesc.spring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftDesc.damping'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftPairDesc.low'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftPairDesc.high'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.linearLimit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.swing1Limit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.swing2Limit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.twistLimit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.xDrive'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.swingDrive'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.slerpDrive'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.drivePosition'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.driveOrientation'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.driveLinearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.driveAngularVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.projectionDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.projectionAngle'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.gearRatio'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxCapsuleShapeDesc.radius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxCapsuleShapeDesc.height'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxPlaneShape'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPlaneShapeDesc.normal'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPlaneShapeDesc.d'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphereShapeDesc.radius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTriangleMeshDesc.heightFieldVerticalExtent'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTriangleMeshDesc.convexEdgeThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxTriangleMeshShape.overlapAABBTriangles(NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.nbRows'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.nbColumns'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.verticalExtent'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.thickness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.convexEdgeThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxHeightFieldShape.overlapAABBTriangles(NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxHeightFieldShape.getNormalAtShapePoint(System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxHeightFieldShape.getSmoothNormalAtShapePoint(System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldShapeDesc.heightScale'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldShapeDesc.rowScale'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldShapeDesc.columnScale'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxTireFunctionDesc'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.extremumSlip'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.extremumValue'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.asymptoteSlip'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.asymptoteValue'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.stiffnessFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxTireFunctionDesc.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.radius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.suspensionTravel'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.suspension'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.longitudalTireForceFunction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.lateralTireForceFunction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.inverseWheelMass'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.motorTorque'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.brakeTorque'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.steerAngle'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxWheelShape.setSuspension(NxSpringDesc)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxPlatformMismatch'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxCookingInterface.NxPlatformMismatch'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxBitField.getField(System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxBounds3'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxBounds3.setCenterExtents(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxTriangleFlags'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_SKIN_WIDTH'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_DEFAULT_SLEEP_LIN_VEL_SQUARED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_DEFAULT_SLEEP_ANG_VEL_SQUARED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_BOUNCE_THRESHOLD'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_DYN_FRICT_SCALING'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_STA_FRICT_SCALING'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_MAX_ANGULAR_VELOCITY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_CONTINUOUS_CD'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_VISUALIZATION_SCALE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_VISUALIZE_COLLISION_VNORMALS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_VISUALIZE_COLLISION_FNORMALS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_ADAPTIVE_FORCE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_COLL_VETO_JOINTED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_TRIGGER_TRIGGER_CALLBACK'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_CCD_EPSILON'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_SOLVER_CONVERGENCE_THRESHOLD'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_BBOX_NOISE_LEVEL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_IMPLICIT_SWEEP_CACHE_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_DEFAULT_SLEEP_ENERGY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_CONSTANT_FLUID_MAX_PACKETS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_CONSTANT_FLUID_MAX_PARTICLES_PER_STEP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_FORCE_FIELD_CUSTOM_KERNEL_EPSILON'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_IMPROVED_SPRING_SOLVER'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSceneDesc.gravity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSceneDesc.maxTimestep'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSceneDesc.maxBounds'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSceneDesc.dynamicTreeRebuildRateHint'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxParticleUpdateData'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluidEmitter'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxFluidEmitterDesc.repulsionCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxFluidDescBase.fadeInTime'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxFluidDescBase.collisionResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluidDesc'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluid'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxFluid.addParticles(NxParticleData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxFluid.saveToDesc(NxFluidDescBase*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.thickness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.density'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.bendingStiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.stretchingStiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.dampingCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.friction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.pressure'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.tearFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.collisionResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.attachmentResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.attachmentTearFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.toFluidResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.fromFluidResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.wakeUpCounter'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.sleepLinearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.relativeGridSpacing'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxCloth.dominateVertex(System.UInt32,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.particleRadius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.density'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.volumeStiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.stretchingStiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.dampingCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.friction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.tearFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.collisionResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.attachmentResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.attachmentTearFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.toFluidResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.fromFluidResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.wakeUpCounter'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.sleepLinearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.relativeGridSpacing'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxScene.createForceFieldVariety'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxScene.setGroupCollisionFlag(System.UInt16,System.UInt16,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxScene.setDominanceGroupPair(System.UInt16,System.UInt16,NxConstraintDominance*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.massLocalPose'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.massSpaceInertia'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.mass'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.linearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.angularVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.wakeUpCounter'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.linearDamping'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.angularDamping'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.maxAngularVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.CCDMotionThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.sleepLinearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.sleepAngularVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.solverIterationCount'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.sleepEnergyThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.sleepDamping'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.contactReportThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxShapeDesc.localPose'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxShapeDesc.density'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxShapeDesc.mass'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxShapeDesc.skinWidth'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxActorDescBase.globalPose'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxActorDescBase.density'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxActorDesc'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringDesc.spring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringDesc.damper'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringDesc.targetValue'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.dynamicFriction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.staticFriction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.restitution'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.dynamicFrictionV'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.staticFrictionV'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.dirOfAnisotropy'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxMaterial.setStaticFriction(System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxContactStreamIterator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxContactStreamIterator.getFeatureIndex0'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxContactStreamIterator.getFeatureIndex1'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxContactStreamIterator.getPointNormalForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxContactStreamIterator.pointNormalForce'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluidEventType'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluidEmitterEventType'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxSpringAndDamperEffector.setLinearSpring(System.Single,System.Single,System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxSpringAndDamperEffector.setLinearDamper(System.Single,System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.pos1'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.pos2'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springDistCompressSaturate'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springDistRelaxed'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springDistStretchSaturate'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springMaxCompressForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springMaxStretchForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.damperVelCompressSaturate'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.damperVelStretchSaturate'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.damperMaxCompressForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.damperMaxStretchForce'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxForceField.samplePoints(System.UInt32,NxVec3!System.Runtime.CompilerServices.IsConst*,NxVec3!System.Runtime.CompilerServices.IsConst*,NxVec3*,NxVec3*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxCapsuleForceFieldShapeDesc.radius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxCapsuleForceFieldShapeDesc.height'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitDesc.value'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitDesc.restitution'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitDesc.hardness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitPairDesc.low'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitPairDesc.high'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMotorDesc.velTarget'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMotorDesc.maxForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.localNormal'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.localAxis'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.localAnchor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.maxForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.maxTorque'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.solverExtrapolationFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.useAccelerationSpring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.limit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.motor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.spring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.projectionDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.projectionAngle'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxRevoluteJoint.setLimits(NxJointLimitPairDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.swingAxis'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.projectionDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.twistLimit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.swingLimit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.twistSpring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.swingSpring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.jointSpring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxDistanceJointDesc.maxDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxDistanceJointDesc.minDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxDistanceJointDesc.spring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.pulley'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.distance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.stiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.ratio'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.motor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftDesc.value'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftDesc.restitution'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftDesc.spring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftDesc.damping'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftPairDesc.low'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftPairDesc.high'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.linearLimit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.swing1Limit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.swing2Limit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.twistLimit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.xDrive'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.swingDrive'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.slerpDrive'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.drivePosition'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.driveOrientation'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.driveLinearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.driveAngularVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.projectionDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.projectionAngle'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.gearRatio'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxCapsuleShapeDesc.radius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxCapsuleShapeDesc.height'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxPlaneShape'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPlaneShapeDesc.normal'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPlaneShapeDesc.d'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphereShapeDesc.radius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTriangleMeshDesc.heightFieldVerticalExtent'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTriangleMeshDesc.convexEdgeThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxTriangleMeshShape.overlapAABBTriangles(NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.nbRows'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.nbColumns'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.verticalExtent'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.thickness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.convexEdgeThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxHeightFieldShape.overlapAABBTriangles(NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxHeightFieldShape.getNormalAtShapePoint(System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxHeightFieldShape.getSmoothNormalAtShapePoint(System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldShapeDesc.heightScale'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldShapeDesc.rowScale'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldShapeDesc.columnScale'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxTireFunctionDesc'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.extremumSlip'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.extremumValue'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.asymptoteSlip'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.asymptoteValue'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.stiffnessFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxTireFunctionDesc.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.radius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.suspensionTravel'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.suspension'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.longitudalTireForceFunction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.lateralTireForceFunction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.inverseWheelMass'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.motorTorque'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.brakeTorque'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.steerAngle'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxWheelShape.setSuspension(NxSpringDesc)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxPlatformMismatch'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxCookingInterface.NxPlatformMismatch'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxBitField.getField(System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxBounds3'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxBounds3.setCenterExtents(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxTriangleFlags'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_SKIN_WIDTH'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_DEFAULT_SLEEP_LIN_VEL_SQUARED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_DEFAULT_SLEEP_ANG_VEL_SQUARED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_BOUNCE_THRESHOLD'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_DYN_FRICT_SCALING'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_STA_FRICT_SCALING'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_MAX_ANGULAR_VELOCITY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_CONTINUOUS_CD'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_VISUALIZATION_SCALE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_VISUALIZE_COLLISION_VNORMALS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_VISUALIZE_COLLISION_FNORMALS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_ADAPTIVE_FORCE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_COLL_VETO_JOINTED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_TRIGGER_TRIGGER_CALLBACK'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_CCD_EPSILON'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_SOLVER_CONVERGENCE_THRESHOLD'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_BBOX_NOISE_LEVEL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_IMPLICIT_SWEEP_CACHE_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_DEFAULT_SLEEP_ENERGY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_CONSTANT_FLUID_MAX_PACKETS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_CONSTANT_FLUID_MAX_PARTICLES_PER_STEP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_FORCE_FIELD_CUSTOM_KERNEL_EPSILON'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_IMPROVED_SPRING_SOLVER'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSceneDesc.gravity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSceneDesc.maxTimestep'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSceneDesc.maxBounds'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSceneDesc.dynamicTreeRebuildRateHint'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxParticleUpdateData'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluidEmitter'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxFluidEmitterDesc.repulsionCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxFluidDescBase.fadeInTime'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxFluidDescBase.collisionResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluidDesc'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluid'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxFluid.addParticles(NxParticleData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxFluid.saveToDesc(NxFluidDescBase*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.thickness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.density'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.bendingStiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.stretchingStiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.dampingCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.friction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.pressure'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.tearFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.collisionResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.attachmentResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.attachmentTearFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.toFluidResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.fromFluidResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.wakeUpCounter'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.sleepLinearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.relativeGridSpacing'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxCloth.dominateVertex(System.UInt32,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.particleRadius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.density'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.volumeStiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.stretchingStiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.dampingCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.friction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.tearFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.collisionResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.attachmentResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.attachmentTearFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.toFluidResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.fromFluidResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.wakeUpCounter'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.sleepLinearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.relativeGridSpacing'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxScene.createForceFieldVariety'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxScene.setGroupCollisionFlag(System.UInt16,System.UInt16,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxScene.setDominanceGroupPair(System.UInt16,System.UInt16,NxConstraintDominance*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.massLocalPose'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.massSpaceInertia'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.mass'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.linearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.angularVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.wakeUpCounter'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.linearDamping'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.angularDamping'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.maxAngularVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.CCDMotionThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.sleepLinearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.sleepAngularVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.solverIterationCount'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.sleepEnergyThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.sleepDamping'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.contactReportThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxShapeDesc.localPose'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxShapeDesc.density'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxShapeDesc.mass'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxShapeDesc.skinWidth'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxActorDescBase.globalPose'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxActorDescBase.density'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxActorDesc'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringDesc.spring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringDesc.damper'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringDesc.targetValue'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.dynamicFriction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.staticFriction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.restitution'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.dynamicFrictionV'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.staticFrictionV'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.dirOfAnisotropy'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxMaterial.setStaticFriction(System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxContactStreamIterator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxContactStreamIterator.getFeatureIndex0'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxContactStreamIterator.getFeatureIndex1'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxContactStreamIterator.getPointNormalForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxContactStreamIterator.pointNormalForce'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluidEventType'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluidEmitterEventType'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxSpringAndDamperEffector.setLinearSpring(System.Single,System.Single,System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxSpringAndDamperEffector.setLinearDamper(System.Single,System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.pos1'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.pos2'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springDistCompressSaturate'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springDistRelaxed'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springDistStretchSaturate'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springMaxCompressForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springMaxStretchForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.damperVelCompressSaturate'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.damperVelStretchSaturate'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.damperMaxCompressForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.damperMaxStretchForce'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxForceField.samplePoints(System.UInt32,NxVec3!System.Runtime.CompilerServices.IsConst*,NxVec3!System.Runtime.CompilerServices.IsConst*,NxVec3*,NxVec3*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxCapsuleForceFieldShapeDesc.radius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxCapsuleForceFieldShapeDesc.height'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitDesc.value'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitDesc.restitution'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitDesc.hardness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitPairDesc.low'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitPairDesc.high'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMotorDesc.velTarget'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMotorDesc.maxForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.localNormal'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.localAxis'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.localAnchor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.maxForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.maxTorque'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.solverExtrapolationFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.useAccelerationSpring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.limit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.motor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.spring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.projectionDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.projectionAngle'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxRevoluteJoint.setLimits(NxJointLimitPairDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.swingAxis'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.projectionDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.twistLimit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.swingLimit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.twistSpring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.swingSpring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.jointSpring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxDistanceJointDesc.maxDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxDistanceJointDesc.minDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxDistanceJointDesc.spring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.pulley'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.distance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.stiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.ratio'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.motor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftDesc.value'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftDesc.restitution'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftDesc.spring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftDesc.damping'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftPairDesc.low'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftPairDesc.high'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.linearLimit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.swing1Limit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.swing2Limit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.twistLimit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.xDrive'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.swingDrive'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.slerpDrive'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.drivePosition'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.driveOrientation'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.driveLinearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.driveAngularVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.projectionDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.projectionAngle'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.gearRatio'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxCapsuleShapeDesc.radius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxCapsuleShapeDesc.height'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxPlaneShape'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPlaneShapeDesc.normal'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPlaneShapeDesc.d'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphereShapeDesc.radius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTriangleMeshDesc.heightFieldVerticalExtent'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTriangleMeshDesc.convexEdgeThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxTriangleMeshShape.overlapAABBTriangles(NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.nbRows'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.nbColumns'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.verticalExtent'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.thickness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.convexEdgeThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxHeightFieldShape.overlapAABBTriangles(NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxHeightFieldShape.getNormalAtShapePoint(System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxHeightFieldShape.getSmoothNormalAtShapePoint(System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldShapeDesc.heightScale'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldShapeDesc.rowScale'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldShapeDesc.columnScale'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxTireFunctionDesc'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.extremumSlip'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.extremumValue'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.asymptoteSlip'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.asymptoteValue'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.stiffnessFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxTireFunctionDesc.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.radius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.suspensionTravel'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.suspension'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.longitudalTireForceFunction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.lateralTireForceFunction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.inverseWheelMass'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.motorTorque'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.brakeTorque'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.steerAngle'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxWheelShape.setSuspension(NxSpringDesc)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxPlatformMismatch'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxCookingInterface.NxPlatformMismatch'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxBitField.getField(System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxBounds3'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxBounds3.setCenterExtents(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxTriangleFlags'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_SKIN_WIDTH'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_DEFAULT_SLEEP_LIN_VEL_SQUARED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_DEFAULT_SLEEP_ANG_VEL_SQUARED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_BOUNCE_THRESHOLD'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_DYN_FRICT_SCALING'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_STA_FRICT_SCALING'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_MAX_ANGULAR_VELOCITY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_CONTINUOUS_CD'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_VISUALIZATION_SCALE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_VISUALIZE_COLLISION_VNORMALS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_VISUALIZE_COLLISION_FNORMALS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_ADAPTIVE_FORCE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_COLL_VETO_JOINTED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_TRIGGER_TRIGGER_CALLBACK'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_CCD_EPSILON'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_SOLVER_CONVERGENCE_THRESHOLD'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_BBOX_NOISE_LEVEL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_IMPLICIT_SWEEP_CACHE_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_DEFAULT_SLEEP_ENERGY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_CONSTANT_FLUID_MAX_PACKETS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_CONSTANT_FLUID_MAX_PARTICLES_PER_STEP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_FORCE_FIELD_CUSTOM_KERNEL_EPSILON'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_IMPROVED_SPRING_SOLVER'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSceneDesc.gravity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSceneDesc.maxTimestep'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSceneDesc.maxBounds'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSceneDesc.dynamicTreeRebuildRateHint'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxParticleUpdateData'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluidEmitter'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxFluidEmitterDesc.repulsionCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxFluidDescBase.fadeInTime'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxFluidDescBase.collisionResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluidDesc'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluid'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxFluid.addParticles(NxParticleData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxFluid.saveToDesc(NxFluidDescBase*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.thickness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.density'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.bendingStiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.stretchingStiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.dampingCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.friction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.pressure'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.tearFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.collisionResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.attachmentResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.attachmentTearFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.toFluidResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.fromFluidResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.wakeUpCounter'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.sleepLinearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.relativeGridSpacing'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxCloth.dominateVertex(System.UInt32,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.particleRadius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.density'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.volumeStiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.stretchingStiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.dampingCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.friction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.tearFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.collisionResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.attachmentResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.attachmentTearFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.toFluidResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.fromFluidResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.wakeUpCounter'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.sleepLinearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.relativeGridSpacing'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxScene.createForceFieldVariety'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxScene.setGroupCollisionFlag(System.UInt16,System.UInt16,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxScene.setDominanceGroupPair(System.UInt16,System.UInt16,NxConstraintDominance*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.massLocalPose'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.massSpaceInertia'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.mass'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.linearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.angularVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.wakeUpCounter'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.linearDamping'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.angularDamping'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.maxAngularVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.CCDMotionThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.sleepLinearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.sleepAngularVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.solverIterationCount'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.sleepEnergyThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.sleepDamping'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.contactReportThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxShapeDesc.localPose'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxShapeDesc.density'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxShapeDesc.mass'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxShapeDesc.skinWidth'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxActorDescBase.globalPose'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxActorDescBase.density'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxActorDesc'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringDesc.spring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringDesc.damper'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringDesc.targetValue'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.dynamicFriction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.staticFriction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.restitution'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.dynamicFrictionV'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.staticFrictionV'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.dirOfAnisotropy'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxMaterial.setStaticFriction(System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxContactStreamIterator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxContactStreamIterator.getFeatureIndex0'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxContactStreamIterator.getFeatureIndex1'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxContactStreamIterator.getPointNormalForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxContactStreamIterator.pointNormalForce'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluidEventType'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluidEmitterEventType'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxSpringAndDamperEffector.setLinearSpring(System.Single,System.Single,System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxSpringAndDamperEffector.setLinearDamper(System.Single,System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.pos1'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.pos2'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springDistCompressSaturate'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springDistRelaxed'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springDistStretchSaturate'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springMaxCompressForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springMaxStretchForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.damperVelCompressSaturate'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.damperVelStretchSaturate'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.damperMaxCompressForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.damperMaxStretchForce'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxForceField.samplePoints(System.UInt32,NxVec3!System.Runtime.CompilerServices.IsConst*,NxVec3!System.Runtime.CompilerServices.IsConst*,NxVec3*,NxVec3*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxCapsuleForceFieldShapeDesc.radius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxCapsuleForceFieldShapeDesc.height'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitDesc.value'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitDesc.restitution'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitDesc.hardness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitPairDesc.low'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitPairDesc.high'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMotorDesc.velTarget'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMotorDesc.maxForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.localNormal'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.localAxis'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.localAnchor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.maxForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.maxTorque'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.solverExtrapolationFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.useAccelerationSpring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.limit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.motor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.spring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.projectionDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.projectionAngle'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxRevoluteJoint.setLimits(NxJointLimitPairDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.swingAxis'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.projectionDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.twistLimit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.swingLimit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.twistSpring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.swingSpring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.jointSpring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxDistanceJointDesc.maxDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxDistanceJointDesc.minDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxDistanceJointDesc.spring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.pulley'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.distance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.stiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.ratio'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.motor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftDesc.value'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftDesc.restitution'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftDesc.spring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftDesc.damping'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftPairDesc.low'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftPairDesc.high'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.linearLimit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.swing1Limit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.swing2Limit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.twistLimit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.xDrive'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.swingDrive'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.slerpDrive'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.drivePosition'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.driveOrientation'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.driveLinearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.driveAngularVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.projectionDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.projectionAngle'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.gearRatio'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxCapsuleShapeDesc.radius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxCapsuleShapeDesc.height'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxPlaneShape'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPlaneShapeDesc.normal'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPlaneShapeDesc.d'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphereShapeDesc.radius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTriangleMeshDesc.heightFieldVerticalExtent'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTriangleMeshDesc.convexEdgeThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxTriangleMeshShape.overlapAABBTriangles(NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.nbRows'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.nbColumns'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.verticalExtent'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.thickness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.convexEdgeThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxHeightFieldShape.overlapAABBTriangles(NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxHeightFieldShape.getNormalAtShapePoint(System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxHeightFieldShape.getSmoothNormalAtShapePoint(System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldShapeDesc.heightScale'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldShapeDesc.rowScale'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldShapeDesc.columnScale'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxTireFunctionDesc'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.extremumSlip'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.extremumValue'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.asymptoteSlip'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.asymptoteValue'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.stiffnessFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxTireFunctionDesc.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.radius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.suspensionTravel'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.suspension'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.longitudalTireForceFunction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.lateralTireForceFunction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.inverseWheelMass'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.motorTorque'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.brakeTorque'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.steerAngle'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxWheelShape.setSuspension(NxSpringDesc)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxPlatformMismatch'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxCookingInterface.NxPlatformMismatch'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxBitField.getField(System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxBounds3'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxBounds3.setCenterExtents(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxTriangleFlags'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_SKIN_WIDTH'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_DEFAULT_SLEEP_LIN_VEL_SQUARED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_DEFAULT_SLEEP_ANG_VEL_SQUARED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_BOUNCE_THRESHOLD'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_DYN_FRICT_SCALING'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_STA_FRICT_SCALING'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_MAX_ANGULAR_VELOCITY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_CONTINUOUS_CD'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_VISUALIZATION_SCALE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_VISUALIZE_COLLISION_VNORMALS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_VISUALIZE_COLLISION_FNORMALS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_ADAPTIVE_FORCE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_COLL_VETO_JOINTED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_TRIGGER_TRIGGER_CALLBACK'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_CCD_EPSILON'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_SOLVER_CONVERGENCE_THRESHOLD'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_BBOX_NOISE_LEVEL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_IMPLICIT_SWEEP_CACHE_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_DEFAULT_SLEEP_ENERGY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_CONSTANT_FLUID_MAX_PACKETS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_CONSTANT_FLUID_MAX_PARTICLES_PER_STEP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_FORCE_FIELD_CUSTOM_KERNEL_EPSILON'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_IMPROVED_SPRING_SOLVER'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSceneDesc.gravity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSceneDesc.maxTimestep'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSceneDesc.maxBounds'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSceneDesc.dynamicTreeRebuildRateHint'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxParticleUpdateData'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluidEmitter'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxFluidEmitterDesc.repulsionCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxFluidDescBase.fadeInTime'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxFluidDescBase.collisionResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluidDesc'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluid'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxFluid.addParticles(NxParticleData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxFluid.saveToDesc(NxFluidDescBase*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.thickness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.density'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.bendingStiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.stretchingStiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.dampingCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.friction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.pressure'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.tearFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.collisionResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.attachmentResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.attachmentTearFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.toFluidResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.fromFluidResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.wakeUpCounter'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.sleepLinearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.relativeGridSpacing'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxCloth.dominateVertex(System.UInt32,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.particleRadius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.density'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.volumeStiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.stretchingStiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.dampingCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.friction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.tearFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.collisionResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.attachmentResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.attachmentTearFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.toFluidResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.fromFluidResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.wakeUpCounter'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.sleepLinearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.relativeGridSpacing'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxScene.createForceFieldVariety'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxScene.setGroupCollisionFlag(System.UInt16,System.UInt16,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxScene.setDominanceGroupPair(System.UInt16,System.UInt16,NxConstraintDominance*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.massLocalPose'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.massSpaceInertia'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.mass'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.linearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.angularVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.wakeUpCounter'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.linearDamping'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.angularDamping'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.maxAngularVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.CCDMotionThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.sleepLinearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.sleepAngularVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.solverIterationCount'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.sleepEnergyThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.sleepDamping'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.contactReportThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxShapeDesc.localPose'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxShapeDesc.density'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxShapeDesc.mass'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxShapeDesc.skinWidth'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxActorDescBase.globalPose'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxActorDescBase.density'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxActorDesc'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringDesc.spring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringDesc.damper'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringDesc.targetValue'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.dynamicFriction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.staticFriction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.restitution'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.dynamicFrictionV'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.staticFrictionV'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.dirOfAnisotropy'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxMaterial.setStaticFriction(System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxContactStreamIterator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxContactStreamIterator.getFeatureIndex0'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxContactStreamIterator.getFeatureIndex1'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxContactStreamIterator.getPointNormalForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxContactStreamIterator.pointNormalForce'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluidEventType'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluidEmitterEventType'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxSpringAndDamperEffector.setLinearSpring(System.Single,System.Single,System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxSpringAndDamperEffector.setLinearDamper(System.Single,System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.pos1'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.pos2'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springDistCompressSaturate'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springDistRelaxed'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springDistStretchSaturate'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springMaxCompressForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springMaxStretchForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.damperVelCompressSaturate'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.damperVelStretchSaturate'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.damperMaxCompressForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.damperMaxStretchForce'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxForceField.samplePoints(System.UInt32,NxVec3!System.Runtime.CompilerServices.IsConst*,NxVec3!System.Runtime.CompilerServices.IsConst*,NxVec3*,NxVec3*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxCapsuleForceFieldShapeDesc.radius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxCapsuleForceFieldShapeDesc.height'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitDesc.value'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitDesc.restitution'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitDesc.hardness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitPairDesc.low'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitPairDesc.high'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMotorDesc.velTarget'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMotorDesc.maxForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.localNormal'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.localAxis'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.localAnchor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.maxForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.maxTorque'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.solverExtrapolationFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.useAccelerationSpring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.limit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.motor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.spring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.projectionDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.projectionAngle'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxRevoluteJoint.setLimits(NxJointLimitPairDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.swingAxis'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.projectionDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.twistLimit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.swingLimit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.twistSpring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.swingSpring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.jointSpring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxDistanceJointDesc.maxDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxDistanceJointDesc.minDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxDistanceJointDesc.spring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.pulley'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.distance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.stiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.ratio'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.motor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftDesc.value'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftDesc.restitution'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftDesc.spring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftDesc.damping'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftPairDesc.low'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftPairDesc.high'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.linearLimit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.swing1Limit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.swing2Limit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.twistLimit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.xDrive'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.swingDrive'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.slerpDrive'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.drivePosition'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.driveOrientation'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.driveLinearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.driveAngularVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.projectionDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.projectionAngle'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.gearRatio'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxCapsuleShapeDesc.radius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxCapsuleShapeDesc.height'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxPlaneShape'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPlaneShapeDesc.normal'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPlaneShapeDesc.d'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphereShapeDesc.radius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTriangleMeshDesc.heightFieldVerticalExtent'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTriangleMeshDesc.convexEdgeThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxTriangleMeshShape.overlapAABBTriangles(NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.nbRows'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.nbColumns'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.verticalExtent'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.thickness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.convexEdgeThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxHeightFieldShape.overlapAABBTriangles(NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxHeightFieldShape.getNormalAtShapePoint(System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxHeightFieldShape.getSmoothNormalAtShapePoint(System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldShapeDesc.heightScale'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldShapeDesc.rowScale'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldShapeDesc.columnScale'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxTireFunctionDesc'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.extremumSlip'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.extremumValue'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.asymptoteSlip'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.asymptoteValue'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.stiffnessFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxTireFunctionDesc.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.radius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.suspensionTravel'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.suspension'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.longitudalTireForceFunction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.lateralTireForceFunction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.inverseWheelMass'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.motorTorque'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.brakeTorque'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.steerAngle'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxWheelShape.setSuspension(NxSpringDesc)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxPlatformMismatch'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxCookingInterface.NxPlatformMismatch'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxBitField.getField(System.UInt32,System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxBounds3'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxBounds3.setCenterExtents(NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,NxVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxTriangleFlags'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_SKIN_WIDTH'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_DEFAULT_SLEEP_LIN_VEL_SQUARED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_DEFAULT_SLEEP_ANG_VEL_SQUARED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_BOUNCE_THRESHOLD'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_DYN_FRICT_SCALING'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_STA_FRICT_SCALING'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_MAX_ANGULAR_VELOCITY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_CONTINUOUS_CD'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_VISUALIZATION_SCALE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_VISUALIZE_COLLISION_VNORMALS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_VISUALIZE_COLLISION_FNORMALS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_ADAPTIVE_FORCE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_COLL_VETO_JOINTED'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_TRIGGER_TRIGGER_CALLBACK'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_CCD_EPSILON'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_SOLVER_CONVERGENCE_THRESHOLD'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_BBOX_NOISE_LEVEL'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_IMPLICIT_SWEEP_CACHE_SIZE'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_DEFAULT_SLEEP_ENERGY'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_CONSTANT_FLUID_MAX_PACKETS'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_CONSTANT_FLUID_MAX_PARTICLES_PER_STEP'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_FORCE_FIELD_CUSTOM_KERNEL_EPSILON'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NX_IMPROVED_SPRING_SOLVER'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSceneDesc.gravity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSceneDesc.maxTimestep'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSceneDesc.maxBounds'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSceneDesc.dynamicTreeRebuildRateHint'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxParticleUpdateData'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluidEmitter'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxFluidEmitterDesc.repulsionCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxFluidDescBase.fadeInTime'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxFluidDescBase.collisionResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluidDesc'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluid'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxFluid.addParticles(NxParticleData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxFluid.saveToDesc(NxFluidDescBase*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.thickness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.density'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.bendingStiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.stretchingStiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.dampingCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.friction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.pressure'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.tearFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.collisionResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.attachmentResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.attachmentTearFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.toFluidResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.fromFluidResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.wakeUpCounter'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.sleepLinearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxClothDesc.relativeGridSpacing'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxCloth.dominateVertex(System.UInt32,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.particleRadius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.density'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.volumeStiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.stretchingStiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.dampingCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.friction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.tearFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.collisionResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.attachmentResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.attachmentTearFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.toFluidResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.fromFluidResponseCoefficient'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.wakeUpCounter'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.sleepLinearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSoftBodyDesc.relativeGridSpacing'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxScene.createForceFieldVariety'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxScene.setGroupCollisionFlag(System.UInt16,System.UInt16,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxScene.setDominanceGroupPair(System.UInt16,System.UInt16,NxConstraintDominance*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.massLocalPose'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.massSpaceInertia'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.mass'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.linearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.angularVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.wakeUpCounter'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.linearDamping'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.angularDamping'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.maxAngularVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.CCDMotionThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.sleepLinearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.sleepAngularVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.solverIterationCount'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.sleepEnergyThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.sleepDamping'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxBodyDesc.contactReportThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxShapeDesc.localPose'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxShapeDesc.density'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxShapeDesc.mass'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxShapeDesc.skinWidth'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxActorDescBase.globalPose'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxActorDescBase.density'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxActorDesc'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringDesc.spring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringDesc.damper'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringDesc.targetValue'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.dynamicFriction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.staticFriction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.restitution'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.dynamicFrictionV'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.staticFrictionV'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMaterialDesc.dirOfAnisotropy'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxMaterial.setStaticFriction(System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxContactStreamIterator'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxContactStreamIterator.getFeatureIndex0'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxContactStreamIterator.getFeatureIndex1'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxContactStreamIterator.getPointNormalForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxContactStreamIterator.pointNormalForce'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluidEventType'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxFluidEmitterEventType'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxSpringAndDamperEffector.setLinearSpring(System.Single,System.Single,System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxSpringAndDamperEffector.setLinearDamper(System.Single,System.Single,System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.pos1'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.pos2'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springDistCompressSaturate'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springDistRelaxed'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springDistStretchSaturate'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springMaxCompressForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.springMaxStretchForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.damperVelCompressSaturate'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.damperVelStretchSaturate'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.damperMaxCompressForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSpringAndDamperEffectorDesc.damperMaxStretchForce'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxForceField.samplePoints(System.UInt32,NxVec3!System.Runtime.CompilerServices.IsConst*,NxVec3!System.Runtime.CompilerServices.IsConst*,NxVec3*,NxVec3*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxCapsuleForceFieldShapeDesc.radius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxCapsuleForceFieldShapeDesc.height'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitDesc.value'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitDesc.restitution'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitDesc.hardness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitPairDesc.low'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitPairDesc.high'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMotorDesc.velTarget'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxMotorDesc.maxForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.localNormal'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.localAxis'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.localAnchor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.maxForce'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.maxTorque'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.solverExtrapolationFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointDesc.useAccelerationSpring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.limit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.motor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.spring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.projectionDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxRevoluteJointDesc.projectionAngle'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxRevoluteJoint.setLimits(NxJointLimitPairDesc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.swingAxis'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.projectionDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.twistLimit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.swingLimit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.twistSpring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.swingSpring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphericalJointDesc.jointSpring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxDistanceJointDesc.maxDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxDistanceJointDesc.minDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxDistanceJointDesc.spring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.pulley'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.distance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.stiffness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.ratio'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPulleyJointDesc.motor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftDesc.value'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftDesc.restitution'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftDesc.spring'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftDesc.damping'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftPairDesc.low'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxJointLimitSoftPairDesc.high'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.linearLimit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.swing1Limit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.swing2Limit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.twistLimit'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.xDrive'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.swingDrive'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.slerpDrive'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.drivePosition'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.driveOrientation'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.driveLinearVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.driveAngularVelocity'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.projectionDistance'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.projectionAngle'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxD6JointDesc.gearRatio'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxCapsuleShapeDesc.radius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxCapsuleShapeDesc.height'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxPlaneShape'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPlaneShapeDesc.normal'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxPlaneShapeDesc.d'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxSphereShapeDesc.radius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTriangleMeshDesc.heightFieldVerticalExtent'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTriangleMeshDesc.convexEdgeThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxTriangleMeshShape.overlapAABBTriangles(NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.nbRows'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.nbColumns'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.verticalExtent'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.thickness'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldDesc.convexEdgeThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxHeightFieldShape.overlapAABBTriangles(NxBounds3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxHeightFieldShape.getNormalAtShapePoint(System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxHeightFieldShape.getSmoothNormalAtShapePoint(System.Single,System.Single)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldShapeDesc.heightScale'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldShapeDesc.rowScale'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxHeightFieldShapeDesc.columnScale'. -->
        <!-- Discarding badly formed XML document comment for member 'T:NxTireFunctionDesc'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.extremumSlip'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.extremumValue'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.asymptoteSlip'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.asymptoteValue'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxTireFunctionDesc.stiffnessFactor'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxTireFunctionDesc.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.radius'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.suspensionTravel'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.suspension'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.longitudalTireForceFunction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.lateralTireForceFunction'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.inverseWheelMass'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.motorTorque'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.brakeTorque'. -->
        <!-- Discarding badly formed XML document comment for member 'F:NxWheelShapeDesc.steerAngle'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxWheelShape.setSuspension(NxSpringDesc)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxPlatformMismatch'. -->
        <!-- Discarding badly formed XML document comment for member 'M:NxCookingInterface.NxPlatformMismatch'. -->
    </members>
</doc>